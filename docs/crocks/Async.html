<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta content="minimum-scale=1.0, width=device-width" name="viewport"><meta name="description" content="Async Crock"><title>Async - Crocks</title><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700|Roboto+Mono"><!-- inject:css --><link rel="stylesheet" href="/crocks/vendor/icon-12/icon-12.css"><link rel="stylesheet" href="/crocks/vendor/galano/galano.css"><link rel="stylesheet" href="/crocks/vendor/icon-16/icon-16.css"><link rel="stylesheet" href="/crocks/vendor/senna/senna.css"><link rel="stylesheet" href="/crocks/vendor/codemirror/lib/codemirror.css"><link rel="stylesheet" href="/crocks/vendor/codemirror/theme/blackboard.css"><!-- endinject --><!-- inject:js --><script src="/crocks/js/bundles/shared.electric.js"></script><script src="/crocks/vendor/senna/senna.js"></script><script src="/crocks/vendor/codemirror/lib/codemirror.js"></script><script src="/crocks/vendor/codemirror/mode/haskell/haskell.js"></script><script src="/crocks/vendor/codemirror/mode/javascript/javascript.js"></script><!-- endinject --><link rel="icon" href="/crocks/images/favicon.ico" type="image/x-icon"><link rel="stylesheet" href="/crocks/styles/main.css"></head><body data-senna><div data-senna-surface id="wrapper"><div class="senna-loading-bar"></div><!-- inject:metal:js --><div id="pageComponent"><div class="main"><main class="guide"><div class="docs"><nav class="topbar topbar-light topbar-docs"><div class="topbar-logo"><a class="topbar-logo-link" href="/crocks"><span class="topbar-logo-icon icon-16-loop"></span><h3 class="topbar-logo-text">Crocks</h3></a></div><nav class="topbar-menu"><button class="topbar-toggle">Menu</button><ul class="topbar-list"><li class="topbar-item"><a class="topbar-link topbar-link-selected" href="/crocks/docs/" target="undefined"><span>Documentation</span></a></li></ul></nav></nav><nav class="sidebar"><a class="sidebar-header toggler-header-collapsed"><span class="sidebar-icon icon-16-menu"></span><span>Docs Menu</span><span class="sidebar-icon-right"><span class="icon-12-arrow-down-short"></span><span class="icon-12-arrow-up-short"></span></span></a><div class="sidebar-toggler-content toggler-collapsed"><div class="sidebar-search"><div class="page-autocomplete"><div class="form-group"><div class="input-inner-addon input-inner-addon-right"><input autocomplete="off" class="form-control" name="q" placeholder="Search Docs" ref="input" required type="text" ><span class="input-inner-icon-helper icon-16-magnifier"></span></div></div></div></div><nav class=""><ul class="sidebar-list sidebar-list-1"><li class="sidebar-item"><a class="sidebar-link " href="/crocks/docs/getting-started.html"><span class="sidebar-icon icon-16-arrow-right-rod"></span><span>Getting Started</span></a></li><li class="sidebar-item active"><a class="sidebar-link sidebar-link-selected" href="/crocks/docs/crocks/"><span class="sidebar-icon icon-16-code-file"></span><span>Crocks</span></a><nav class=""><ul class="sidebar-list sidebar-list-1"><li class="sidebar-item"><a class="sidebar-link " href="/crocks/docs/crocks/Arrow.html"><span>Arrow</span></a></li><li class="sidebar-item active"><a class="sidebar-link sidebar-link-selected" href="/crocks/docs/crocks/Async.html"><span>Async</span></a></li><li class="sidebar-item"><a class="sidebar-link " href="/crocks/docs/crocks/Equiv.html"><span>Equiv</span></a></li><li class="sidebar-item"><a class="sidebar-link " href="/crocks/docs/crocks/Maybe.html"><span>Maybe</span></a></li><li class="sidebar-item"><a class="sidebar-link " href="/crocks/docs/crocks/Pred.html"><span>Pred</span></a></li><li class="sidebar-item"><a class="sidebar-link " href="/crocks/docs/crocks/Reader.html"><span>Reader</span></a></li><li class="sidebar-item"><a class="sidebar-link " href="/crocks/docs/crocks/ReaderT.html"><span>ReaderT</span></a></li><li class="sidebar-item"><a class="sidebar-link " href="/crocks/docs/crocks/State.html"><span>State</span></a></li></ul></nav></li><li class="sidebar-item"><a class="sidebar-link " href="/crocks/docs/monoids/"><span class="sidebar-icon icon-16-code-file"></span><span>Monoids</span></a><nav class=""><ul class="sidebar-list sidebar-list-1"><li class="sidebar-item"><a class="sidebar-link " href="/crocks/docs/monoids/All.html"><span>All</span></a></li><li class="sidebar-item"><a class="sidebar-link " href="/crocks/docs/monoids/Any.html"><span>Any</span></a></li><li class="sidebar-item"><a class="sidebar-link " href="/crocks/docs/monoids/Assign.html"><span>Assign</span></a></li><li class="sidebar-item"><a class="sidebar-link " href="/crocks/docs/monoids/Endo.html"><span>Endo</span></a></li><li class="sidebar-item"><a class="sidebar-link " href="/crocks/docs/monoids/First.html"><span>First</span></a></li><li class="sidebar-item"><a class="sidebar-link " href="/crocks/docs/monoids/Last.html"><span>Last</span></a></li><li class="sidebar-item"><a class="sidebar-link " href="/crocks/docs/monoids/Max.html"><span>Max</span></a></li><li class="sidebar-item"><a class="sidebar-link " href="/crocks/docs/monoids/Min.html"><span>Min</span></a></li><li class="sidebar-item"><a class="sidebar-link " href="/crocks/docs/monoids/Prod.html"><span>Prod</span></a></li><li class="sidebar-item"><a class="sidebar-link " href="/crocks/docs/monoids/Sum.html"><span>Sum</span></a></li></ul></nav></li><li class="sidebar-item"><a class="sidebar-link " href="/crocks/docs/functions/"><span class="sidebar-icon icon-16-code-file"></span><span>Functions</span></a><nav class=""><ul class="sidebar-list sidebar-list-1"><li class="sidebar-item"><a class="sidebar-link " href="/crocks/docs/functions/combinators.html"><span>Combinators</span></a></li><li class="sidebar-item"><a class="sidebar-link " href="/crocks/docs/functions/helpers.html"><span>Helpers</span></a></li><li class="sidebar-item"><a class="sidebar-link " href="/crocks/docs/functions/logic-functions.html"><span>Logic Functions</span></a></li><li class="sidebar-item"><a class="sidebar-link " href="/crocks/docs/functions/predicate-functions.html"><span>Predicate Functions</span></a></li><li class="sidebar-item"><a class="sidebar-link " href="/crocks/docs/functions/pointfree-functions.html"><span>Point-free Functions</span></a></li><li class="sidebar-item"><a class="sidebar-link " href="/crocks/docs/functions/transformation-functions.html"><span>Transformation Functions</span></a></li></ul></nav></li></ul></nav></div></nav><div class="sidebar-offset"><header class="guide-header"><div class="container-hybrid"><h1 class="title">Async</h1></div></header><div class="container-hybrid"><div class="docs-guide row"><div class="docs-content col-xs-16 col-md-9"><div class="guide-content"><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="haskell" ref="code">Async e a = Rejected e | Resolved a</code></pre></div><p>Defined as a &quot;lazy&quot; Sum Type that implements an asynchronous control structure,<code>Async</code> represents either the success or failure of a given asynchronous operation. The &quot;laziness&quot; of <code>Async</code> allows the ability to build complex asynchronous operations by defining each portion of that flow as smaller &quot;steps&quot; that can be composed together.</p><p>Depending on your needs, an <code>Async</code> can be constructed in a variety of ways. The typical closely resembles how a <code>Promise</code> is constructed with one major difference, the arguments used in the function that is passed to the <code>Promise</code>constructor are reversed in an <code>Async</code> to match the order in which Async is parameterized.</p><p>There are many ways to represent asynchronous operations in JavaScript, and as such, the libraries available to us in our ecosystem provide different means to take advantage of these operations. The two most common use either <code>Promise</code> returning functions or allow for the Continuation Passing Style prevalent in the asynchronous function that ship with NodeJS. <code>Async</code> provides (2) construction helpers that wrap functions using these styles of asynchronous processing and will give you back a function that takes the same arguments as the original and will return an <code>Async</code> instead. These functions are called <a href="#frompromise"><code>fromPromise</code></a> and <a href="#fromnode"><code>fromNode</code></a>.</p><p><code>Async</code> instances wrap asynchronous functions and are considered lazy, in that they will not run or execute until needed. This typically happens at an edge in a program and is done by executing the <a href="#fork"><code>fork</code></a> method available on the instance, which takes (2) functions as its arguments.</p><p>The first function passed to <a href="#fork"><code>fork</code></a> will be called on a <a href="#rejected"><code>Rejected</code></a> instance and passed the value the <code>Async</code> was rejected with. The second function is called when <a href="#fork"><code>fork</code></a> is invoked on a <a href="#resolved"><code>Resolved</code></a> instance receiving the value the <code>Async</code> was resolved with.</p><p>At times, in a given environment, it may not be feasible to run an asynchronous flow to completion. To address when these use cases pop up, the <a href="#fork"><code>fork</code></a> function will return a function that ignores its arguments and returns a <code>Unit</code>. When this function is called, <code>Async</code> will finish running the current &quot;in flight&quot; computation to completion, but will cease all remaining execution. Cancellation with <code>Async</code> is total and will cancel silently, without notification.</p><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="javascript" ref="code">import Async from &#39;crocks/Async&#39;

import maybeToAsync from &#39;crocks/Async/maybeToAsync&#39;

import First from &#39;crocks/First&#39;
import equals from &#39;crocks/pointfree/equals&#39;
import map from &#39;crocks/pointfree/map&#39;
import mreduceMap from &#39;crocks/helpers/mreduceMap&#39;
import pick from &#39;crocks/helpers/pick&#39;
import safe from &#39;crocks/Maybe/safe&#39;

// log :: String -&gt; a -&gt; a
const log = label =&gt; x =&gt;
  (console.log(`${label}:`, x), x)

// propEq :: (String, a) -&gt; Object -&gt; Boolean
const propEq = (key, value) =&gt;
  x =&gt; equals(x[key], value)

// findById :: Foldable f =&gt; (a -&gt; Boolean) -&gt; f a -&gt; Maybe a
const findById = id =&gt;
  mreduceMap(First, safe(propEq(&#39;id&#39;, id)))

// getById :: Number -&gt; Async String Object
function getById(id) {
  const data = [
    { id: 1, name: &#39;Jimmothy Schmidt&#39;, age: 24 },
    { id: 2, name: &#39;Tori Blackwood&#39;, age: 21 },
    { id: 3, name: &#39;Joey Mc Carthy&#39;, age: 27 }
  ]

  return Async(
    (rej, res) =&gt; setTimeout(() =&gt; res(data), 1000)
  ).chain(maybeToAsync(`id: ${id} -- Not Found`, findById(id)))
}

getById(3)
  .map(pick([ &#39;id&#39;, &#39;name&#39; ]))
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; res: { id: 3, name: &#39;Joey Mc Carthy&#39; }

getById(5)
  .map(pick([ &#39;id&#39;, &#39;name&#39; ]))
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; rej: &quot;id: 5 -- Not Found&quot;

// cancel :: () -&gt; ()
const cancel = getById(1).fork(
  log(&#39;rej&#39;),
  log(&#39;res&#39;),
  () =&gt; console.log(&#39;cancelled&#39;)
)

setTimeout(cancel, 500)
//=&gt; &quot;cancelled&quot;

Async
  .all(map(getById, [ 1, 2 ]))
  .map(map(pick([ &#39;id&#39;, &#39;name&#39; ])))
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; res: [
//=&gt;   { id: 1, name: &#39;Jimmothy Schmidt&#39; },
//=&gt;   { id: 2, name: &#39;Tori Blackwood&#39; },
//=&gt; ]

Async
  .all(map(getById, [ 3, 14 ]))
  .map(map(pick([ &#39;id&#39;, &#39;name&#39; ])))
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; rej:  &quot;id: 14 -- Not Found&quot;</code></pre></div><article id="topic-implements"><h2><a id="implements"href="#implements">Implements</a></h2><p><code>Functor</code>, <code>Alt</code>,  <code>Bifunctor</code>, <code>Apply</code>, <code>Chain</code>, <code>Applicative</code>, <code>Monad</code></p></article><article id="topic-constructor"><h2><a id="constructor-methods"href="#constructor-methods">Constructor Methods</a></h2><h4><a id="rejected"href="#rejected">Rejected</a></h4><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="haskell" ref="code">Async.Rejected :: e -&gt; Async e a</code></pre></div><p>Used to construct a <code>Rejected</code> instance of <code>Async</code> that represents the failure or &quot;false&quot; case of the disjunction. Calling <code>Rejected</code> with a given value, will return a new <code>Rejected</code> instance, wrapping the provided value.</p><p>When an instance is <code>Rejected</code>, most <code>Async</code> returning methods on the instance will return another <code>Rejected</code> instance. This is in contrast to a javascript <code>Promise</code>, that will continue on a <a href="#resolved"><code>Resolved</code></a> path after a <code>catch</code>. This behavior of <code>Promise</code>s provide challenges when constructing complicated (or even some simple) <code>Promise</code> chains that may fail at various steps along the chain.</p><p>Even though <code>Async</code> is a <code>Bifunctor</code>, in most cases it is desired to keep the type of a <code>Rejected</code> fixed to a type for a given flow. Given that <code>Async</code> is a <code>Bifunctor</code>, it is easy to make sure you get the type you need at the edge by leaning on <a href="#bimap"><code>bimap</code></a> to &quot;square things up&quot;.</p><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="javascript" ref="code">import Async from &#39;crocks/Async&#39;

const { Rejected } = Async

// log :: String -&gt; a -&gt; a
const log = label =&gt; x =&gt;
  (console.log(`${label}:`, x), x)

// m :: Async String a
const m = Async(
  rej =&gt; { rej(&#39;Some Error&#39;) }
)

// n :: Async String a
const n =
  Rejected(&#39;Some Error&#39;)

m.fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; rej: &quot;Some Error&quot;

n.fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; rej: &quot;Some Error&quot;</code></pre></div><h4><a id="resolved"href="#resolved">Resolved</a></h4><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="haskell" ref="code">Async.Resolved :: a -&gt; Async e a</code></pre></div><p>Used to construct a <code>Resolved</code> instance that represents the success or &quot;true&quot; portion of the disjunction. <code>Resolved</code> will wrap any given value passed to this constructor in the <code>Resolved</code> instance it returns, signaling the validity of the wrapped value.</p><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="javascript" ref="code">import Async from &#39;crocks/Async&#39;

const { Resolved } = Async

// log :: String -&gt; a -&gt; a
const log = label =&gt; x =&gt;
  (console.log(`${label}:`, x), x)

// m :: Async e Number
const m = Async(
  (rej, res) =&gt; { res(97) }
)

// n :: Async e Number
const n =
  Resolved(97)

m.fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; res: 97

n.fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; res: 97</code></pre></div><h4><a id="frompromise"href="#frompromise">fromPromise</a></h4><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="haskell" ref="code">Async.fromPromise :: (* -&gt; Promise a e) -&gt; (* -&gt; Async e a)</code></pre></div><p>Used to turn an &quot;eager&quot; <code>Promise</code> returning function, into a function that takes the same arguments but returns a &quot;lazy&quot; <code>Async</code> instance instead. Due to the lazy nature of <code>Async</code>, any curried interface will not be respected on the provided function. This can be solved by wrapping the resulting function with <a href="../functions/helpers.html#nary"><code>nAry</code></a>, which will provide a curried function that will return the desired <code>Async</code>.</p><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="javascript" ref="code">import Async from &#39;crocks/Async&#39;

import ifElse from &#39;crocks/logic/ifElse&#39;
import isNumber from &#39;crocks/predicates/isNumber&#39;
import nAry from &#39;crocks/helpers/nAry&#39;

const { fromPromise } = Async

// log :: String -&gt; a -&gt; a
const log = label =&gt; x =&gt;
  (console.log(`${label}:`, x), x)

// safeProm :: ((a -&gt; Boolean), a) -&gt; Promise a a
const safeProm = (pred, x) =&gt; new Promise(
  (res, rej) =&gt; ifElse(pred, res, rej, x)
)

safeProm(isNumber, 34)
  .then(log(&#39;resProm&#39;))
//=&gt; resProm: 34

safeProm(isNumber, &#39;34&#39;)
  .catch(log(&#39;rejProm&#39;))
//=&gt; rejProm: &quot;34&quot;

// safeAsync :: (a -&gt; Boolean) -&gt; a -&gt; Async a a
const safeAsync =
  nAry(2, fromPromise(safeProm))

// numAsync :: a -&gt; Async a Number
const numAsync =
  safeAsync(isNumber)

numAsync(34)
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; res: 34

numAsync(&#39;34&#39;)
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; rej: &quot;34&quot;</code></pre></div><h4><a id="fromnode"href="#fromnode">fromNode</a></h4><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="haskell" ref="code">NodeCallback :: (e, a) -&gt; ()
Async.fromNode :: ((*, NodeCallback) -&gt; ()) -&gt; (* -&gt; Async e a)
Async.fromNode :: (((*, NodeCallback) -&gt; ()), ctx) -&gt; (* -&gt; Async e a)</code></pre></div><p>Many of the asynchronous functions that ship with Node JS provide a Continuation Passing Style, that requires the use of a callback function to be passed as the last argument. The provided callback functions are binary functions that take an <code>err</code> as the first argument, which is <code>null</code> when there is no error to be reported. The second argument is the <code>data</code> representing the result of the function in the case that there is no error present.</p><p>This interface can create the fabled pyramid of callback doom when trying to combine multiple asynchronous calls. <code>fromNode</code> can be used to wrap functions of this style. Just pass the desired function to wrap and <code>fromNode</code> will give back a new function, that takes the same number of arguments, minus the callback function.</p><p>When the provided function is called, it returns a &quot;lazy&quot; <code>Async</code>. When the resulting instance is forked, if the <code>err</code> is a non-null value then the instance will be <a href="#rejected"><code>Rejected</code></a> with the <code>err</code> value. When the <code>err</code> is null, then the instance will become <a href="#resolved"><code>Resolved</code></a> with the <code>data</code> value.</p><p>There are some libraries whose functions are methods on some stateful object. As such, the need for binding may arise. <code>fromNode</code> provides a second, optional argument that takes the context that will be used to bind the function being wrapped.</p><p>Like <a href="#frompromise"><code>fromPromise</code></a>, any curried interface will not be respected. If a curried interface is needed then <a href="../functions/helpers.html#nary"><code>nAry</code></a> can be used.</p><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="javascript" ref="code">import Async from &#39;crocks/Async&#39;

import curry from &#39;crocks/helpers/curry&#39;
import isNumber from &#39;crocks/predicates/isNumber&#39;
import nAry from &#39;crocks/helpers/nAry&#39;
import partial from &#39;crocks/helpers/partial&#39;

const { fromNode } = Async

// log :: String -&gt; a -&gt; a
const log = curry(label =&gt; x =&gt;
  (console.log(`${label}:`, x), x)
)

// NodeCallback :: (e, a) -&gt; ()
// delay :: (Number, a, NodeCallback (String, Number)) -&gt; ()
function delay(delay, val, cb) {
  setTimeout(
    () =&gt; isNumber(val) ? cb(null, val) : cb(&#39;No Number&#39;),
    delay
  )
}

// callback :: (e, a) -&gt; ()
const callback = (err, data) =&gt; {
  err ? log(&#39;err&#39;, err) : log(&#39;data&#39;, data)
}

// wait500 :: a -&gt; NodeCallback (String, Number) -&gt; ()
const wait500 =
  partial(delay, 500)

wait500(32, callback)
//=&gt; data: 32

wait500(&#39;32&#39;, callback)
//=&gt; err: &quot;No Number&quot;

// delayAsync :: Number -&gt; a -&gt; Async String Number
const delayAsync =
  nAry(2, fromNode(delay))

// waitAsync :: a -&gt; Async String Number
const waitAsync =
  delayAsync(1000)

waitAsync(32)
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; res: 32

waitAsync(&#39;32&#39;)
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; rej: &quot;No Number&quot;</code></pre></div><h4><a id="all"href="#all">all</a></h4><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="haskell" ref="code">Async.all :: [ Async e a ] -&gt; Async e [ a ]</code></pre></div><p><code>Async</code> provides an <code>all</code> method that can be used when multiple, independent asynchronous operations need to be run in parallel. <code>all</code> takes an <code>Array</code> of<code>Async</code> instances that, when forked, will execute each instance in the provided <code>Array</code> in parallel.</p><p>If any of the instances result in a <a href="#rejected"><code>Rejected</code></a> state, the entire flow will be <a href="#rejected"><code>Rejected</code></a> with value of the first <a href="#rejected"><code>Rejected</code></a> instance. If all instances resolve, then the entire instance is <a href="#resolved"><code>Resolved</code></a> with an <code>Array</code> containing all <a href="#resolved"><code>Resolved</code></a> values in their provided order.</p><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="javascript" ref="code">import Async from &#39;crocks/Async&#39;

const { all, Rejected, Resolved } = Async

// log :: String -&gt; a -&gt; a
const log = label =&gt; x =&gt;
  (console.log(`${label}:`, x), x)

all([ Resolved(1), Resolved(2), Resolved(3) ])
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; res: [ 1, 2, 3 ]

all([ Resolved(1), Rejected(2), Rejected(3) ])
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; rej: 2</code></pre></div><h4><a id="of"href="#of">of</a></h4><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="haskell" ref="code">Async.of :: a -&gt; Async e a</code></pre></div><p>Used to wrap any value into an <code>Async</code> as a <a href="#resolved"><code>Resolved</code></a> instance, <code>of</code> is used mostly by helper functions that work &quot;generically&quot; with instances of either <code>Applicative</code> or <code>Monad</code>. When working specifically with the <code>Async</code> type, the <a href="#resolved"><code>Resolved</code></a> constructor should be used. Reach for <code>of</code> when working with functions that will work with ANY <code>Applicative</code>/<code>Monad</code>.</p><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="javascript" ref="code">import Async from &#39;crocks/Async&#39;

const { Resolved } = Async

// log :: String -&gt; a -&gt; a
const log = label =&gt; x =&gt;
  (console.log(`${label}:`, x), x)

Async.of(&#39;U Wut M8&#39;)
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; res: &quot;U Wut M8&quot;

Resolved(&#39;U Wut M8&#39;)
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; res: &quot;U Wut M8&quot;

Async((rej, res) =&gt; res(&#39;U Wut M8&#39;))
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; res: &quot;U Wut M8&quot;</code></pre></div></article><article id="topic-instance"><h2><a id="instance-methods"href="#instance-methods">Instance Methods</a></h2><h4><a id="map"href="#map">map</a></h4><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="haskell" ref="code">Async e a ~&gt; (a -&gt; b) -&gt; Async e b</code></pre></div><p>Used to apply transformations to <a href="#resolved"><code>Resolved</code></a> values of an <code>Async</code>, <code>map</code> takes a function that it will lift into the context of the <code>Async</code> and apply to it the wrapped value. When ran on a <a href="#resolved"><code>Resolved</code></a> instance, <code>map</code> will apply the wrapped value to the provided function and return the result in a new <a href="#resolved"><code>Resolved</code></a> instance.</p><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="javascript" ref="code">import Async from &#39;crocks/Async&#39;

import and from &#39;crocks/logic/and&#39;
import compose from &#39;crocks/helpers/compose&#39;
import constant from &#39;crocks/combinators/constant&#39;
import ifElse from &#39;crocks/logic/ifElse&#39;
import isNumber from &#39;crocks/predicates/isNumber&#39;
import map from &#39;crocks/pointfree/map&#39;

const { Rejected, Resolved } = Async

// log :: String -&gt; a -&gt; a
const log = label =&gt; x =&gt;
  (console.log(`${label}:`, x), x)

// double :: Number -&gt; Number
const double =
  x =&gt; x * 2

// gt10 :: Number -&gt; Boolean
const gt10 =
  x =&gt; x &gt; 10

// isValid :: a -&gt; Async String Number
const isValid = ifElse(
  and(isNumber, gt10),
  Resolved,
  constant(Rejected(&#39;Not Valid&#39;))
)

// doubleValid :: a -&gt; Async String Number
const doubleValid =
  compose(map(double), isValid)

Resolved(34)
  .map(double)
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; res: 68

Rejected(&#39;34&#39;)
  .map(double)
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; rej: &quot;34&quot;

doubleValid(76)
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; res: 152

doubleValid(&#39;Too Silly&#39;)
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; rej: &quot;Not Valid&quot;</code></pre></div><h4><a id="alt"href="#alt">alt</a></h4><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="haskell" ref="code">Async e a ~&gt; Async e a -&gt; Async e a</code></pre></div><p>Providing a means for a fallback or alternative value, <code>alt</code> combines (2)<code>Async</code> instances and will return the first <a href="#resolved"><code>Resolved</code></a> instance it encounters or the last <a href="#rejected"><code>Rejected</code></a> instance if it does not encounter a <a href="#resolved"><code>Resolved</code></a> instance.</p><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="javascript" ref="code">import Async from &#39;crocks/Async&#39;

const { Rejected, Resolved } = Async

// log :: String -&gt; a -&gt; a
const log = label =&gt; x =&gt;
  (console.log(`${label}:`, x), x)

Resolved(true)
  .alt(Rejected(&#39;Bad News&#39;))
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; res: true

Rejected(&#39;First Reject&#39;)
  .alt(Rejected(&#39;Second Reject&#39;))
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; rej: &quot;Second Reject&quot;

Rejected(&#39;First Reject&#39;)
  .alt(Resolved(&#39;First Resolve&#39;))
  .alt(Rejected(&#39;Second Reject&#39;))
  .alt(Resolved(&#39;Second Resolve&#39;))
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; rej: &quot;First Resolve&quot;</code></pre></div><h4><a id="bimap"href="#bimap">bimap</a></h4><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="haskell" ref="code">Async e a ~&gt; ((e -&gt; b), (a -&gt; c)) -&gt; Async b c</code></pre></div><p>Both <a href="#rejected"><code>Rejected</code></a> and <a href="#resolved"><code>Resolved</code></a> values can vary in their type, although most of the time, focus on mapping values is placed on the <a href="#resolved"><code>Resolved</code></a> portion. When the requirement or need to map the <a href="#rejected"><code>Rejected</code></a> portion arises, <code>bimap</code> can be used.</p><p><code>bimap</code> takes (2) functions as its arguments. The first function is used to map a <a href="#rejected"><code>Rejected</code></a> instance, while the second maps a <a href="#resolved"><code>Resolved</code></a> instance. While <code>bimap</code> requires that both possible instances are to be mapped, if the desire to map only the <a href="#rejected"><code>Rejected</code></a> portion, an <a href="../functions/combinators.html#identity"><code>identity</code></a> function can be provided to the second argument. This will leave all <a href="#resolved"><code>Resolved</code></a> instance values untouched.</p><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="javascript" ref="code">import Async from &#39;crocks/Async&#39;

import assoc from &#39;crocks/helpers/assoc&#39;
import bimap from &#39;crocks/pointfree/bimap&#39;
import compose from &#39;crocks/helpers/compose&#39;
import objOf from &#39;crocks/helpers/objOf&#39;

const { Rejected, Resolved } = Async

// log :: String -&gt; a -&gt; a
const log = label =&gt; x =&gt;
  (console.log(`${label}:`, x), x)

// hasError :: Boolean -&gt; Object -&gt; Object
const hasError =
  assoc(&#39;hasError&#39;)

// buildError :: a -&gt; String
const buildError =
  x =&gt; `${x}: is not valid`

// buildResult :: (String, Boolean) -&gt; a -&gt; Object
const buildResult = (key, isError) =&gt;
  compose(hasError(isError), objOf(key))

// finalize :: Bifunctor m =&gt; m a b -&gt; m Object Object
const finalize = bimap(
  compose(buildResult(&#39;error&#39;, true), buildError),
  buildResult(&#39;result&#39;, false)
)

finalize(Resolved(&#39;Good To Go&#39;))
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; res: { result: &quot;Good To Go&quot;, hasError: false }

finalize(Rejected(null))
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; rej: { error: &quot;null is not valid&quot;, hasError: true }</code></pre></div><h4><a id="ap"href="#ap">ap</a></h4><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="haskell" ref="code">Async e (a -&gt; b) ~&gt; Async e a -&gt; Async e b</code></pre></div><p>Short for apply, <code>ap</code> is used to apply an <code>Async</code> instance containing a value to another <code>Async</code> instance that contains a function, resulting in new <code>Async</code> instance with the result. <code>ap</code> requires that it is called on an instance that is either <a href="#rejected"><code>Rejected</code></a> or <a href="#resolved"><code>Resolved</code></a> that wraps a curried polyadic function.</p><p>When either <code>Async</code> is <a href="#rejected"><code>Rejected</code></a>, <code>ap</code> will return a <a href="#rejected"><code>Rejected</code></a> instance, that wraps the value of the original <a href="#rejected"><code>Rejected</code></a> instance. This can be used to safely combine multiple values under a given combination function. If any of the inputs result in a <a href="#rejected"><code>Rejected</code></a> than they will never be applied to the function and will not result in undesired exceptions or results.</p><p>When <a href="#fork"><code>fork</code></a>ed, all <code>Async</code>s chained with multiple <code>ap</code> invocations will be executed concurrently.</p><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="javascript" ref="code">import Async from &#39;crocks/Async&#39;

import liftA2 from &#39;crocks/helpers/liftA2&#39;

const { Rejected, Resolved } = Async

// log :: String -&gt; a -&gt; a
const log = label =&gt; x =&gt;
  (console.log(`${label}:`, x), x)

// resolveAfter :: (Integer, a) -&gt; Async e a
const resolveAfter = (delay, x) =&gt; Async(
  (rej, res) =&gt; setTimeout(() =&gt; res(x), delay)
)

// join :: String -&gt; String -&gt; String
const join =
  a =&gt; b =&gt; `${a} ${b}`

Async.of(join)
  .ap(Resolved(&#39;blip&#39;))
  .ap(Resolved(&#39;blop&#39;))
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; res: &quot;blip blop&quot;

Async.of(join)
  .ap(Resolved(&#39;blip&#39;))
  .ap(Rejected(&#39;Not Good&#39;))
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; rej: &quot;Not Good&quot;

Resolved(&#39;splish&#39;)
  .map(join)
  .ap(Resolved(&#39;splash&#39;))
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; res: &quot;splish splash&quot;

// first :: Async e String
const first =
  resolveAfter(5000, &#39;first&#39;)

// second :: Async e String
const second =
  resolveAfter(5000, &#39;second&#39;)

// `ap` runs all Asyncs at the same time in parallel.
// This will finish running in about 5 seconds and
// not 10 seconds

liftA2(join, first, second)
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; res: &quot;first second&quot;</code></pre></div><h4><a id="chain"href="#chain">chain</a></h4><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="haskell" ref="code">Async e a ~&gt; (a -&gt; Async e b) -&gt; Async e b</code></pre></div><p>Combining a sequential series of transformations that capture disjunction can be accomplished with <code>chain</code>. <code>chain</code> expects a unary, <code>Async</code> returning function as its argument. When invoked on a <a href="#rejected"><code>Rejected</code></a> instance , <code>chain</code> will not run the function, but will instead return another <a href="#rejected"><code>Rejected</code></a> instance wrapping the original <a href="#rejected"><code>Rejected</code></a> value. When called on a <a href="#resolved"><code>Resolved</code></a> instance however, the inner value will be passed to provided function, returning the result as the new instance.</p><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="javascript" ref="code">import Async from &#39;crocks/Async&#39;

import chain from &#39;crocks/pointfree/chain&#39;
import compose from &#39;crocks/helpers/compose&#39;
import composeK from &#39;crocks/helpers/composeK&#39;
import constant from &#39;crocks/combinators/constant&#39;
import flip from &#39;crocks/combinators/flip&#39;
import ifElse from &#39;crocks/logic/ifElse&#39;
import isString from &#39;crocks/predicates/isString&#39;
import prop from &#39;crocks/Maybe/prop&#39;
import maybeToAsync from &#39;crocks/Async/maybeToAsync&#39;

const { Rejected, Resolved } = Async

// log :: String -&gt; a -&gt; a
const log = label =&gt; x =&gt;
  (console.log(`${label}:`, x), x)

// safe :: (b -&gt; Boolean) -&gt; b -&gt; Async String a
const safe = pred =&gt;
  ifElse(pred, Resolved, constant(Rejected(&#39;Not Safe&#39;)))

// test :: RegExp -&gt; String -&gt; Boolean
const test = regex =&gt; str =&gt;
  regex.test(str)

// lookup :: String -&gt; Async String String
const lookup = compose(
  maybeToAsync(&#39;Not Found&#39;),
  flip(prop, { &#39;file-a&#39;: &#39;file-b&#39;, &#39;file-b&#39;: &#39;file-c&#39; })
)

// fake :: String -&gt; Async String Object
const fake = compose(
  chain(lookup),
  chain(safe(test(/^file-(a|b|c)/))),
  chain(safe(isString))
)

fake(&#39;file-a&#39;)
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; file-b

// getTwo :: a -&gt; Async String String
const getTwo =
  composeK(fake, fake)

getTwo(&#39;file-a&#39;)
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; res: file-c

getTwo(&#39;file-b&#39;)
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; rej: &quot;Not Found&quot;

getTwo(76)
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; rej: &quot;Not Safe&quot;</code></pre></div><h4><a id="coalesce"href="#coalesce">coalesce</a></h4><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="haskell" ref="code">Async e a ~&gt; ((e -&gt; b), (a -&gt; b))) -&gt; Async e b</code></pre></div><p>Used as a means to apply a computation to a <a href="#resolved"><code>Resolved</code></a> instance and then map any <a href="#rejected"><code>Rejected</code></a> value while transforming it to a <a href="#resolved"><code>Resolved</code></a> to continue computation. <code>coalesce</code> on an <code>Async</code> can be used to model the all too familiar, and more imperative <code>if/else</code> flow in a more declarative manner.</p><p>The first function is used when invoked on a <a href="#rejected"><code>Rejected</code></a> instance and will return a <a href="#resolved"><code>Resolved</code></a> instance wrapping the result of the function. The second function is used when <code>coalesce</code> is invoked on a <a href="#resolved"><code>Resolved</code></a> instance and is used to map the original value, returning a new <a href="#resolved"><code>Resolved</code></a> instance wrapping the result of the second function.</p><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="javascript" ref="code">import Async from &#39;crocks/Async&#39;

import coalesce from &#39;crocks/pointfree/coalesce&#39;

const { Rejected, Resolved } = Async

// log :: String -&gt; a -&gt; a
const log = label =&gt; x =&gt;
  (console.log(`${label}:`, x), x)

// label :: String -&gt; String -&gt; String
const label =
  lbl =&gt; x =&gt; `${lbl} ${x}`

// resolve :: Async e String -&gt; Async e String
const resolve =
  coalesce(label(&#39;Was&#39;), label(&#39;Still&#39;))

resolve(Resolved(&#39;Resolved&#39;))
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; res: &quot;Still Resolved&quot;

resolve(Rejected(&#39;Rejected&#39;))
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; res: &quot;Was Rejected&quot;</code></pre></div><h4><a id="swap"href="#swap">swap</a></h4><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="haskell" ref="code">Async e a ~&gt; ((e -&gt; b), (a -&gt; c)) -&gt; Async c b</code></pre></div><p>Used to map the value of a <a href="#rejected"><code>Rejected</code></a> into a <a href="#resolved"><code>Resolved</code></a> or a <a href="#resolved"><code>Resolved</code></a> to a <a href="#rejected"><code>Rejected</code></a>, <code>swap</code> takes (2) functions as its arguments. The first function is used to map the expected <a href="#rejected"><code>Rejected</code></a> value into a <a href="#resolved"><code>Resolved</code></a>, while the second goes from <a href="#resolved"><code>Resolved</code></a> to <a href="#rejected"><code>Rejected</code></a>. If no mapping is required on either, then <a href="../functions/combinators.html#identity"><code>identity</code></a> functions can be used in one or both arguments.</p><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="javascript" ref="code">import Async from &#39;crocks/Async&#39;

import compose from &#39;crocks/helpers/compose&#39;
import identity from &#39;crocks/combinators/identity&#39;
import swap from &#39;crocks/pointfree/swap&#39;

const { Rejected, Resolved } = Async

// log :: String -&gt; a -&gt; a
const log = label =&gt; x =&gt;
  (console.log(`${label}:`, x), x)

// length :: String -&gt; Integer
const length =
  x =&gt; x.length

// repeat :: String -&gt; Number -&gt; String
const repeat =
  char =&gt; n =&gt; char.repeat(n)

// values :: Async String Number -&gt; Async String Number
const values =
  swap(length, repeat(&#39;a&#39;))

// valueIso :: Async String Number -&gt; Async String Number
const valueIso =
  compose(values, values)

// types :: Async a b -&gt; b a
const types =
  swap(identity, identity)

// typeIso :: Async a b -&gt; b a
const typeIso =
  compose(types, types)

values(Resolved(5))
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; rej: &quot;aaaaa&quot;

values(Rejected(&#39;aaaaa&#39;))
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; res: 5

valueIso(Resolved(5))
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; res: 5

valueIso(Rejected(&#39;aaaaa&#39;))
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; rej: &quot;aaaaa&quot;

types(Resolved(5))
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; rej: 5

types(Rejected(&#39;aaaaa&#39;))
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; res: &quot;aaaaa&quot;

typeIso(Resolved(5))
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; res: 5

typeIso(Rejected(&#39;aaaaa&#39;))
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; rej: &quot;aaaaa&quot;</code></pre></div><h4><a id="fork"href="#fork">fork</a></h4><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="haskell" ref="code">Async e a ~&gt; ((e -&gt; ()), (a -&gt; ())) -&gt; (() -&gt; ())
Async e a ~&gt; ((e -&gt; ()), (a -&gt; ()), (() -&gt; ())) -&gt; (() -&gt; ())</code></pre></div><p>The <code>Async</code> type is lazy and will not be executed until told to do so and <code>fork</code> is the primary method used for execution. <code>fork</code> implements (2) signatures depending on the need for clean up in the event of cancellation, but both return a function that can be used for cancellation of a given instance.</p><p>The first and more common signature takes (2) functions that will have their return values ignored. The first function will be run in the event of the<code>Async</code> instance settling on <a href="#rejected"><code>Rejected</code></a> and will receive as its single argument the value or &quot;cause&quot; of rejection. The second function provided will be executed in the case of the instance settling on <a href="#resolved"><code>Resolved</code></a> and will receive as its single argument the value the <code>Async</code> was resolved with.</p><p>The second signature is used when any cleanup needs to be performed after a given <code>Async</code> is cancelled by having the function returned from <code>fork</code> called. The first (2) arguments to the signature are the same as the more common signature described above, but takes an addition function that can be used for &quot;clean up&quot; after cancellation. When all in-flight computations settle, the function provided will be silently executed.</p><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="javascript" ref="code">import Async from &#39;crocks/Async&#39;

import compose from &#39;crocks/helpers/compose&#39;

// log :: String -&gt; a -&gt; a
const log = label =&gt; x =&gt;
  (console.log(`${label}:`, x), x)

// inc :: Number -&gt; Number
const inc =
  n =&gt; n + 1

// delay :: a -&gt; Async e a
const delay = x =&gt; Async(
  (rej, res) =&gt; { setTimeout(() =&gt; res(x), 1000) }
).map(compose(inc, log(&#39;value&#39;)))

delay(0)
  .chain(delay)
  .chain(delay)
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; value: 0
//=&gt; value: 1
//=&gt; value: 2
//=&gt; res: 3

const cancel =
  delay(0)
    .chain(delay)
    .chain(delay)
    .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; value: 0
//=&gt; value: 1

setTimeout(cancel, 2200)</code></pre></div><h4><a id="topromise"href="#topromise">toPromise</a></h4><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="haskell" ref="code">Async e a ~&gt; () -&gt; Promise a e</code></pre></div><p>While <a href="#fork"><code>fork</code></a> is the more common method for running an <code>Async</code> instance, there may come time where a <code>Promise</code> is needed at the edge of a given program or flow. When the need to integrate into an existing <code>Promise</code> chain arises, <code>Async</code> provides the <code>toPromise</code> method.</p><p><code>toPromise</code> takes no arguments and when invoked will fork the instance internally and return a <code>Promise</code> that will be in-flight. This comes in handy for integration with other <code>Promise</code> based libraries that are utilized in a given application, program or flow.</p><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="javascript" ref="code">import Async from &#39;crocks/Async&#39;

const { Rejected, Resolved } = Async

// log :: String -&gt; a -&gt; a
const log = label =&gt; x =&gt;
  (console.log(`${label}:`, x), x)

Resolved(&#39;resolved&#39;)
  .toPromise()
  .then(log(&#39;res&#39;))
  .catch(log(&#39;rej&#39;))
//=&gt; res: resolved

Rejected(&#39;rejected&#39;)
  .toPromise()
  .then(log(&#39;res&#39;))
  .catch(log(&#39;rej&#39;))
//=&gt; rej: rejected</code></pre></div></article><article id="topic-transformation"><h2><a id="transformation-functions"href="#transformation-functions">Transformation Functions</a></h2><h4><a id="eithertoasync"href="#eithertoasync">eitherToAsync</a></h4><p><code>crocks/Async/eitherToAsync</code></p><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="haskell" ref="code">eitherToAsync :: Either b a -&gt; Async b a
eitherToAsync :: (a -&gt; Either c b) -&gt; a -&gt; Async c b</code></pre></div><p>Used to transform a given <code>Either</code> instance to an <code>Async</code> instance, <code>eitherToAsync</code> will turn a <code>Right</code> instance into a <a href="#resolved"><code>Resolved</code></a> instance wrapping the original value contained in the original <code>Right</code>. If a <code>Left</code> is provided, then <code>eitherToAsync</code> will return a <a href="#rejected"><code>Rejected</code></a> instance, wrapping the original <code>Left</code> value.</p><p>Like all <code>crocks</code> transformation functions, <code>eitherToAsync</code> has (2) possible signatures and will behave differently when passed either an <code>Either</code> instance or a function that returns an instance of <code>Either</code>. When passed the instance, a transformed <code>Async</code> is returned. When passed an <code>Either</code> returning function, a function will be returned that takes a given value and returns an <code>Async</code>.</p><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="javascript" ref="code">import Async from &#39;crocks/Async&#39;
import Either from &#39;crocks/Either&#39;

import eitherToAsync from &#39;crocks/Async/eitherToAsync&#39;

import and from &#39;crocks/logic/and&#39;
import ifElse from &#39;crocks/logic/ifElse&#39;
import isNumber from &#39;crocks/predicates/isNumber&#39;

const { Resolved } = Async
const { Left, Right } = Either

// log :: String -&gt; a -&gt; a
const log = label =&gt; x =&gt;
  (console.log(`${label}:`, x), x)

// gte :: Number -&gt; Number -&gt; Boolean
const gte =
  x =&gt; y =&gt; y &gt;= x

// isLarge :: a -&gt; Boolean
const isLarge =
  and(isNumber, gte(10))

// isValid :: a -&gt; Either String a
const isValid = ifElse(
  isLarge,
  Right,
  x =&gt; Left(`${x} is not valid`)
)

eitherToAsync(Right(&#39;Correct&#39;))
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; res: &quot;Correct&quot;

eitherToAsync(Left(&#39;Not Good&#39;))
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; rej: &quot;Not Good&quot;

Resolved(54)
  .chain(eitherToAsync(isValid))
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; res: 54

Resolved(4)
  .chain(eitherToAsync(isValid))
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; rej: &quot;4 is not valid&quot;

Resolved(&#39;Bubble&#39;)
  .chain(eitherToAsync(isValid))
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; rej: &quot;Bubble is not valid&quot;</code></pre></div><h4><a id="firsttoasync"href="#firsttoasync">firstToAsync</a></h4><p><code>crocks/Async/firstToAsync</code></p><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="haskell" ref="code">firstToAsync :: e -&gt; First a -&gt; Async e a
firstToAsync :: e -&gt; (a -&gt; First b) -&gt; a -&gt; Async e b</code></pre></div><p>Used to transform a given <a href="../monoids/First.html"><code>First</code></a> instance to an <code>Async</code> instance, <code>firstToAsync</code> will turn a non-empty <a href="../monoids/First.html"><code>First</code></a> instance into a <a href="#resolved"><code>Resolved</code></a> instance wrapping the original value contained in the original non-empty.</p><p>The <a href="../monoids/First.html"><code>First</code></a> datatype is based on a <a href="../crocks/Maybe.html"><code>Maybe</code></a> and as such its left or empty value is fixed to a <code>()</code> type. As a means to allow for convenient transformation, <code>firstToAsync</code> takes a default <a href="#rejected"><code>Rejected</code></a> value as the first argument. This value will be wrapped in a resulting <a href="#rejected"><code>Rejected</code></a> instance in the case of empty.</p><p>Like all <code>crocks</code> transformation functions, <code>firstToAsync</code> has (2) possible signatures and will behave differently when passed either a <a href="../monoids/First.html"><code>First</code></a> instance or a function that returns an instance of <a href="../monoids/First.html"><code>First</code></a>. When passed the instance, a transformed <code>Async</code> is returned. When passed a <a href="../monoids/First.html"><code>First</code></a> returning function, a function will be returned that takes a given value and returns an <code>Async</code>.</p><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="javascript" ref="code">import Async from &#39;crocks/Async&#39;
import First from &#39;crocks/First&#39;

import firstToAsync from &#39;crocks/Async/firstToAsync&#39;

import Pred from &#39;crocks/Pred&#39;
import isString from &#39;crocks/predicates/isString&#39;
import mconcatMap from &#39;crocks/helpers/mconcatMap&#39;
import safe from &#39;crocks/Maybe/safe&#39;

const { Resolved } = Async

// log :: String -&gt; a -&gt; a
const log = label =&gt; x =&gt;
  (console.log(`${label}:`, x), x)

// length :: String -&gt; Number
const length =
  x =&gt; x.length

// gte :: Number -&gt; Number -&gt; Boolean
const gte =
  x =&gt; y =&gt; y &gt;= x

// isValid :: Pred String
const isValid =
  Pred(isString)
    .concat(Pred(gte(4)).contramap(length))

// firstValid :: [ String ] -&gt; First String
const firstValid =
  mconcatMap(First, safe(isValid))

// findFirstValid :: [ String ] -&gt; Async String String
const findFirstValid =
  firstToAsync(&#39;Nothing Found&#39;, firstValid)

firstToAsync(&#39;Error&#39;, First(true))
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; res: true

firstToAsync(&#39;Error&#39;, First.empty())
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; rej: &quot;Error&quot;

Resolved([ &#39;cat&#39;, &#39;rhino&#39;, &#39;unicorn&#39; ])
  .chain(findFirstValid)
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; res: &quot;rhino&quot;

Resolved([ 1, 2, 3 ])
  .chain(findFirstValid)
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; rej: &quot;Nothing Found&quot;

Resolved([ &#39;cat&#39;, &#39;bat&#39;, &#39;imp&#39; ])
  .chain(findFirstValid)
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; rej: &quot;Nothing Found&quot;</code></pre></div><h4><a id="lasttoasync"href="#lasttoasync">lastToAsync</a></h4><p><code>crocks/Async/lastToAsync</code></p><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="haskell" ref="code">lastToAsync :: e -&gt; Last a -&gt; Async e a
lastToAsync :: e -&gt; (a -&gt; Last b) -&gt; a -&gt; Async e b</code></pre></div><p>Used to transform a given <a href="../monoids/Last.html"><code>Last</code></a> instance to an <code>Async</code> instance, <code>lastToAsync</code> will turn a non-empty <a href="../monoids/Last.html"><code>Last</code></a> instance into a <a href="#resolved"><code>Resolved</code></a> instance wrapping the original value contained in the original non-empty.</p><p>The <a href="../monoids/Last.html"><code>Last</code></a> datatype is based on a <a href="../crocks/Maybe.html"><code>Maybe</code></a> and as such its left or empty value is fixed to a <code>()</code> type. As a means to allow for convenient transformation, <code>lastToAsync</code> takes a default <a href="#rejected"><code>Rejected</code></a> value as the first argument. This value will be wrapped in a resulting <a href="#rejected"><code>Rejected</code></a> instance, in the case of empty.</p><p>Like all <code>crocks</code> transformation functions, <code>lastToAsync</code> has (2) possible signatures and will behave differently when passed either a <a href="../monoids/Last.html"><code>Last</code></a> instance or a function that returns an instance of <a href="../monoids/Last.html"><code>Last</code></a>. When passed the instance, a transformed <code>Async</code> is returned. When passed a <a href="../monoids/Last.html"><code>Last</code></a> returning function, a function will be returned that takes a given value and returns an <code>Async</code>.</p><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="javascript" ref="code">import Async from &#39;crocks/Async&#39;
import Last from &#39;crocks/Last&#39;

import lastToAsync from &#39;crocks/Async/lastToAsync&#39;

import Pred from &#39;crocks/Pred&#39;
import isString from &#39;crocks/predicates/isString&#39;
import mconcatMap from &#39;crocks/helpers/mconcatMap&#39;
import safe from &#39;crocks/Maybe/safe&#39;

const { Resolved } = Async

// log :: String -&gt; a -&gt; a
const log = label =&gt; x =&gt;
  (console.log(`${label}:`, x), x)

// length :: String -&gt; Number
const length =
  x =&gt; x.length

// gte :: Number -&gt; Number -&gt; Boolean
const gte =
  x =&gt; y =&gt; y &gt;= x

// isValid :: Pred String
const isValid =
  Pred(isString)
    .concat(Pred(gte(4)).contramap(length))

// lastValid :: [ String ] -&gt; Last String
const lastValid =
  mconcatMap(Last, safe(isValid))

// findLastValid :: [ String ] -&gt; Async String String
const findLastValid =
  lastToAsync(&#39;Nothing Found&#39;, lastValid)

lastToAsync(&#39;Error&#39;, Last(true))
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; res: true

lastToAsync(&#39;Error&#39;, Last.empty())
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; rej: &quot;Error&quot;

Resolved([ &#39;unicorn&#39;, &#39;rhino&#39;, &#39;cat&#39; ])
  .chain(findLastValid)
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; res: &quot;rhino&quot;

Resolved([ 1, 2, 3 ])
  .chain(findLastValid)
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; rej: &quot;Nothing Found&quot;

Resolved([ &#39;cat&#39;, &#39;bat&#39;, &#39;imp&#39; ])
  .chain(findLastValid)
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; rej: &quot;Nothing Found&quot;</code></pre></div><h4><a id="maybetoasync"href="#maybetoasync">maybeToAsync</a></h4><p><code>crocks/Async/maybeToAsync</code></p><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="haskell" ref="code">maybeToAsync :: e -&gt; Maybe a -&gt; Async e a
maybeToAsync :: e -&gt; (a -&gt; Maybe b) -&gt; a -&gt; Async e b</code></pre></div><p>Used to transform a given <a href="../crocks/Maybe.html"><code>Maybe</code></a> instance to an <code>Async</code> instance, <code>maybeToAsync</code> will turn a <a href="../crocks/Maybe.html#just"><code>Just</code></a> instance into a <a href="#resolved"><code>Resolved</code></a> instance wrapping the original value contained in the original <a href="../crocks/Maybe.html#just"><code>Just</code></a>.</p><p>A <a href="../crocks/Maybe.html#nothing"><code>Nothing</code></a> instance is fixed to a <code>()</code> type and as such can only ever contain a value of <code>undefined</code>. As a means to allow for convenient transformation, <code>maybeToAsync</code> takes a default <a href="#rejected"><code>Rejected</code></a> value as the first argument. This value will be wrapped in a resulting <a href="#rejected"><code>Rejected</code></a> instance, in the case of <a href="../crocks/Maybe.html#nothing"><code>Nothing</code></a>.</p><p>Like all <code>crocks</code> transformation functions, <code>maybeToAsync</code> has (2) possible signatures and will behave differently when passed either a <a href="../crocks/Maybe.html"><code>Maybe</code></a> instance or a function that returns an instance of <a href="../crocks/Maybe.html"><code>Maybe</code></a>. When passed the instance, a transformed <code>Async</code> is returned. When passed a <a href="../crocks/Maybe.html"><code>Maybe</code></a> returning function, a function will be returned that takes a given value and returns an <code>Async</code>.</p><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="javascript" ref="code">import Async from &#39;crocks/Async&#39;
import Maybe from &#39;crocks/Maybe&#39;

import maybeToAsync from &#39;crocks/Async/maybeToAsync&#39;

import and from &#39;crocks/logic/and&#39;
import isEmpty from &#39;crocks/predicates/isEmpty&#39;
import isArray from &#39;crocks/predicates/isArray&#39;
import not from &#39;crocks/logic/not&#39;
import safe from &#39;crocks/Maybe/safe&#39;

const { Resolved } = Async
const { Nothing, Just } = Maybe

// log :: String -&gt; a -&gt; a
const log = label =&gt; x =&gt;
  (console.log(`${label}:`, x), x)

// isValid :: a -&gt; Maybe [ b ]
const isValid = safe(
  and(isArray, not(isEmpty))
)

maybeToAsync(false, Just(true))
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; res: true

maybeToAsync(&#39;Bad&#39;, Nothing())
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; rej: &quot;Bad&quot;

Resolved([ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ])
  .chain(maybeToAsync(&#39;Invalid&#39;, isValid))
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; res: [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ]

Resolved([])
  .chain(maybeToAsync(&#39;Invalid&#39;, isValid))
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; rej: &quot;Invalid&quot;

Resolved(&#39;&#39;)
  .chain(maybeToAsync(&#39;Invalid&#39;, isValid))
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; rej: &quot;Invalid&quot;</code></pre></div><h4><a id="resulttoasync"href="#resulttoasync">resultToAsync</a></h4><p><code>crocks/Async/resultToAsync</code></p><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="haskell" ref="code">resultToAsync :: Result b a -&gt; Async b a
resultToAsync :: (a -&gt; Result c b) -&gt; a -&gt; Result c b</code></pre></div><p>Used to transform a given <code>Result</code> instance to an <code>Async</code> instance, <code>resultToAsync</code> will turn an <code>Ok</code> instance into a <a href="#resolved"><code>Resolved</code></a> instance wrapping the original value contained in the original <code>Ok</code>. If an <code>Err</code> is provided, then <code>resultToAsync</code> will return a <a href="#rejected"><code>Rejected</code></a> instance, wrapping the original <code>Err</code> value.</p><p>Like all <code>crocks</code> transformation functions, <code>resultToAsync</code> has (2) possible signatures and will behave differently when passed either a <code>Result</code> instance or a function that returns an instance of <code>Result</code>. When passed the instance, a transformed <code>Async</code> is returned. When passed a <code>Result</code> returning function, a function will be returned that takes a given value and returns an <code>Async</code>.</p><div class="code-container"><button class="btn btn-sm btn-copy"><span class="icon-12-overlap"></span></button><pre><code class="code" data-mode="javascript" ref="code">import Async from &#39;crocks/Async&#39;

import Result from &#39;crocks/Result&#39;

import resultToAsync from &#39;crocks/Async/resultToAsync&#39;

import identity from &#39;crocks/combinators/identity&#39;
import isNumber from &#39;crocks/predicates/isNumber&#39;
import tryCatch from &#39;crocks/Result/tryCatch&#39;

const { Resolved } = Async

const { Err, Ok }  = Result

// log :: String -&gt; a -&gt; a
const log = label =&gt; x =&gt;
  (console.log(`${label}:`, x), x)

// notNumber :: a -&gt; Number
function notNumber(x) {
  if (!isNumber(x)) {
    throw new TypeError(&#39;Must be a Number&#39;)
  }
  return x
}

// safeFail :: a -&gt; Result TypeError Number
const safeFail =
  tryCatch(notNumber)

resultToAsync(Ok(99))
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; res: 99

resultToAsync(Err(&#39;Not Good&#39;))
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; rej: &quot;Not Good&quot;

Resolved(103)
  .chain(resultToAsync(safeFail))
  .bimap(x =&gt; x.message, identity)
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; res: 103

Resolved(&#39;103&#39;)
  .chain(resultToAsync(safeFail))
  .bimap(x =&gt; x.message, identity)
  .fork(log(&#39;rej&#39;), log(&#39;res&#39;))
//=&gt; rej: &quot;Must be a Number&quot;</code></pre></div></article><input type="hidden" value="Async"><input type="hidden" value="Crocks"></div><div class="contribute"><div class="contribute-img"><span class="icon-16-github"></span></div><div class="contribute-text"><p>Contribute on Github! <a href="https://github.com/evilsoft/crocks/tree/master/docs/src/pages/docs/crocks/Async.md" class="contribute-link" target="_blank">Edit this section</a>.</p></div></div></div><nav class="col-xs-16 col-md-offset-2 col-md-5"><div class="docs-nav-container"><div class="affix-top docs-nav"><div ref="readingContainer"></div></div></div></nav></div></div></div></div></main></div></div><script src="/crocks/js/bundles/qfSev.js"></script><script>var data = JSON.parse('{\x22pageLocation\x22:\x22index.children.docs.children.crocks.children.Async\x22,\x22site\x22:{\x22title\x22:\x22Crocks\x22,\x22githubRepo\x22:\x22evilsoft\/crocks\x22,\x22googleAnalytics\x22:\x22UA-37033501-5\x22,\x22icon\x22:\x22icon-16-loop\x22,\x22index\x22:{\x22title\x22:\x22Home\x22,\x22description\x22:\x22A collection of well known Algebraic Data Types for your utter enjoyment.\x22,\x22srcFilePath\x22:\x22src\/pages\/index.soy\x22,\x22id\x22:\x22pages\x22,\x22location\x22:\x22\/.\/\x22,\x22url\x22:\x22\/crocks\/.\/\x22,\x22children\x22:{\x22docs\x22:{\x22children\x22:{\x22getting-started\x22:{\x22title\x22:\x22Getting Started\x22,\x22description\x22:\x22Getting started with a Crocks.\x22,\x22icon\x22:\x22arrow-right-rod\x22,\x22layout\x22:\x22guide\x22,\x22weight\x22:1,\x22srcFilePath\x22:\x22src\/pages\/docs\/getting-started.md\x22,\x22id\x22:\x22getting-started\x22,\x22location\x22:\x22\/docs\/getting-started.html\x22,\x22url\x22:\x22\/crocks\/docs\/getting-started.html\x22},\x22search\x22:{\x22title\x22:\x22Search\x22,\x22description\x22:\x22Find what you\x27re looking for in the documentation.\x22,\x22hidden\x22:true,\x22srcFilePath\x22:\x22src\/pages\/docs\/search.soy\x22,\x22id\x22:\x22search\x22,\x22location\x22:\x22\/docs\/search.html\x22,\x22url\x22:\x22\/crocks\/docs\/search.html\x22},\x22crocks\x22:{\x22children\x22:{\x22Arrow\x22:{\x22title\x22:\x22Arrow\x22,\x22description\x22:\x22Arrow Crock\x22,\x22layout\x22:\x22guide\x22,\x22weight\x22:10,\x22srcFilePath\x22:\x22src\/pages\/docs\/crocks\/Arrow.md\x22,\x22id\x22:\x22Arrow\x22,\x22location\x22:\x22\/docs\/crocks\/Arrow.html\x22,\x22url\x22:\x22\/crocks\/docs\/crocks\/Arrow.html\x22},\x22Async\x22:{\x22title\x22:\x22Async\x22,\x22description\x22:\x22Async Crock\x22,\x22layout\x22:\x22guide\x22,\x22functions\x22:[\x22eithertoasync\x22,\x22firsttoasync\x22,\x22lasttoasync\x22,\x22maybetoasync\x22,\x22resulttoasync\x22],\x22weight\x22:20,\x22srcFilePath\x22:\x22src\/pages\/docs\/crocks\/Async.md\x22,\x22id\x22:\x22Async\x22,\x22location\x22:\x22\/docs\/crocks\/Async.html\x22,\x22url\x22:\x22\/crocks\/docs\/crocks\/Async.html\x22,\x22active\x22:true},\x22Equiv\x22:{\x22title\x22:\x22Equiv\x22,\x22description\x22:\x22Equiv Crock\x22,\x22layout\x22:\x22guide\x22,\x22weight\x22:50,\x22srcFilePath\x22:\x22src\/pages\/docs\/crocks\/Equiv.md\x22,\x22id\x22:\x22Equiv\x22,\x22location\x22:\x22\/docs\/crocks\/Equiv.html\x22,\x22url\x22:\x22\/crocks\/docs\/crocks\/Equiv.html\x22},\x22Maybe\x22:{\x22title\x22:\x22Maybe\x22,\x22description\x22:\x22Maybe Crock\x22,\x22layout\x22:\x22guide\x22,\x22functions\x22:[\x22find\x22,\x22prop\x22,\x22proppath\x22,\x22safe\x22,\x22safeafter\x22,\x22safelift\x22,\x22eithertomaybe\x22,\x22firsttomaybe\x22,\x22lasttomaybe\x22,\x22resulttomaybe\x22],\x22weight\x22:90,\x22srcFilePath\x22:\x22src\/pages\/docs\/crocks\/Maybe.md\x22,\x22id\x22:\x22Maybe\x22,\x22location\x22:\x22\/docs\/crocks\/Maybe.html\x22,\x22url\x22:\x22\/crocks\/docs\/crocks\/Maybe.html\x22},\x22Pred\x22:{\x22title\x22:\x22Pred\x22,\x22description\x22:\x22Pred Crock\x22,\x22layout\x22:\x22guide\x22,\x22weight\x22:100,\x22srcFilePath\x22:\x22src\/pages\/docs\/crocks\/Pred.md\x22,\x22id\x22:\x22Pred\x22,\x22location\x22:\x22\/docs\/crocks\/Pred.html\x22,\x22url\x22:\x22\/crocks\/docs\/crocks\/Pred.html\x22},\x22Reader\x22:{\x22title\x22:\x22Reader\x22,\x22description\x22:\x22Reader Crock\x22,\x22layout\x22:\x22guide\x22,\x22weight\x22:110,\x22srcFilePath\x22:\x22src\/pages\/docs\/crocks\/Reader.md\x22,\x22id\x22:\x22Reader\x22,\x22location\x22:\x22\/docs\/crocks\/Reader.html\x22,\x22url\x22:\x22\/crocks\/docs\/crocks\/Reader.html\x22},\x22ReaderT\x22:{\x22title\x22:\x22ReaderT\x22,\x22description\x22:\x22Reader Monad Transformer Crock\x22,\x22layout\x22:\x22guide\x22,\x22weight\x22:120,\x22srcFilePath\x22:\x22src\/pages\/docs\/crocks\/ReaderT.md\x22,\x22id\x22:\x22ReaderT\x22,\x22location\x22:\x22\/docs\/crocks\/ReaderT.html\x22,\x22url\x22:\x22\/crocks\/docs\/crocks\/ReaderT.html\x22},\x22State\x22:{\x22title\x22:\x22State\x22,\x22description\x22:\x22State Crock\x22,\x22layout\x22:\x22guide\x22,\x22functions\x22:[\x22evalwith\x22,\x22execwith\x22],\x22weight\x22:140,\x22srcFilePath\x22:\x22src\/pages\/docs\/crocks\/State.md\x22,\x22id\x22:\x22State\x22,\x22location\x22:\x22\/docs\/crocks\/State.html\x22,\x22url\x22:\x22\/crocks\/docs\/crocks\/State.html\x22}},\x22title\x22:\x22Crocks\x22,\x22description\x22:\x22Crocks API\x22,\x22layout\x22:\x22notopic\x22,\x22icon\x22:\x22code-file\x22,\x22weight\x22:2,\x22srcFilePath\x22:\x22src\/pages\/docs\/crocks\/index.md\x22,\x22id\x22:\x22crocks\x22,\x22location\x22:\x22\/docs\/crocks\/\x22,\x22url\x22:\x22\/crocks\/docs\/crocks\/\x22,\x22childIds\x22:[\x22Arrow\x22,\x22Async\x22,\x22Equiv\x22,\x22Maybe\x22,\x22Pred\x22,\x22Reader\x22,\x22ReaderT\x22,\x22State\x22],\x22active\x22:true},\x22functions\x22:{\x22children\x22:{\x22combinators\x22:{\x22description\x22:\x22Combinators API\x22,\x22layout\x22:\x22notopic\x22,\x22title\x22:\x22Combinators\x22,\x22functions\x22:[\x22applyto\x22,\x22composeb\x22,\x22constant\x22,\x22flip\x22,\x22identity\x22,\x22substitution\x22],\x22weight\x22:10,\x22srcFilePath\x22:\x22src\/pages\/docs\/functions\/combinators.md\x22,\x22id\x22:\x22combinators\x22,\x22location\x22:\x22\/docs\/functions\/combinators.html\x22,\x22url\x22:\x22\/crocks\/docs\/functions\/combinators.html\x22},\x22helpers\x22:{\x22title\x22:\x22Helpers\x22,\x22description\x22:\x22Helper functions\x22,\x22layout\x22:\x22notopic\x22,\x22functions\x22:[\x22assign\x22,\x22assoc\x22,\x22binary\x22,\x22compose\x22,\x22composek\x22,\x22composep\x22,\x22composes\x22,\x22curry\x22,\x22defaultprops\x22,\x22defaultto\x22,\x22dissoc\x22,\x22fanout\x22,\x22frompairs\x22,\x22lifta2\x22,\x22lifta3\x22,\x22liftn\x22,\x22mapprops\x22,\x22mapreduce\x22,\x22mconcat\x22,\x22mconcatmap\x22,\x22mreduce\x22,\x22mreducemap\x22,\x22nary\x22,\x22objof\x22,\x22omit\x22,\x22once\x22,\x22partial\x22,\x22pick\x22,\x22pipe\x22,\x22pipek\x22,\x22pipep\x22,\x22pipes\x22,\x22propor\x22,\x22proppathor\x22,\x22tap\x22,\x22unary\x22,\x22unit\x22],\x22weight\x22:20,\x22srcFilePath\x22:\x22src\/pages\/docs\/functions\/helpers.md\x22,\x22id\x22:\x22helpers\x22,\x22location\x22:\x22\/docs\/functions\/helpers.html\x22,\x22url\x22:\x22\/crocks\/docs\/functions\/helpers.html\x22},\x22logic-functions\x22:{\x22description\x22:\x22Logic Functions API\x22,\x22layout\x22:\x22notopic\x22,\x22title\x22:\x22Logic Functions\x22,\x22functions\x22:[\x22and\x22,\x22ifelse\x22,\x22not\x22,\x22or\x22,\x22unless\x22,\x22when\x22],\x22weight\x22:30,\x22srcFilePath\x22:\x22src\/pages\/docs\/functions\/logic-functions.md\x22,\x22id\x22:\x22logic-functions\x22,\x22location\x22:\x22\/docs\/functions\/logic-functions.html\x22,\x22url\x22:\x22\/crocks\/docs\/functions\/logic-functions.html\x22},\x22pointfree-functions\x22:{\x22title\x22:\x22Point-free Functions\x22,\x22description\x22:\x22Point-free Functions API\x22,\x22layout\x22:\x22notopic\x22,\x22functions\x22:[\x22alt\x22,\x22ap\x22,\x22bimap\x22,\x22both\x22,\x22chain\x22,\x22coalesce\x22,\x22comparewith\x22,\x22concat\x22,\x22cons\x22,\x22contramap\x22,\x22either\x22,\x22empty\x22,\x22equals\x22,\x22extend\x22,\x22filter\x22,\x22first\x22,\x22fold\x22,\x22head\x22,\x22map\x22,\x22option\x22,\x22promap\x22,\x22reduce\x22,\x22reduceright\x22,\x22run\x22,\x22runwith\x22,\x22second\x22,\x22sequence\x22,\x22swap\x22,\x22tail\x22,\x22traverse\x22,\x22valueof\x22],\x22weight\x22:50,\x22srcFilePath\x22:\x22src\/pages\/docs\/functions\/pointfree-functions.md\x22,\x22id\x22:\x22pointfree-functions\x22,\x22location\x22:\x22\/docs\/functions\/pointfree-functions.html\x22,\x22url\x22:\x22\/crocks\/docs\/functions\/pointfree-functions.html\x22},\x22predicate-functions\x22:{\x22description\x22:\x22Predicate Functions API\x22,\x22layout\x22:\x22notopic\x22,\x22title\x22:\x22Predicate Functions\x22,\x22functions\x22:[\x22hasprop\x22,\x22hasproppath\x22,\x22isalt\x22,\x22isalternative\x22,\x22isapplicative\x22,\x22isapply\x22,\x22isarray\x22,\x22isbifunctor\x22,\x22isboolean\x22,\x22iscategory\x22,\x22ischain\x22,\x22iscontravariant\x22,\x22isdefined\x22,\x22isempty\x22,\x22isextend\x22,\x22isfoldable\x22,\x22isfunction\x22,\x22isfunctor\x22,\x22isinteger\x22,\x22ismonad\x22,\x22ismonoid\x22,\x22isnil\x22,\x22isnumber\x22,\x22isobject\x22,\x22isplus\x22,\x22isprofunctor\x22,\x22ispromise\x22,\x22issame\x22,\x22issametype\x22,\x22issemigroup\x22,\x22issemigroupoid\x22,\x22issetoid\x22,\x22isstring\x22,\x22istraversable\x22,\x22propeq\x22,\x22proppatheq\x22],\x22weight\x22:40,\x22srcFilePath\x22:\x22src\/pages\/docs\/functions\/predicate-functions.md\x22,\x22id\x22:\x22predicate-functions\x22,\x22location\x22:\x22\/docs\/functions\/predicate-functions.html\x22,\x22url\x22:\x22\/crocks\/docs\/functions\/predicate-functions.html\x22},\x22transformation-functions\x22:{\x22title\x22:\x22Transformation Functions\x22,\x22description\x22:\x22Transformation Functions API\x22,\x22layout\x22:\x22notopic\x22,\x22functions\x22:[\x22arraytolist\x22,\x22eithertoasync\x22,\x22eithertofirst\x22,\x22eithertolast\x22,\x22eithertomaybe\x22,\x22eithertoresult\x22,\x22firsttoasync\x22,\x22firsttoeither\x22,\x22firsttolast\x22,\x22firsttomaybe\x22,\x22firsttoresult\x22,\x22lasttoasync\x22,\x22lasttoeither\x22,\x22lasttofirst\x22,\x22lasttomaybe\x22,\x22lasttoresult\x22,\x22listtoarray\x22,\x22maybetoasync\x22,\x22maybetoeither\x22,\x22maybetofirst\x22,\x22maybetolast\x22,\x22maybetoresult\x22,\x22resulttoasync\x22,\x22resulttoeither\x22,\x22resulttofirst\x22,\x22resulttolast\x22,\x22resulttomaybe\x22,\x22writertopair\x22],\x22weight\x22:60,\x22srcFilePath\x22:\x22src\/pages\/docs\/functions\/transformation-functions.md\x22,\x22id\x22:\x22transformation-functions\x22,\x22location\x22:\x22\/docs\/functions\/transformation-functions.html\x22,\x22url\x22:\x22\/crocks\/docs\/functions\/transformation-functions.html\x22}},\x22title\x22:\x22Functions\x22,\x22description\x22:\x22functions\x22,\x22layout\x22:\x22notopic\x22,\x22icon\x22:\x22code-file\x22,\x22weight\x22:40,\x22srcFilePath\x22:\x22src\/pages\/docs\/functions\/index.md\x22,\x22id\x22:\x22functions\x22,\x22location\x22:\x22\/docs\/functions\/\x22,\x22url\x22:\x22\/crocks\/docs\/functions\/\x22,\x22childIds\x22:[\x22combinators\x22,\x22helpers\x22,\x22logic-functions\x22,\x22predicate-functions\x22,\x22pointfree-functions\x22,\x22transformation-functions\x22]},\x22monoids\x22:{\x22children\x22:{\x22All\x22:{\x22title\x22:\x22All\x22,\x22description\x22:\x22All Monoid\x22,\x22layout\x22:\x22guide\x22,\x22weight\x22:10,\x22srcFilePath\x22:\x22src\/pages\/docs\/monoids\/All.md\x22,\x22id\x22:\x22All\x22,\x22location\x22:\x22\/docs\/monoids\/All.html\x22,\x22url\x22:\x22\/crocks\/docs\/monoids\/All.html\x22},\x22Any\x22:{\x22title\x22:\x22Any\x22,\x22description\x22:\x22Any Monoid\x22,\x22layout\x22:\x22guide\x22,\x22weight\x22:20,\x22srcFilePath\x22:\x22src\/pages\/docs\/monoids\/Any.md\x22,\x22id\x22:\x22Any\x22,\x22location\x22:\x22\/docs\/monoids\/Any.html\x22,\x22url\x22:\x22\/crocks\/docs\/monoids\/Any.html\x22},\x22Assign\x22:{\x22title\x22:\x22Assign\x22,\x22description\x22:\x22Assign Monoid\x22,\x22layout\x22:\x22guide\x22,\x22weight\x22:30,\x22srcFilePath\x22:\x22src\/pages\/docs\/monoids\/Assign.md\x22,\x22id\x22:\x22Assign\x22,\x22location\x22:\x22\/docs\/monoids\/Assign.html\x22,\x22url\x22:\x22\/crocks\/docs\/monoids\/Assign.html\x22},\x22Endo\x22:{\x22title\x22:\x22Endo\x22,\x22description\x22:\x22Endo Monoid\x22,\x22layout\x22:\x22guide\x22,\x22weight\x22:40,\x22srcFilePath\x22:\x22src\/pages\/docs\/monoids\/Endo.md\x22,\x22id\x22:\x22Endo\x22,\x22location\x22:\x22\/docs\/monoids\/Endo.html\x22,\x22url\x22:\x22\/crocks\/docs\/monoids\/Endo.html\x22},\x22First\x22:{\x22title\x22:\x22First\x22,\x22description\x22:\x22First Monoid\x22,\x22layout\x22:\x22guide\x22,\x22weight\x22:50,\x22srcFilePath\x22:\x22src\/pages\/docs\/monoids\/First.md\x22,\x22id\x22:\x22First\x22,\x22location\x22:\x22\/docs\/monoids\/First.html\x22,\x22url\x22:\x22\/crocks\/docs\/monoids\/First.html\x22},\x22Last\x22:{\x22title\x22:\x22Last\x22,\x22description\x22:\x22Last Monoid\x22,\x22layout\x22:\x22guide\x22,\x22weight\x22:60,\x22srcFilePath\x22:\x22src\/pages\/docs\/monoids\/Last.md\x22,\x22id\x22:\x22Last\x22,\x22location\x22:\x22\/docs\/monoids\/Last.html\x22,\x22url\x22:\x22\/crocks\/docs\/monoids\/Last.html\x22},\x22Max\x22:{\x22title\x22:\x22Max\x22,\x22description\x22:\x22Max Monoid\x22,\x22layout\x22:\x22guide\x22,\x22weight\x22:70,\x22srcFilePath\x22:\x22src\/pages\/docs\/monoids\/Max.md\x22,\x22id\x22:\x22Max\x22,\x22location\x22:\x22\/docs\/monoids\/Max.html\x22,\x22url\x22:\x22\/crocks\/docs\/monoids\/Max.html\x22},\x22Min\x22:{\x22title\x22:\x22Min\x22,\x22description\x22:\x22Min Monoid\x22,\x22layout\x22:\x22guide\x22,\x22weight\x22:80,\x22srcFilePath\x22:\x22src\/pages\/docs\/monoids\/Min.md\x22,\x22id\x22:\x22Min\x22,\x22location\x22:\x22\/docs\/monoids\/Min.html\x22,\x22url\x22:\x22\/crocks\/docs\/monoids\/Min.html\x22},\x22Prod\x22:{\x22title\x22:\x22Prod\x22,\x22description\x22:\x22Prod Monoid\x22,\x22layout\x22:\x22guide\x22,\x22weight\x22:90,\x22srcFilePath\x22:\x22src\/pages\/docs\/monoids\/Prod.md\x22,\x22id\x22:\x22Prod\x22,\x22location\x22:\x22\/docs\/monoids\/Prod.html\x22,\x22url\x22:\x22\/crocks\/docs\/monoids\/Prod.html\x22},\x22Sum\x22:{\x22title\x22:\x22Sum\x22,\x22description\x22:\x22Sum Monoid\x22,\x22layout\x22:\x22guide\x22,\x22weight\x22:100,\x22srcFilePath\x22:\x22src\/pages\/docs\/monoids\/Sum.md\x22,\x22id\x22:\x22Sum\x22,\x22location\x22:\x22\/docs\/monoids\/Sum.html\x22,\x22url\x22:\x22\/crocks\/docs\/monoids\/Sum.html\x22}},\x22title\x22:\x22Monoids\x22,\x22description\x22:\x22Monoids API\x22,\x22layout\x22:\x22notopic\x22,\x22icon\x22:\x22code-file\x22,\x22weight\x22:3,\x22srcFilePath\x22:\x22src\/pages\/docs\/monoids\/index.md\x22,\x22id\x22:\x22monoids\x22,\x22location\x22:\x22\/docs\/monoids\/\x22,\x22url\x22:\x22\/crocks\/docs\/monoids\/\x22,\x22childIds\x22:[\x22All\x22,\x22Any\x22,\x22Assign\x22,\x22Endo\x22,\x22First\x22,\x22Last\x22,\x22Max\x22,\x22Min\x22,\x22Prod\x22,\x22Sum\x22]}},\x22title\x22:\x22Documentation\x22,\x22description\x22:\x22Everything you need to know to get started.\x22,\x22srcFilePath\x22:\x22src\/pages\/docs\/index.soy\x22,\x22id\x22:\x22docs\x22,\x22location\x22:\x22\/docs\/\x22,\x22url\x22:\x22\/crocks\/docs\/\x22,\x22childIds\x22:[\x22getting-started\x22,\x22crocks\x22,\x22monoids\x22,\x22functions\x22,\x22search\x22],\x22active\x22:true}},\x22childIds\x22:[\x22docs\x22]},\x22basePath\x22:\x22\/crocks\x22,\x22topbar\x22:[{\x22href\x22:\x22\/crocks\/docs\/\x22,\x22label\x22:\x22Documentation\x22,\x22selected\x22:true}]}}'); if (window.electricPageComponent) {window.electricPageComponent.dispose();}var getByPath = function(obj, path) {path = path.split('.'); for (var i = 0; i < path.length; i++) {obj = obj[path[i]];}; return obj;}; if (window.pageComponent) {var page = getByPath(data.site, data.pageLocation); if (page) {window.electricPageComponent = pageComponent.default.render(pageComponent.default, {element: '#pageComponent > *', page: page, site: data.site});}if (window.runCodeMirror) {runCodeMirror();}}</script><!-- endinject --></div><!-- inject:vendor:js --><script>CodeMirror.defaults.lineNumbers = true; CodeMirror.defaults.matchBrackets = true; CodeMirror.defaults.readOnly = true; CodeMirror.defaults.tabindex = -1; CodeMirror.defaults.tabSize = 2; CodeMirror.defaults.theme = 'blackboard'; CodeMirror.defaults.viewportMargin = Infinity; var REGEX_LB = /&#123;/g; var REGEX_RB = /&#125;/g; function runCodeMirror() {var code = document.querySelectorAll('.code'); for (var i = 0; i < code.length; i++) {var text = code[i].innerText .replace(REGEX_LB, '{') .replace(REGEX_RB, '}'); var editor = CodeMirror(function(elt) {var preEl = code[i].parentNode; preEl.parentNode.appendChild(elt);}, {mode: code[i].getAttribute('data-mode') || '', value: text});}if (window.ElectricCodeTabs) {new window.ElectricCodeTabs();}}runCodeMirror(); function runGoogleAnalytics(path) {if (typeof ga === 'function') {ga('set', 'page', path); ga('send', 'pageview');}}document.addEventListener('DOMContentLoaded', function() {if (typeof senna !== 'undefined') {var app = senna.dataAttributeHandler.getApp(); app.on('endNavigate', function(event) {runGoogleAnalytics(event.path);});}}); (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-37033501-5', 'auto'); ga('send', 'pageview');</script><!-- endinject --></body></html>