{"title":"Crocks","githubRepo":"evilsoft/crocks","googleAnalytics":"UA-37033501-5","icon":"icon-16-loop","index":{"title":"Home","description":"A collection of well known Algebraic Data Types for your utter enjoyment.","content":" Crocks Distributed under ISC License Found an issue with the docs? Report it here ","srcFilePath":"src/pages/index.soy","id":"pages","location":"/./","url":"/crocks/./","children":{"docs":{"children":{"getting-started":{"title":"Getting Started","description":"Getting started with a Crocks.","icon":"arrow-right-rod","layout":"guide","weight":1,"content":" Installation crocks is available from npm and is just a shell command away. All you need to do is run the following to save it as a dependency in your current project folder: $ npm install crocks -S This will pull down crocks into your project's node_modules folder and can be accessed by adding something like the following in the file that needs it: // node require syntax const crocks = require('crocks') // Javascript modules (if you are transpiling) import crocks from 'crocks' Import only what's needed There is a lot to this library, and as such it may not be desired to bring in the whole thing when bundling for a library or frontend application. If this is the case, the code is organized in a manner that groups all functions that return or construct a given ADT into their respective folders. While general purpose functions are spread across the following folders: combinators, helpers, logic, pointfree and predicates. To access the types, just reference the folder like: crocks/Maybe, or crocks/Result. If you want to access a function that constructs a given type, reference it by name, like: crocks/Maybe/safe or crocks/Result/tryCatch. This organization helps ensure that you only include what you need. Entire library (CommonJS) // namespace entire suite to crocks variable const crocks = require('crocks') // pluck anything that does not require name-spacing const { safe, isNumber } = crocks // still requires entire object, but removes name-spacing const { and, liftA2 } = require('crocks') // divide :: Number - Number const divide = x = y = x / y // safeNumber :: a - Maybe Number const safeNumber = safe(isNumber) // notZero :: a - Maybe Number const notZero = safe( and(isNumber, x = x !== 0) ) // safeDivide:: a - Maybe Number const safeDivide = crocks.curry( (x, y) = liftA2(divide, safeNumber(x), notZero(y)) ) safeDivide(20, 0) //= Nothing safeDivide(20, 5) //= Just 4 safeDivide('number', 5) //= Nothing Entire library (JS Modules) // namespace entire suite to crocks variable import crocks from 'crocks' // still imports entire object, but removes name-spacing import { and, liftA2 } from 'crocks' // pluck anything that does not require name-spacing const { safe, isNumber } = crocks // divide :: Number - Number const divide = x = y = x / y // safeNumber :: a - Maybe Number const safeNumber = safe(isNumber) // notZero :: a - Maybe Number const notZero = safe( and(isNumber, x = x !== 0) ) // safeDivide:: a - Maybe Number const safeDivide = crocks.curry( (x, y) = liftA2(divide, safeNumber(x), notZero(y)) ) safeDivide(20, 0) //= Nothing safeDivide(20, 5) //= Just 4 safeDivide('number', 5) //= Nothing Single entities (CommonJS) // require in each entity directly const and = require('crocks/logic/and') const curry = require('crocks/helpers/curry') const isNumber = require('crocks/predicates/isNumber') const liftA2 = require('crocks/helpers/liftA2') const safe = require('crocks/Maybe/safe') // divide :: Number - Number const divide = x = y = x / y // safeNumber :: a - Maybe Number const safeNumber = safe(isNumber) // notZero :: a - Maybe Number const notZero = safe( and(isNumber, x = x !== 0) ) // safeDivide:: a - Maybe Number const safeDivide = curry( (x, y) = liftA2(divide, safeNumber(x), notZero(y)) ) safeDivide(20, 0) //= Nothing safeDivide(20, 5) //= Just 4 safeDivide('number', 5) //= Nothing Single entities (JS Modules) // import in each entity directly import and from 'crocks/logic/and' import curry from 'crocks/helpers/curry' import isNumber from 'crocks/predicates/isNumber' import liftA2 from 'crocks/helpers/liftA2' import safe from 'crocks/Maybe/safe' // divide :: Number - Number const divide = x = y = x / y // safeNumber :: a - Maybe Number const safeNumber = safe(isNumber) // notZero :: a - Maybe Number const notZero = safe( and(isNumber, x = x !== 0) ) // safeDivide:: a - Maybe Number const safeDivide = curry( (x, y) = liftA2(divide, safeNumber(x), notZero(y)) ) safeDivide(20, 0) //= Nothing safeDivide(20, 5) //= Just 4 safeDivide('number', 5) //= Nothing ","srcFilePath":"src/pages/docs/getting-started.md","id":"getting-started","location":"/docs/getting-started.html","url":"/crocks/docs/getting-started.html"},"search":{"title":"Search","description":"Find what you're looking for in the documentation.","hidden":true,"content":" Electric Docs Start learning how to leverage the power of . ","srcFilePath":"src/pages/docs/search.soy","id":"search","location":"/docs/search.html","url":"/crocks/docs/search.html"},"crocks":{"children":{"Arrow":{"title":"Arrow","description":"Arrow Crock","layout":"guide","weight":10,"content":" Arrow a b Arrow is a Profunctor that lifts a function of type a - b and allows for lazy execution of the function. Arrow can be considered a Strong Profunctor if the underlying data running throw the Arrow is a Pair, typically in the form of Arrow (Pair a c) (Pair b d). This will allow you to split execution into two distinct paths, applying Arrow to a specific path. The parameters of Arrow represent the function that it wraps, with the input being on the left, and the output on the right. When an Arrow wraps an endomorphism, the signature typically represents both the input and output. const Arrow = require('crocks/Arrow') const chain = require('crocks/pointfree/chain') const compose = require('crocks/helpers/compose') const isString = require('crocks/predicates/isString') const option = require('crocks/pointfree/option') const prop = require('crocks/Maybe/prop') const safe = require('crocks/Maybe/safe') // arrUpper :: Arrow String const arrUpper = Arrow(str = str.toUpperCase()) arrUpper .runWith('nice') //= 'NICE' // getName :: a - String const getName = compose( option('no name'), chain(safe(isString)), prop('name') ) // arrUpperName :: Arrow a String const arrUpperName = arrUpper .contramap(getName) arrUpperName .runWith({ name: 'joey' }) //= 'JOEY' arrUpperName .runWith({ age: 23 }) //= 'NO NAME' arrUpperName .runWith({ name: false }) //= 'NO NAME' Implements Semigroupoid, Category, Functor, Contravariant, Profunctor Constructor Methods id Arrow.id :: () - Arrow a id provides the identity for the Arrow in that when it is composed to either the left or right side of a given function, it will essentially result in a morphism that is, for all intents and purposes, the given function. For Arrow, id is the simple identity function that echoes it's given argument (x = x). As a convenience, id is also available on the Arrow instance. const Arrow = require('crocks/Arrow') // arrId :: Arrow a const id = Arrow.id() // arrow :: Arrow a String const arrow = Arrow(x = x.toString()) // left :: Arrow a String const left = id.compose(arrow) // right :: Arrow a String const right = arrow.compose(id) right.runWith(12) //= '12' left.runWith(12) //= '12' Instance Methods both Pair p = Arrow a b ~ () - Arrow (p a a) (p b b) both allows for the mode of a given Arrow to switch to a manner that applies itself to both slots of a Pair that is passed through the Arrow. As noted in the type signature, both will give back an Arrow has a new signature that utilizes a Pair on both sides. const Arrow = require('crocks/Arrow') const Pair = require('crocks/Pair') const merge = require('crocks/Pair/merge') // double :: Number - Number const double = x = x * 2 // add :: (Number, Number) - Number const add = (x, y) = x + y // arrDouble :: Arrow Number const arrDouble = Arrow(double) // arrDoubleAndAdd :: Arrow (Pair Number Number) Number const arrDoubleAndAdd = arrDouble .both() .map(merge(add)) arrDouble .runWith(200) //= 400 arrDoubleAndAdd .runWith(Pair(200, 10)) //= 420 compose Arrow a b ~ Arrow b c - Arrow a c compose allows you to compose (2) Arrows together, resulting in a new Arrow that is the result of the composition. const Arrow = require('crocks/Arrow') const filter = require('crocks/pointfree/filter') const map = require('crocks/pointfree/map') // arrFilterEven :: Arrow [ Number ] const arrFilterEven = Arrow(filter(x = !(x % 2))) // arrDoubleNumbers :: Arrow [ Number ] const arrDoubleNumbers = Arrow(map(x = x * 2)) // arrLength :: Arrow [ a ] - Number const arrLength = Arrow(x = x.length) // arrDoubleEven :: Arrow [ Number ] const arrDoubleEven = arrFilterEven .compose(arrDoubleNumbers) // arrEvenCount :: Arrow [ Number ] Number const arrEvenCount = arrFilterEven .compose(arrLength) // data :: [ Number ] const data = [ 12, 2, 36, 35 ] arrDoubleEven .runWith(data) //= [ 24, 4, 72 ] arrEvenCount .runWith(data) //= 3 contramap Arrow a b ~ (c - a) - Arrow c b When using contramap on an Arrow, a function can be lifted that will map a given type into the type required for the original Arrow's input. This allows for \"adaption\" of given Arrow's input for better reuse. The resulting type of the lifted function must match the input type of the Arrow. const Arrow = require('crocks/Arrow') const chain = require('crocks/pointfree/chain') const compose = require('crocks/helpers/compose') const isNumber = require('crocks/predicates/isNumber') const option = require('crocks/pointfree/option') const prop = require('crocks/Maybe/prop') const safe = require('crocks/Maybe/safe') // getValue :: (String, Number) - a - Number const getValue = (key, def) = compose( option(def), chain(safe(isNumber)), prop(key) ) // arrAdd10 :: Arrow Number const arrAdd10 = Arrow(x = x + 10) // arrAdd10Value :: Arrow Object Number const arrAdd10Value = arrAdd10 .contramap(getValue('value', 0)) arrAdd10 .runWith(23) //= 33 arrAdd10Value .runWith({ value: 23 }) //= 33 arrAdd10Value .runWith({ value: '23' }) //= 10 arrAdd10Value .runWith({ num: '23' }) //= 10 first Pair p = Arrow a b ~ () - Arrow (p a c) (p b c) When calling first on an Arrow, a new Arrow is returned that will expect a Pair with the original input type in the first slot of the Pair. When run, the Arrow will only be applied to the first slot in the Pair, leaving the second slot untouched. const Arrow = require('crocks/Arrow') const branch = require('crocks/Pair/branch') // arrToUpper :: Arrow String const arrToUpper = Arrow(x = x.toUpperCase()) arrToUpper .runWith('burrito bounce') //= 'BURRITO BOUNCE' // join :: Pair String - Object const join = p = ({ original: p.snd(), result: p.fst() }) // flow :: Arrow String Object const flow = arrToUpper .first() .promap(branch, join) flow .runWith('taco time') //= { original: 'taco time', result: 'TACO TIME' } map Arrow a b ~ (b - c) - Arrow a c map allows a function to be lifted that will map the right side of the Arrow. Where contramap is used to map the input, map maps the result of the Arrow, allowing the result to be \"adapted\" or modified. The input type to the lifted function must match the result the Arrow. const Arrow = require('crocks/Arrow') const B = require('crocks/combinators/composeB') // arrFullScale :: Arrow Number const arrFullScale = Arrow(x = 20 * Math.log10(Math.abs(x))) arrFullScale .runWith(-0.35) //= -9.118639112994488 // round :: Number - Number const round = x = Math.floor(x * 100) / 100 // stringRep :: Number - String const stringRep = x = ${x} dBFS // Arrow :: Number String const arrStringFS = arrFullScale .map(B(stringRep, round)) arrStringFS .runWith(0.35) //= '-9.12 dbFS' promap Arrow a b ~ ((c - a), (b - d)) - Arrow c d promap can be used to adapt BOTH ends of an Arrow allowing for existing Arrows to be reused in places in a flow where the types do not line up. It combines both map and conramap into one operation. Just pass the contramap function as the first argument and the map function as the second. const Arrow = require('crocks/Arrow') const chain = require('crocks/pointfree/chain') const compose = require('crocks/helpers/compose') const isString = require('crocks/predicates/isString') const objOf = require('crocks/helpers/objOf') const option = require('crocks/pointfree/option') const prop = require('crocks/Maybe/prop') const safe = require('crocks/Maybe/safe') // upperFirst :: String - String const upperFirst = x = x.charAt(0) .toUpperCase() .concat(x.slice(1).toLowerCase()) // arrTitleize :: Arrow String const arrTitleize = Arrow(x = x.split(' ').map(upperFirst).join(' ')) arrTitleize .runWith('tHis is siLLy') //= 'This Is Silly' // stringProp :: String - Object - String const stringProp = key = compose( option(''), chain(safe(isString)), prop(key) ) // arrTitleObject :: Arrow Object const arrTitleObject = arrTitleize .promap(stringProp('title'), objOf('title')) arrTitleObject .runWith({ title: 'SaY wHaT!?!' }) // { title: 'Say What!?!' } arrTitleObject .runWith({ title: true }) // { title: '' } runWith Arrow a b ~ a - b Arrows are lazy to make combining and extending them easy. Once you have your final computation built out and you are ready to execute it, all you have to do is call runWith on it, passing in the argument you what to run it with. const Arrow = require('crocks/Arrow') const Sum = require('crocks/Sum') const branch = require('crocks/Pair/branch') const merge = require('crocks/Pair/merge') const mreduce = require('crocks/helpers/mreduce') // data :: [ Number ] const data = [ 35, 60, 22, 100 ] // arrLength :: Arrow [ a ] Number const arrLength = Arrow(x = x.length) arrLength .runWith(data) //= 4 // arrSum :: Arrow [ Number ] Number const arrSum = Arrow(mreduce(Sum)) arrSum .runWith(data) //= 217 // arrAvgList :: Arrow [ Number ] Number const arrAvgList = arrSum.first() .compose(arrLength.second()) .promap(branch, merge((x, y) = x / y)) arrAvgList .runWith(data) //= 54.25 second Pair p = Arrow a b ~ () - Arrow (p c a) (p c b) Used to apply a given Arrow over the second slot of a Pair, leaving the first slot untouched. The input to the Arrow must match the expected type on the second slot of the incoming Pair. const Arrow = require('crocks/Arrow') const assign = require('crocks/helpers/assign') const branch = require('crocks/Pair/branch') const merge = require('crocks/Pair/merge') const objOf = require('crocks/helpers/objOf') // names :: Object const names = { first: 'Joey', last: 'Fella' } // arrFull :: Arrow Object const arrFull = Arrow(({ first, last }) = ${first} ${last}) .map(objOf('full')) //= { full: 'Joey Fella' } // arrAddFull :: Arrow Object const arrAddFull = arrFull .second() .promap(branch, merge(assign)) arrAddFull .runWith(names) //= { full: 'Joey Fella', first: 'Joey', last: 'Fella' } ","srcFilePath":"src/pages/docs/crocks/Arrow.md","id":"Arrow","location":"/docs/crocks/Arrow.html","url":"/crocks/docs/crocks/Arrow.html"},"Async":{"title":"Async","description":"Async Crock","layout":"guide","weight":20,"content":" Async e a = Rejected e | Resolved a Defined as a \"lazy\" Sum Type that implements an asynchronous control structure, Async represents either the success or failure of a given asynchronous operation. The \"laziness\" of Async allows the ability to build complex asynchronous operations by defining each portion of that flow as smaller \"steps\" that can be composed together. Depending on your needs, an Async can be constructed in a variety of ways. The typical closely resembles how a Promise is constructed with one major difference, the arguments used in the function that is passed to the Promise constructor are reversed in an Async to match the order in which Async is parameterized. There are many ways to represent asynchronous operations in JavaScript, and as such, the libraries available to us in our ecosystem provide different means to take advantage of these operations. The two most common use either Promise returning functions or allow for the Continuation Passing Style prevalent in the asynchronous function that ship with NodeJS. Async provides (2) construction helpers that wrap functions using these styles of asynchronous processing and will give you back a function that takes the same arguments as the original and will return an Async instead. These functions are called fromPromise and fromNode. Async instances wrap asynchronous functions and are considered lazy, in that they will not run or execute until needed. This typically happens at an edge in a program and is done by executing the fork method available on the instance, which takes (2) functions as its arguments. The first function passed to fork will be called on a Rejected instance and passed the value the Async was rejected with. The second function is called when fork is invoked on a Resolved instance receiving the value the Async was resolved with. At times, in a given environment, it may not be feasible to run an asynchronous flow to completion. To address when these use cases pop up, the fork function will return a function that ignores its arguments and returns a Unit. When this function is called, Async will finish running the current \"in flight\" computation to completion, but will cease all remaining execution. Cancellation with Async is total and will cancel silently, without notification. const Async = require('crocks/Async') const maybeToAsync = require('crocks/Async/maybeToAsync') const First = require('crocks/First') const equals = require('crocks/pointfree/equals') const map = require('crocks/pointfree/map') const mreduceMap = require('crocks/helpers/mreduceMap') const pick = require('crocks/helpers/pick') const safe = require('crocks/Maybe/safe') // log :: String - a - a const log = label = x = (console.log(${label}:, x), x) // propEq :: (String, a) - Object - Boolean const propEq = (key, value) = x = equals(x[key], value) // findById :: Foldable f = (a - Boolean) - f a - Maybe a const findById = id = mreduceMap(First, safe(propEq('id', id))) // getById :: Number - Async String Object function getById(id) { const data = [ { id: 1, name: 'Jimmothy Schmidt', age: 24 }, { id: 2, name: 'Tori Blackwood', age: 21 }, { id: 3, name: 'Joey Mc Carthy', age: 27 } ] return Async( (rej, res) = setTimeout(() = res(data), 1000) ).chain(maybeToAsync(id: ${id} -- Not Found, findById(id))) } getById(3) .map(pick([ 'id', 'name' ])) .fork(log('rej'), log('res')) //= res: { id: 3, name: 'Joey Mc Carthy' } getById(5) .map(pick([ 'id', 'name' ])) .fork(log('rej'), log('res')) //= rej: \"id: 5 -- Not Found\" // cancel :: () - () const cancel = getById(1).fork( log('rej'), log('res'), () = console.log('cancelled') ) setTimeout(cancel, 500) //= \"cancelled\" Async .all(map(getById, [ 1, 2 ])) .map(map(pick([ 'id', 'name' ]))) .fork(log('rej'), log('res')) //= res: [ //= { id: 1, name: 'Jimmothy Schmidt' }, //= { id: 2, name: 'Tori Blackwood' }, //= ] Async .all(map(getById, [ 3, 14 ])) .map(map(pick([ 'id', 'name' ]))) .fork(log('rej'), log('res')) //= rej: \"id: 14 -- Not Found\" Implements Functor, Alt, Bifunctor, Apply, Chain, Applicative, Monad Constructor Methods Rejected Async.Rejected :: e - Async e a Used to construct a Rejected instance of Async that represents the failure or \"false\" case of the disjunction. Calling Rejected with a given value, will return a new Rejected instance, wrapping the provided value. When an instance is Rejected, most Async returning methods on the instance will return another Rejected instance. This is in contrast to a javascript Promise, that will continue on a Resolved path after a catch. This behavior of Promises provide challenges when constructing complicated (or even some simple) Promise chains that may fail at various steps along the chain. Even though Async is a Bifunctor, in most cases it is desired to keep the type of a Rejected fixed to a type for a given flow. Given that Async is a Bifunctor, it is easy to make sure you get the type you need at the edge by leaning on bimap to \"square things up\". const Async = require('crocks/Async') const { Rejected } = Async // log :: String - a - a const log = label = x = (console.log(${label}:, x), x) // m :: Async String a const m = Async( rej = { rej('Some Error') } ) // n :: Async String a const n = Rejected('Some Error') m.fork(log('rej'), log('res')) //= rej: \"Some Error\" n.fork(log('rej'), log('res')) //= rej: \"Some Error\" Resolved Async.Resolved :: a - Async e a Used to construct a Resolved instance that represents the success or \"true\" portion of the disjunction. Resolved will wrap any given value passed to this constructor in the Resolved instance it returns, signaling the validity of the wrapped value. const Async = require('crocks/Async') const { Resolved } = Async // log :: String - a - a const log = label = x = (console.log(${label}:, x), x) // m :: Async e Number const m = Async( (rej, res) = { res(97) } ) // n :: Async e Number const n = Resolved(97) m.fork(log('rej'), log('res')) //= res: 97 n.fork(log('rej'), log('res')) //= res: 97 fromPromise Async.fromPromise :: (* - Promise a e) - (* - Async e a) Used to turn an \"eager\" Promise returning function, into a function that takes the same arguments but returns a \"lazy\" Async instance instead. Due to the lazy nature of Async, any curried interface will not be respected on the provided function. This can be solved by wrapping the resulting function with nAry, which will provide a curried function that will return the desired Async. const { fromPromise } = require('crocks/Async') const ifElse = require('crocks/logic/ifElse') const isNumber = require('crocks/predicates/isNumber') const nAry = require('crocks/helpers/nAry') // log :: String - a - a const log = label = x = (console.log(${label}:, x), x) // safeProm :: ((a - Boolean), a) - Promise a a const safeProm = (pred, x) = new Promise( (res, rej) = ifElse(pred, res, rej, x) ) safeProm(isNumber, 34) .then(log('resProm')) //= resProm: 34 safeProm(isNumber, '34') .catch(log('rejProm')) //= rejProm: \"34\" // safeAsync :: (a - Boolean) - a - Async a a const safeAsync = nAry(2, fromPromise(safeProm)) // numAsync :: a - Async a Number const numAsync = safeAsync(isNumber) numAsync(34) .fork(log('rej'), log('res')) //= res: 34 numAsync('34') .fork(log('rej'), log('res')) //= rej: \"34\" fromNode NodeCallback :: (e, a) - () Async.fromNode :: ((, NodeCallback) - ()) - ( - Async e a) Async.fromNode :: (((, NodeCallback) - ()), ctx) - ( - Async e a) Many of the asynchronous functions that ship with Node JS provide a Continuation Passing Style, that requires the use of a callback function to be passed as the last argument. The provided callback functions are binary functions that take an err as the first argument, which is null when there is no error to be reported. The second argument is the data representing the result of the function in the case that there is no error present. This interface can create the fabled pyramid of callback doom when trying to combine multiple asynchronous calls. fromNode can be used to wrap functions of this style. Just pass the desired function to wrap and fromNode will give back a new function, that takes the same number of arguments, minus the callback function. When the provided function is called, it returns a \"lazy\" Async. When the resulting instance is forked, if the err is a non-null value then the instance will be Rejected with the err value. When the err is null, then the instance will become Resolved with the data value. There are some libraries whose functions are methods on some stateful object. As such, the need for binding may arise. fromNode provides a second, optional argument that takes the context that will be used to bind the function being wrapped. Like fromPromise, any curried interface will not be respected. If a curried interface is needed then nAry can be used. const { fromNode } = require('crocks/Async') const curry = require('crocks/helpers/curry') const isNumber = require('crocks/predicates/isNumber') const nAry = require('crocks/helpers/nAry') const partial = require('crocks/helpers/partial') // log :: String - a - a const log = curry(label = x = (console.log(${label}:, x), x) ) // NodeCallback :: (e, a) - () // delay :: (Number, a, NodeCallback (String, Number)) - () function delay(delay, val, cb) { setTimeout( () = isNumber(val) ? cb(null, val) : cb('No Number'), delay ) } // callback :: (e, a) - () const callback = (err, data) = { err ? log('err', err) : log('data', data) } // wait500 :: a - NodeCallback (String, Number) - () const wait500 = partial(delay, 500) wait500(32, callback) //= data: 32 wait500('32', callback) //= err: \"No Number\" // delayAsync :: Number - a - Async String Number const delayAsync = nAry(2, fromNode(delay)) // waitAsync :: a - Async String Number const waitAsync = delayAsync(1000) waitAsync(32) .fork(log('rej'), log('res')) //= res: 32 waitAsync('32') .fork(log('rej'), log('res')) //= rej: \"No Number\" all Async.all :: [ Async e a ] - Async e [ a ] Async provides an all method that can be used when multiple, independent asynchronous operations need to be run in parallel. all takes an Array of Async instances that, when forked, will execute each instance in the provided Array in parallel. If any of the instances result in a Rejected state, the entire flow will be Rejected with value of the first Rejected instance. If all instances resolve, then the entire instance is Resolved with an Array containing all Resolved values in their provided order. const { all, Rejected, Resolved } = require('../crocks/src/Async') // log :: String - a - a const log = label = x = (console.log(${label}:, x), x) all([ Resolved(1), Resolved(2), Resolved(3) ]) .fork(log('rej'), log('res')) //= res: [ 1, 2, 3 ] all([ Resolved(1), Rejected(2), Rejected(3) ]) .fork(log('rej'), log('res')) //= rej: 2 of Async.of :: a - Async e a Used to wrap any value into an Async as a Resolved instance, of is used mostly by helper functions that work \"generically\" with instances of either Applicative or Monad. When working specifically with the Async type, the Resolved constructor should be used. Reach for of when working with functions that will work with ANY Applicative/Monad. const Async = require('../crocks/src/Async') const { Resolved } = Async // log :: String - a - a const log = label = x = (console.log(${label}:, x), x) Async.of('U Wut M8') .fork(log('rej'), log('res')) //= res: \"U Wut M8\" Resolved('U Wut M8') .fork(log('rej'), log('res')) //= res: \"U Wut M8\" Async((rej, res) = res('U Wut M8')) .fork(log('rej'), log('res')) //= res: \"U Wut M8\" Instance Methods map Async e a ~ (a - b) - Async e b Used to apply transformations to Resolved values of an Async, map takes a function that it will lift into the context of the Async and apply to it the wrapped value. When ran on a Resolved instance, map will apply the wrapped value to the provided function and return the result in a new Resolved instance. const { Rejected, Resolved } = require('crocks/Async') const and = require('crocks/logic/and') const compose = require('crocks/helpers/compose') const constant = require('crocks/combinators/constant') const ifElse = require('crocks/logic/ifElse') const isNumber = require('crocks/predicates/isNumber') const map = require('crocks/pointfree/map') // log :: String - a - a const log = label = x = (console.log(${label}:, x), x) // double :: Number - Number const double = x = x * 2 // gt10 :: Number - Boolean const gt10 = x = x 10 // isValid :: a - Async String Number const isValid = ifElse( and(isNumber, gt10), Resolved, constant(Rejected('Not Valid')) ) // doubleValid :: a - Async String Number const doubleValid = compose(map(double), isValid) Resolved(34) .map(double) .fork(log('rej'), log('res')) //= res: 68 Rejected('34') .map(double) .fork(log('rej'), log('res')) //= rej: \"34\" doubleValid(76) .fork(log('rej'), log('res')) //= res: 152 doubleValid('Too Silly') .fork(log('rej'), log('res')) //= rej: \"Not Valid\" alt Async e a ~ Async e a - Async e a Providing a means for a fallback or alternative value, alt combines (2) Async instances and will return the first Resolved instance it encounters or the last Rejected instance if it does not encounter a Resolved instance. const { Rejected, Resolved } = require('crocks/Async') // log :: String - a - a const log = label = x = (console.log(${label}:, x), x) Resolved(true) .alt(Rejected('Bad News')) .fork(log('rej'), log('res')) //= res: true Rejected('First Reject') .alt(Rejected('Second Reject')) .fork(log('rej'), log('res')) //= rej: \"Second Reject\" Rejected('First Reject') .alt(Resolved('First Resolve')) .alt(Rejected('Second Reject')) .alt(Resolved('Second Resolve')) .fork(log('rej'), log('res')) //= rej: \"First Resolve\" bimap Async e a ~ ((e - b), (a - c)) - Async b c Both Rejected and Resolved values can vary in their type, although most of the time, focus on mapping values is placed on the Resolved portion. When the requirement or need to map the Rejected portion arises, bimap can be used. bimap takes (2) functions as its arguments. The first function is used to map a Rejected instance, while the second maps a Resolved instance. While bimap requires that both possible instances are to be mapped, if the desire to map only the Rejected portion, an identity function can be provided to the second argument. This will leave all Resolved instance values untouched. const { Rejected, Resolved } = require('crocks/Async') const assoc = require('crocks/helpers/assoc') const bimap = require('crocks/pointfree/bimap') const compose = require('crocks/helpers/compose') const objOf = require('crocks/helpers/objOf') // log :: String - a - a const log = label = x = (console.log(${label}:, x), x) // hasError :: Boolean - Object - Object const hasError = assoc('hasError') // buildError :: a - String const buildError = x = ${x}: is not valid // buildResult :: (String, Boolean) - a - Object const buildResult = (key, isError) = compose(hasError(isError), objOf(key)) // finalize :: Bifunctor m = m a b - m Object Object const finalize = bimap( compose(buildResult('error', true), buildError), buildResult('result', false) ) finalize(Resolved('Good To Go')) .fork(log('rej'), log('res')) //= res: { result: \"Good To Go\", hasError: false } finalize(Rejected(null)) .fork(log('rej'), log('res')) //= rej: { error: \"null is not valid\", hasError: true } ap Async e (a - b) ~ Async e a - Async e b Short for apply, ap is used to apply an Async instance containing a value to another Async instance that contains a function, resulting in new Async instance with the result. ap requires that it is called on an instance that is either Rejected or Resolved that wraps a curried polyadic function. When either Async is Rejected, ap will return a Rejected instance, that wraps the value of the original Rejected instance. This can be used to safely combine multiple values under a given combination function. If any of the inputs result in a Rejected than they will never be applied to the function and will not result in undesired exceptions or results. When forked, all Asyncs chained with multiple ap invocations will be executed concurrently. const Async = require('crocks/Async') const { Rejected, Resolved } = Async const liftA2 = require('crocks/helpers/liftA2') // log :: String - a - a const log = label = x = (console.log(${label}:, x), x) // resolveAfter :: (Integer, a) - Async e a const resolveAfter = (delay, x) = Async( (rej, res) = setTimeout(() = res(x), delay) ) // join :: String - String - String const join = a = b = ${a} ${b} Async.of(join) .ap(Resolved('blip')) .ap(Resolved('blop')) .fork(log('rej'), log('res')) //= res: \"blip blop\" Async.of(join) .ap(Resolved('blip')) .ap(Rejected('Not Good')) .fork(log('rej'), log('res')) //= rej: \"Not Good\" Resolved('splish') .map(join) .ap(Resolved('splash')) .fork(log('rej'), log('res')) //= res: \"splish splash\" // first :: Async e String const first = resolveAfter(5000, 'first') // second :: Async e String const second = resolveAfter(5000, 'second') // ap runs all Asyncs at the same time in parallel. // This will finish running in about 5 seconds and // not 10 seconds liftA2(join, first, second) .fork(log('rej'), log('res')) //= res: \"first second\" chain Async e a ~ (a - Async e b) - Async e b Combining a sequential series of transformations that capture disjunction can be accomplished with chain. chain expects a unary, Async returning function as its argument. When invoked on a Rejected instance , chain will not run the function, but will instead return another Rejected instance wrapping the original Rejected value. When called on a Resolved instance however, the inner value will be passed to provided function, returning the result as the new instance. const Async = require('crocks/Async') const { Rejected, Resolved } = Async const chain = require('crocks/pointfree/chain') const compose = require('crocks/helpers/compose') const composeK = require('crocks/helpers/composeK') const constant = require('crocks/combinators/constant') const flip = require('crocks/combinators/flip') const ifElse = require('crocks/logic/ifElse') const isString = require('crocks/predicates/isString') const prop = require('crocks/Maybe/prop') const maybeToAsync = require('crocks/Async/maybeToAsync') // log :: String - a - a const log = label = x = (console.log(${label}:, x), x) // safe :: (b - Boolean) - b - Async String a const safe = pred = ifElse(pred, Resolved, constant(Rejected('Not Safe'))) // test :: RegExp - String - Boolean const test = regex = str = regex.test(str) // lookup :: String - Async String String const lookup = compose( maybeToAsync('Not Found'), flip(prop, { 'file-a': 'file-b', 'file-b': 'file-c' }) ) // fake :: String - Async String Object const fake = compose( chain(lookup), chain(safe(test(/^file-(a|b|c)/))), chain(safe(isString)) ) fake('file-a') .fork(log('rej'), log('res')) //= file-b // getTwo :: a - Async String String const getTwo = composeK(fake, fake) getTwo('file-a') .fork(log('rej'), log('res')) //= res: file-c getTwo('file-b') .fork(log('rej'), log('res')) //= rej: \"Not Found\" getTwo(76) .fork(log('rej'), log('res')) //= rej: \"Not Safe\" coalesce Async e a ~ ((e - b), (a - b))) - Async e b Used as a means to apply a computation to a Resolved instance and then map any Rejected value while transforming it to a Resolved to continue computation. coalesce on an Async can be used to model the all too familiar, and more imperative if/else flow in a more declarative manner. The first function is used when invoked on a Rejected instance and will return a Resolved instance wrapping the result of the function. The second function is used when coalesce is invoked on a Resolved instance and is used to map the original value, returning a new Resolved instance wrapping the result of the second function. const Async = require('crocks/Async') const { Rejected, Resolved } = Async const coalesce = require('crocks/pointfree/coalesce') // log :: String - a - a const log = label = x = (console.log(${label}:, x), x) // label :: String - String - String const label = lbl = x = ${lbl} ${x} // resolve :: Async e String - Async e String const resolve = coalesce(label('Was'), label('Still')) resolve(Resolved('Resolved')) .fork(log('rej'), log('res')) //= res: \"Still Resolved\" resolve(Rejected('Rejected')) .fork(log('rej'), log('res')) //= res: \"Was Rejected\" swap Async e a ~ ((e - b), (a - c)) - Async c b Used to map the value of a Rejected into a Resolved or a Resolved to a Rejected, swap takes (2) functions as its arguments. The first function is used to map the expected Rejected value into a Resolved, while the second goes from Resolved to Rejected. If no mapping is required on either, then identity functions can be used in one or both arguments. const Async = require('crocks/Async') const { Rejected, Resolved } = Async const compose = require('crocks/helpers/compose') const identity = require('crocks/combinators/identity') const swap = require('crocks/pointfree/swap') // log :: String - a - a const log = label = x = (console.log(${label}:, x), x) // length :: String - Integer const length = x = x.length // repeat :: String - Number - String const repeat = char = n = char.repeat(n) // values :: Async String Number - Async String Number const values = swap(length, repeat('a')) // valueIso :: Async String Number - Async String Number const valueIso = compose(values, values) // types :: Async a b - b a const types = swap(identity, identity) // typeIso :: Async a b - b a const typeIso = compose(types, types) values(Resolved(5)) .fork(log('rej'), log('res')) //= rej: \"aaaaa\" values(Rejected('aaaaa')) .fork(log('rej'), log('res')) //= res: 5 valueIso(Resolved(5)) .fork(log('rej'), log('res')) //= res: 5 valueIso(Rejected('aaaaa')) .fork(log('rej'), log('res')) //= rej: \"aaaaa\" types(Resolved(5)) .fork(log('rej'), log('res')) //= rej: 5 types(Rejected('aaaaa')) .fork(log('rej'), log('res')) //= res: \"aaaaa\" typeIso(Resolved(5)) .fork(log('rej'), log('res')) //= res: 5 typeIso(Rejected('aaaaa')) .fork(log('rej'), log('res')) //= rej: \"aaaaa\" fork Async e a ~ ((e - ()), (a - ())) - (() - ()) Async e a ~ ((e - ()), (a - ()), (() - ())) - (() - ()) The Async type is lazy and will not be executed until told to do so and fork is the primary method used for execution. fork implements (2) signatures depending on the need for clean up in the event of cancellation, but both return a function that can be used for cancellation of a given instance. The first and more common signature takes (2) functions that will have their return values ignored. The first function will be run in the event of the Async instance settling on Rejected and will receive as its single argument the value or \"cause\" of rejection. The second function provided will be executed in the case of the instance settling on Resolved and will receive as its single argument the value the Async was resolved with. The second signature is used when any cleanup needs to be performed after a given Async is cancelled by having the function returned from fork called. The first (2) arguments to the signature are the same as the more common signature described above, but takes an addition function that can be used for \"clean up\" after cancellation. When all in-flight computations settle, the function provided will be silently executed. const Async = require('crocks/Async') const compose = require('crocks/helpers/compose') // log :: String - a - a const log = label = x = (console.log(${label}:, x), x) // inc :: Number - Number const inc = n = n + 1 // delay :: a - Async e a const delay = x = Async( (rej, res) = { setTimeout(() = res(x), 1000) } ).map(compose(inc, log('value'))) delay(0) .chain(delay) .chain(delay) .fork(log('rej'), log('res')) //= value: 0 //= value: 1 //= value: 2 //= res: 3 const cancel = delay(0) .chain(delay) .chain(delay) .fork(log('rej'), log('res')) //= value: 0 //= value: 1 setTimeout(cancel, 2200) toPromise Async e a ~ () - Promise a e While fork is the more common method for running an Async instance, there may come time where a Promise is needed at the edge of a given program or flow. When the need to integrate into an existing Promise chain arises, Async provides the toPromise method. toPromise takes no arguments and when invoked will fork the instance internally and return a Promise that will be in-flight. This comes in handy for integration with other Promise based libraries that are utilized in a given application, program or flow. const { Rejected, Resolved } = require('crocks/Async') // log :: String - a - a const log = label = x = (console.log(${label}:, x), x) Resolved('resolved') .toPromise() .then(log('res')) .catch(log('rej')) //= res: resolved Rejected('rejected') .toPromise() .then(log('res')) .catch(log('rej')) //= rej: rejected Transformation Functions eitherToAsync crocks/Async/eitherToAsync eitherToAsync :: Either b a - Async b a eitherToAsync :: (a - Either c b) - a - Async c b Used to transform a given Either instance to an Async instance, eitherToAsync will turn a Right instance into a Resolved instance wrapping the original value contained in the original Right. If a Left is provided, then eitherToAsync will return a Rejected instance, wrapping the original Left value. Like all crocks transformation functions, eitherToAsync has (2) possible signatures and will behave differently when passed either an Either instance or a function that returns an instance of Either. When passed the instance, a transformed Async is returned. When passed an Either returning function, a function will be returned that takes a given value and returns an Async. const { Resolved } = require('crocks/Async') const { Left, Right } = require('crocks/Either') const eitherToAsync = require('crocks/Async/eitherToAsync') const and = require('crocks/logic/and') const ifElse = require('crocks/logic/ifElse') const isNumber = require('crocks/predicates/isNumber') // log :: String - a - a const log = label = x = (console.log(${label}:, x), x) // gte :: Number - Number - Boolean const gte = x = y = y = x // isLarge :: a - Boolean const isLarge = and(isNumber, gte(10)) // isValid :: a - Either String a const isValid = ifElse( isLarge, Right, x = Left(${x} is not valid) ) eitherToAsync(Right('Correct')) .fork(log('rej'), log('res')) //= res: \"Correct\" eitherToAsync(Left('Not Good')) .fork(log('rej'), log('res')) //= rej: \"Not Good\" Resolved(54) .chain(eitherToAsync(isValid)) .fork(log('rej'), log('res')) //= res: 54 Resolved(4) .chain(eitherToAsync(isValid)) .fork(log('rej'), log('res')) //= rej: \"4 is not valid\" Resolved('Bubble') .chain(eitherToAsync(isValid)) .fork(log('rej'), log('res')) //= rej: \"Bubble is not valid\" firstToAsync crocks/Async/firstToAsync firstToAsync :: e - First a - Async e a firstToAsync :: e - (a - First b) - a - Async e b Used to transform a given First instance to an Async instance, firstToAsync will turn a non-empty First instance into a Resolved instance wrapping the original value contained in the original non-empty. The First datatype is based on a Maybe and as such its left or empty value is fixed to a () type. As a means to allow for convenient transformation, firstToAsync takes a default Rejected value as the first argument. This value will be wrapped in a resulting Rejected instance in the case of empty. Like all crocks transformation functions, firstToAsync has (2) possible signatures and will behave differently when passed either a First instance or a function that returns an instance of First. When passed the instance, a transformed Async is returned. When passed a First returning function, a function will be returned that takes a given value and returns an Async. const { Resolved } = require('crocks/Async') const First = require('crocks/First') const firstToAsync = require('crocks/Async/firstToAsync') const Pred = require('crocks/Pred') const isString = require('crocks/predicates/isString') const mconcatMap = require('crocks/helpers/mconcatMap') const safe = require('crocks/Maybe/safe') // log :: String - a - a const log = label = x = (console.log(${label}:, x), x) // length :: String - Number const length = x = x.length // gte :: Number - Number - Boolean const gte = x = y = y = x // isValid :: Pred String const isValid = Pred(isString) .concat(Pred(gte(4)).contramap(length)) // firstValid :: [ String ] - First String const firstValid = mconcatMap(First, safe(isValid)) // findFirstValid :: [ String ] - Async String String const findFirstValid = firstToAsync('Nothing Found', firstValid) firstToAsync('Error', First(true)) .fork(log('rej'), log('res')) //= res: true firstToAsync('Error', First.empty()) .fork(log('rej'), log('res')) //= rej: \"Error\" Resolved([ 'cat', 'rhino', 'unicorn' ]) .chain(findFirstValid) .fork(log('rej'), log('res')) //= res: \"rhino\" Resolved([ 1, 2, 3 ]) .chain(findFirstValid) .fork(log('rej'), log('res')) //= rej: \"Nothing Found\" Resolved([ 'cat', 'bat', 'imp' ]) .chain(findFirstValid) .fork(log('rej'), log('res')) //= rej: \"Nothing Found\" lastToAsync crocks/Async/lastToAsync lastToAsync :: e - Last a - Async e a lastToAsync :: e - (a - Last b) - a - Async e b Used to transform a given Last instance to an Async instance, lastToAsync will turn a non-empty Last instance into a Resolved instance wrapping the original value contained in the original non-empty. The Last datatype is based on a Maybe and as such its left or empty value is fixed to a () type. As a means to allow for convenient transformation, lastToAsync takes a default Rejected value as the first argument. This value will be wrapped in a resulting Rejected instance, in the case of empty. Like all crocks transformation functions, lastToAsync has (2) possible signatures and will behave differently when passed either a Last instance or a function that returns an instance of Last. When passed the instance, a transformed Async is returned. When passed a Last returning function, a function will be returned that takes a given value and returns an Async. const { Resolved } = require('crocks/Async') const Last = require('crocks/Last') const lastToAsync = require('crocks/Async/lastToAsync') const Pred = require('crocks/Pred') const isString = require('crocks/predicates/isString') const mconcatMap = require('crocks/helpers/mconcatMap') const safe = require('crocks/Maybe/safe') // log :: String - a - a const log = label = x = (console.log(${label}:, x), x) // length :: String - Number const length = x = x.length // gte :: Number - Number - Boolean const gte = x = y = y = x // isValid :: Pred String const isValid = Pred(isString) .concat(Pred(gte(4)).contramap(length)) // lastValid :: [ String ] - Last String const lastValid = mconcatMap(Last, safe(isValid)) // findLastValid :: [ String ] - Async String String const findLastValid = lastToAsync('Nothing Found', lastValid) lastToAsync('Error', Last(true)) .fork(log('rej'), log('res')) //= res: true lastToAsync('Error', Last.empty()) .fork(log('rej'), log('res')) //= rej: \"Error\" Resolved([ 'unicorn', 'rhino', 'cat' ]) .chain(findLastValid) .fork(log('rej'), log('res')) //= res: \"rhino\" Resolved([ 1, 2, 3 ]) .chain(findLastValid) .fork(log('rej'), log('res')) //= rej: \"Nothing Found\" Resolved([ 'cat', 'bat', 'imp' ]) .chain(findLastValid) .fork(log('rej'), log('res')) //= rej: \"Nothing Found\" maybeToAsync crocks/Async/maybeToAsync maybeToAsync :: e - Maybe a - Async e a maybeToAsync :: e - (a - Maybe b) - a - Async e b Used to transform a given Maybe instance to an Async instance, maybeToAsync will turn a Just instance into a Resolved instance wrapping the original value contained in the original Just. A Nothing instance is fixed to a () type and as such can only ever contain a value of undefined. As a means to allow for convenient transformation, maybeToAsync takes a default Rejected value as the first argument. This value will be wrapped in a resulting Rejected instance, in the case of Nothing. Like all crocks transformation functions, maybeToAsync has (2) possible signatures and will behave differently when passed either a Maybe instance or a function that returns an instance of Maybe. When passed the instance, a transformed Async is returned. When passed a Maybe returning function, a function will be returned that takes a given value and returns an Async. const { Resolved } = require('crocks/Async') const { Nothing, Just } = require('crocks/Maybe') const maybeToAsync = require('crocks/Async/maybeToAsync') const and = require('crocks/logic/and') const isEmpty = require('crocks/predicates/isEmpty') const isArray = require('crocks/predicates/isArray') const not = require('crocks/logic/not') const safe = require('crocks/Maybe/safe') // log :: String - a - a const log = label = x = (console.log(${label}:, x), x) // isValid :: a - Maybe [ b ] const isValid = safe( and(isArray, not(isEmpty)) ) maybeToAsync(false, Just(true)) .fork(log('rej'), log('res')) //= res: true maybeToAsync('Bad', Nothing()) .fork(log('rej'), log('res')) //= rej: \"Bad\" Resolved([ 'a', 'b', 'c' ]) .chain(maybeToAsync('Invalid', isValid)) .fork(log('rej'), log('res')) //= res: [ 'a', 'b', 'c' ] Resolved([]) .chain(maybeToAsync('Invalid', isValid)) .fork(log('rej'), log('res')) //= rej: \"Invalid\" Resolved('') .chain(maybeToAsync('Invalid', isValid)) .fork(log('rej'), log('res')) //= rej: \"Invalid\" resultToAsync crocks/Async/resultToAsync resultToAsync :: Result b a - Async b a resultToAsync :: (a - Result c b) - a - Result c b Used to transform a given Result instance to an Async instance, resultToAsync will turn an Ok instance into a Resolved instance wrapping the original value contained in the original Ok. If an Err is provided, then resultToAsync will return a Rejected instance, wrapping the original Err value. Like all crocks transformation functions, resultToAsync has (2) possible signatures and will behave differently when passed either a Result instance or a function that returns an instance of Result. When passed the instance, a transformed Async is returned. When passed a Result returning function, a function will be returned that takes a given value and returns an Async. const { Resolved } = require('crocks/Async') const { Err, Ok } = require('crocks/Result') const resultToAsync = require('crocks/Async/resultToAsync') const identity = require('crocks/combinators/identity') const isNumber = require('crocks/predicates/isNumber') const tryCatch = require('crocks/Result/tryCatch') // log :: String - a - a const log = label = x = (console.log(${label}:, x), x) // notNumber :: a - Number function notNumber(x) { if (!isNumber(x)) { throw new TypeError('Must be a Number') } return x } // safeFail :: a - Result TypeError Number const safeFail = tryCatch(notNumber) resultToAsync(Ok(99)) .fork(log('rej'), log('res')) //= res: 99 resultToAsync(Err('Not Good')) .fork(log('rej'), log('res')) //= rej: \"Not Good\" Resolved(103) .chain(resultToAsync(safeFail)) .bimap(x = x.message, identity) .fork(log('rej'), log('res')) //= res: 103 Resolved('103') .chain(resultToAsync(safeFail)) .bimap(x = x.message, identity) .fork(log('rej'), log('res')) //= rej: \"Must be a Number\" [nary]: ../functions/helpers.html#nary [identity]: ../functions/combinators.html#identity [first]: ../monoids/First.html [last]: ../monoids/Last.html [maybe]: ../crocks/Maybe.html [just]: ../crocks/Maybe.html#just [nothing]: ../crocks/Maybe.html#nothing ","srcFilePath":"src/pages/docs/crocks/Async.md","id":"Async","location":"/docs/crocks/Async.html","url":"/crocks/docs/crocks/Async.html"},"Equiv":{"title":"Equiv","description":"Equiv Crock","layout":"guide","weight":50,"content":" Equiv a a Boolean Defined as a Monoidal Contravariant datatype, Equiv can be used to test equivalence between (2) values of a given type. It does this by wrapping a binary equivalence function of the form (a, a) - Boolean. Most of the time strict equality is used, but other functions of the required form can provide some powerful results. While the far right parameter is always fixed to Boolean it cannot be Covariant, but is Contravariant allowing both inputs to vary in their type. Equiv is also a Monoid and will concat the results of (2) Equivs under logical conjunction, with it's empty value always returning true. As Equiv wraps a function, it is lazy and a given instance will not produce a result until both arguments are satisfied. A given instance can be run by calling the method compareWith, providing both values for comparison. const Equiv = require('crocks/Equiv') const equals = require('crocks/pointfree/equals') // toString :: a - String const toString = x = x.toString() // length :: a - Number const length = x = x && x.length ? x.length : 0 // eq :: Equiv a a const eq = Equiv(equals) eq.contramap(toString) .compareWith('123', 123) //= true eq.contramap(length) .compareWith([ 1, 2, 3 ], [ 'a', 'b' ]) //= false Implements Semigroup, Monoid, Contravariant Constructor Methods empty Equiv.empty :: () - Equiv a a empty provides the identity for the Monoid in that when the value it provides is concated to any other value, it will return the other value. In the case of Equiv the result of empty is an Equiv that will always return true. empty is available on both the Constructor and the Instance for convenience. const Equiv = require('crocks/Equiv') const equals = require('crocks/pointfree/equals') const eq = Equiv(equals) const empty = Equiv.empty() eq .concat(empty) .compareWith({ a: 32 }, { a: 32 }) //= true empty .concat(eq) .compareWith({ a: 32 }, { a: 32 }) //= true empty .concat(eq) .compareWith({ a: 32, b: 19 }, { a: 32 }) //= false Instance Methods concat Equiv a a ~ Equiv a a - Equiv a a concat is used to combine (2) Semigroups of the same type under an operation specified by the Semigroup. In the case of Equiv, the results of both Equivs are combined under logical conjunction. const Equiv = require('crocks/Equiv') const compareWith = require('crocks/pointfree/compareWith') const equals = require('crocks/pointfree/equals') const isSameType = require('crocks/predicates/isSameType') const propOr = require('crocks/helpers/propOr') // objLength :: Object - Number const objLength = x = Object.keys(x).length // eq :: Equiv a a const eq = Equiv(equals) // sameType :: Equiv a a const sameType = Equiv(isSameType) // sameType :: Equiv Object Object const length = eq.contramap(objLength) // sameType :: Equiv a a const sameTypeProp = key = sameType.contramap(propOr(null, key)) // run :: Equiv Object Object const run = compareWith( { a: 19, b: 'string' }, { a: 32, c: false } ) run(length) //= true run(sameTypeProp('a')) //= true run(sameTypeProp('b')) //= false run( sameTypeProp('a') .concat(length) ) // true run( sameTypeProp('b') .concat(length) ) // false contramap Equiv a a ~ (b - a) - Equiv b b The far right parameter of Equiv fixed to Boolean which means we cannot map the value as expected. However the left two parameters can vary, although they must vary in the same manner. This is where contramap comes into play as it can be used to adapt an Equiv of a given type to accept a different type or modify the value. Provide it a function that has a return type that matches the input types of the Equiv. This will return a new Equiv matching the input type of the provided function. const Equiv = require('crocks/Equiv') const equals = require('crocks/pointfree/equals') // length :: String - Number const length = x = x.length // eq :: Equiv a a const eq = Equiv(equals) // sameLength :: Equiv String String const sameLength = eq.contramap(length) // sameAmplitude :: Equiv Float Float const sameAmplitude = eq.contramap(Math.abs) sameAmplitude .compareWith(-0.5011, 0.5011) //= true sameAmplitude .compareWith(-0.755, 0.8023) //= false sameLength .compareWith('aBcD', '1234') //= true sameLength .compareWith('AB', 'ABC') //= false valueOf Equiv a a ~ () - a - a - Boolean valueOf is used on all crocks Monoids as a means of extraction. While the extraction is available, types that implement valueOf are not necessarily a Comonad. This function is used primarily for convenience for some of the helper functions that ship with crocks. Calling valueOf on an Equiv instance will result in the underlying curried equivalence function. const Equiv = require('crocks/Equiv') const compose = require('crocks/helpers/compose') const equals = require('crocks/pointfree/equals') const propOr = require('crocks/helpers/propOr') // toLower :: String - String const toLower = x = x.toLowerCase() // length :: String - String const length = x = x.length // lowerName :: Object - String const lowerName = compose(toLower, propOr('', 'name')) // itemsLen :: Object - Number const itemsLen = compose(length, propOr('', 'items')) // eq :: Equiv a a const eq = Equiv(equals) // checkName :: Equiv Object Object const checkName = eq.contramap(lowerName) // checkName :: Equiv Object Object const checkItems = eq.contramap(itemsLen) // test :: Object - Object - Boolean const test = checkName .concat(checkItems) .valueOf() test( { name: 'Bob', items: [ 1, 2, 4 ] }, { name: 'bOb', items: [ 9, 12, 9 ] } ) //= true compareWith Equiv a a ~ a - a - Boolean As Equiv wraps a function, it needs a means to be run with two values for comparison. Instances provide a curried method called compareWith that takes two values for comparison and will run them through the equivalence function, returning the resulting Boolean. Due to the laziness of this type, complicated comparisons can be built out from combining and mapping smaller, simpler units of equivalence comparison. const Equiv = require('crocks/Equiv') // both :: Equiv Boolean Boolean const both = Equiv((x, y) = x && y) // isEven :: Number - Boolean const isEven = x = x % 2 === 0 // isBig :: Number - Boolean const isBig = x = x 10 // bothEven :: Equiv Number Number const bothEven = both.contramap(isEven) // bothBig :: Equiv Number Number const bothBig = both.contramap(isBig) bothEven .compareWith(12, 20) //= true bothEven .compareWith(17, 20) //= false bothBig .compareWith(17)(20) //= true bothBig .compareWith(7)(20) //= false bothBig .concat(bothEven) .compareWith(8)(54) //= false [monoids]: ../monoids/index.html ","srcFilePath":"src/pages/docs/crocks/Equiv.md","id":"Equiv","location":"/docs/crocks/Equiv.html","url":"/crocks/docs/crocks/Equiv.html"},"Maybe":{"title":"Maybe","description":"Maybe Crock","layout":"guide","weight":90,"content":" Maybe a = Nothing | Just a Defined as a Sum Type with its left side fixed to () (Nothing), Maybe is well suited for capturing disjunction when the cause of the \"error\" case does not need to be communicated. For example, providing default values on specific conditions. A Maybe represents disjunction by using (2) constructors, Nothing or Just. A Just instance represents the truth case while Nothing is considered false. With the exception of coalesce, all Maybe returning methods on an instance will be applied to a Just returning the result. If an instance is a Nothing, then all application is skipped and another Nothing is returned. It is recommended to use the available Just and Nothing constructors to construct Maybe instances in most cases. You can use the Maybe constructor to construct a Just, but it may read better to just use Just. const { Just, Nothing } = require('crocks/Maybe') const chain = require('crocks/pointfree/chain') const compose = require('crocks/helpers/compose') const ifElse = require('crocks/logic/ifElse') const isNumber = require('crocks/predicates/isNumber') // gt5 :: Number - Boolean const gt5 = x = x 5 // safe :: (a - Boolean) - a - Maybe b const safe = pred = ifElse(pred, Just, Nothing) // safeNumber :: a - Maybe Number const safeNumber = safe(isNumber) // maybeBig :: Number - Maybe Number const maybeBig = safe(gt5) // bigNumber :: a - Maybe Number const bigNumber = compose( chain(maybeBig), safeNumber ) safeNumber(45) //= Just 45 safeNumber('99') //= Nothing maybeBig(99) //= Just 99 maybeBig(2) //= Nothing bigNumber(34) //= Just 34 bigNumber('string') //= Nothing bigNumber(3) //= Nothing Implements Setoid, Semigroup, Functor, Alt, Plus, Apply, Traversable, Chain, Applicative, Alternative, Monad Constructor Methods Nothing Maybe.Nothing :: () - Maybe a Used to construct a Nothing instance that represents the \"false\" portion of a disjunction. When an instance is a Nothing, most Maybe returning methods will just return another Nothing. Anything passed to the constructor will be thrown out and mapped to (). const { Just, Nothing } = require('crocks/Maybe') const chain = require('crocks/pointfree/chain') const isNumber = require('crocks/predicates/isNumber') const safeLift = require('crocks/Maybe/safeLift') // add10 :: Number - Number const add10 = x = x + 10 // safeAdd10 :: a - Maybe Number const safeAdd10 = safeLift(isNumber, add10) Just(23) .map(add10) //= Just 33 Nothing(23) .map(add10) //= Nothing chain(safeAdd10, Just(10)) //= Just 20 chain(safeAdd10, Nothing()) //= Nothing Just Maybe.Just :: a - Maybe a Used to construct a Just instance that represents the \"true\" portion of a disjunction or a valid value. Just will wrap any given value in a Just, signaling the validity of the wrapped value. const { Just, Nothing } = require('crocks/Maybe') const compose = require('crocks/helpers/compose') const ifElse = require('crocks/logic/ifElse') const isString = require('crocks/predicates/isString') const map = require('crocks/pointfree/map') // toUpper :: String - String const toUpper = x = x.toUpperCase() // safe :: (a - Boolean) - a - Maybe a const safe = pred = ifElse(pred, Just, Nothing) // safeShout :: a - Maybe String const safeShout = compose( map(toUpper), safe(isString) ) safeShout(45) //= Nothing safeShout('Hey there!') //= Just \"HEY THERE!\" of Maybe.of :: a - Maybe a Used to wrap any value into a Maybe as a Just, of is used mostly by helper functions that work \"generically\" with instances of either Applicative or Monad. When working specifically with the Maybe type, the Just constructor should be used. Reach for of when working with functions that will work with ANY Applicative/Monad. const Maybe = require('crocks/Maybe') const { Just } = Maybe const curry = require('crocks/helpers/curry') const isString = require('crocks/predicates/isString') const safe = require('crocks/Maybe/safe') Maybe(35) //= Just 35 Just(35) //= Just 35 Maybe.of(35) //= Just 35 const safeString = safe(isString) // lift2 :: Applicative m = (a - b - c) - m a - m b - m c const lift2 = curry( (fn, x, y) = x.of(fn).ap(x).ap(y) ) // join :: Applicative m = m String - m String - m String const join = lift2(a = b = ${a} ${b}) join(safeString('Brad'), safeString('Pitt')) //= Just \"Brad Pitt\" join(safeString(34), safeString('Pitt')) //= Nothing zero Maybe.zero :: () - Maybe a When working with Alts, zero provides a sort of empty or identity for Maybe when used with alt. zero takes no arguments and returns a Nothing instance. Just like an empty method on a given Monoid, zero can be used to fold a collection of Alts under alt. const { Nothing, Just, zero } = require('crocks/Maybe') const alt = require('crocks/pointfree/alt') const flip = require('crocks/combinators/flip') const isNumber = require('crocks/predicates/isNumber') const mapReduce = require('crocks/helpers/mapReduce') const safe = require('crocks/Maybe/safe') // firstValid :: [ * ] - Maybe Number const firstValid = mapReduce(safe(isNumber), flip(alt), zero()) Just(33) .alt(zero()) //= Just 33 zero() .alt(Just(33)) //= Just 33 Nothing() .alt(zero()) //= Nothing zero() .alt(Nothing()) //= Nothing firstValid([ null, 'nope', 10, 45 ]) //= Just 10 firstValid([ 75, null, 'nope' ]) //= Just 75 firstValid([ null, undefined, 'wrong' ]) //= Nothing Instance Methods equals Maybe a ~ b - Boolean Used to compare the underlying values of (2) Maybe instances for equality by value, equals takes any given argument and returns true if the passed arguments is a Maybe with an underlying value equal to the underlying value of the Maybe the method is being called on. If the passed argument is not a Maybe or the underlying values are not equal, equals will return false. const { Nothing, Just } = require('crocks/Maybe') const equals = require('crocks/pointfree/equals') Just(33) .equals(Just(33)) //= true Nothing() .equals(Nothing()) //= true Nothing() .equals(Just(33)) //= false // by value, not reference for most types Just({ a: 86, b: true }) .equals(Just({ a: 86, b: true })) //= true equals(Just(95), 95) //= false equals(undefined, Nothing()) //= false equals(Just([ 2, 3 ]), Just([ 2, 3 ])) //= true concat Semigroup s = Maybe s ~ Maybe s - Maybe s When an underlying value of a given Maybe is fixed to a Semigroup, concat can be used to concat another Maybe instance with an underlying Semigroup of the same type. Expecting a Maybe wrapping a Semigroup of the same type, concat will give back a new Maybe instance wrapping the result of combining the (2) underlying Semigroups. When called on a Nothing instance, concat will return a Nothing. const { Nothing, Just } = require('crocks/Maybe') const Sum = require('crocks/Sum') const compose = require('crocks/helpers/compose') const concat = require('crocks/pointfree/concat') const flip = require('crocks/combinators/flip') const isNumber = require('crocks/predicates/isNumber') const map = require('crocks/pointfree/map') const mapReduce = require('crocks/helpers/mapReduce') const safeLift = require('crocks/Maybe/safeLift') const valueOf = require('crocks/pointfree/valueOf') // safeSum :: a - Maybe Sum const safeSum = safeLift(isNumber, Sum) // empty :: Maybe Sum const empty = Just(Sum.empty()) // sumList :: [ * ] - Maybe Number const sumList = compose( map(valueOf), mapReduce(safeSum, flip(concat), empty) ) Just([ 34 ]) .concat(Just([ 92 ])) //= Just [ 34, 92 ] Just([ 34 ]) .concat(Nothing()) //= Nothing sumList([ 3, 4, 5 ]) //= Just 12 sumList([ 'three', 4, 'five' ]) //= Nothing map Maybe a ~ (a - b) - Maybe b Used to apply transformations to values in the safety of a Maybe, map takes a function that it will lift into the context of the Maybe and apply to it the wrapped value. When ran on a Just instance, map will apply the wrapped value to the provided function and return the result in a new Just instance. const { Nothing, Just } = require('crocks/Maybe') const assign = require('crocks/helpers/assign') const compose = require('crocks/helpers/compose') const isObject = require('crocks/predicates/isObject') const isString = require('crocks/predicates/isString') const map = require('crocks/pointfree/map') const safe = require('crocks/Maybe/safe') // add10 :: Number - Number const add10 = x = x + 10 // toUpper :: String - String const toUpper = x = x.toUpperCase() // safeObj :: a - Maybe Object const safeObj = safe(isObject) // shout :: a - Maybe String const shout = x = safe(isString, x) .map(toUpper) // setProcessed :: a - Maybe Object const setProcessed = compose( map(assign({ processed: true })), safeObj ) Just(0) .map(add10) //= Just 10 Nothing() .map(add10) //= Nothing shout('good news') //= Just \"GOOD NEWS\" shout(33) //= Nothing setProcessed({ cheese: true }) //= Just { cheese: true, processed: true } setProcessed(null) //= Nothing alt Maybe a ~ Maybe a - Maybe a Providing a means for a fallback or alternative value, alt combines (2) Maybe instances and will return the first Just it encounters or Nothing if it does not have a Just. This can be used in conjunction with zero to return the first valid value in contained in a Foldable structure. const { zero, Nothing, Just } = require('crocks/Maybe') const alt = require('crocks/pointfree/alt') const isArray = require('crocks/predicates/isArray') const flip = require('crocks/combinators/flip') const mapReduce = require('crocks/helpers/mapReduce') const safe = require('crocks/Maybe/safe') // firstArray :: Foldable f = f * - Maybe Array const firstArray = mapReduce(safe(isArray), flip(alt), zero()) Nothing() .alt(Just(33)) //= Just 33 Just(42) .alt(Nothing()) .alt(Just(99)) //= Just 42 firstArray([ 'Not Array', null, [ 2, 3, 4 ], [ 1, 2 ] ]) //= Just [ 2, 3, 4 ] firstArray([ null, 5, '76' ]) //= Nothing ap Maybe (a - b) ~ Maybe a - Maybe b Short for apply, ap is used to apply a Maybe instance containing a value to another Maybe instance that contains a function, resulting in new Maybe instance with the result. ap requires that it is called on an instance that is either a Nothing or a Just that wraps a curried polyadic function. When either Maybe is a Nothing, ap will return a Nothing. This can be used to safely combine multiple values under a given combination function. If any of the inputs results in a Nothing than they will never be applied to the function and not provide exceptions or unexpected results. const Maybe = require('crocks/Maybe') const { Nothing, Just } = Maybe const compose = require('crocks/helpers/compose') const chain = require('crocks/pointfree/chain') const curry = require('crocks/helpers/curry') const fanout = require('crocks/helpers/fanout') const isString = require('crocks/predicates/isString') const liftA2 = require('crocks/helpers/liftA2') const merge = require('crocks/Pair/merge') const prop = require('crocks/Maybe/prop') const safe = require('crocks/Maybe/safe') // add :: Number - Number - Number const add = x = y = x + y // joinWith :: String - String - String - String const joinWith = curry( (del, x, y) = x + del + y ) // stringProp :: String - a - Maybe String const stringProp = key = compose( chain(safe(isString)), prop(key) ) // getNames :: a - Pair (Maybe String) (Maybe String) const getNames = fanout( stringProp('first'), stringProp('last') ) // joinNames :: Pair (Maybe String) (Maybe String) - Maybe String const joinNames = merge(liftA2(joinWith(' '))) // fullName :: a - Maybe String const fullName = compose(joinNames, getNames) Maybe.of(add) .ap(Just(5)) .ap(Just(27)) //= Just 32 Just('hello') .map(joinWith(' -- ')) .ap(Just('friend')) //= Just \"hello -- friend\" Maybe.of(add) .ap(Just(29)) .ap(Nothing()) //= Nothing fullName({ first: 'Joey', last: 'Fella' }) //= Just \"Joey Fella\" fullName(null) //= Nothing fullName({ first: 'Lizzy' }) //= Nothing sequence Applicative f = Maybe (f a) ~ (a - f a) - f (Maybe a) When an instance of Maybe wraps a possible Applicative instance, sequence can be used to \"swap\" the \"type sequence\". sequence requires that the of, or Applicative function of the wrapped Applicative instance is provided for the case of when the Maybe instance is a Nothing. sequence can be derived from traverse by passing it an identity function (x = x). const { Nothing, Just } = require('crocks/Maybe') const Identity = require('crocks/Identity') const sequence = require('crocks/pointfree/sequence') // seqId :: Maybe Identity a - Identity Maybe a const seqId = sequence(Identity.of) seqId(Just(Identity(34))) //= Identity Just 34 seqId(Nothing()) //= Identity Nothing traverse Applicative f = Maybe a ~ ((a - f a), (a - f b)) - f Maybe b Used to apply the \"effect\" of an Applicative to a value inside of a Maybe, traverse, combines both the \"effects\" of the Applicative and the Maybe by returning a new instance of the Applicative wrapping the result of the Applicatives \"effect\" on the value in the Maybe. traverse requires the of function of the target Applicative and a function that is used to apply the Applicative to the value inside of the Maybe. Both functions must return an instance of the Applicative. const IO = require('crocks/IO') const compose = require('crocks/helpers/compose') const isNumber = require('crocks/predicates/isNumber') const safe = require('crocks/Maybe/safe') const traverse = require('crocks/pointfree/traverse') let someGlobal = 10 // addToGlobal :: Number - IO Number const addToGlobal = x = IO(function() { someGlobal = someGlobal + x return someGlobal }) // safeAddToGlobal :: a - IO (Maybe Number) const safeAddToGlobal = compose( traverse(IO.of, addToGlobal), safe(isNumber) ) safeAddToGlobal(32) .run() //= Just 42 //someGlobal = 42 safeAddToGlobal(undefined) .run() //= Nothing //someGlobal = 42 chain Maybe a ~ (a - Maybe b) - Maybe b Combining a sequential series of transformations that capture disjunction can be accomplished with chain. chain expects a unary, Maybe returning function as its argument. When invoked on a Nothing, chain will not run the function, but will instead return another Nothing. When called on a Just however, the inner value will be passed to provided function, returning the result as the new instance. const { Nothing, Just } = require('crocks/Maybe') const chain = require('crocks/pointfree/chain') const compose = require('crocks/helpers/compose') const isNumber = require('crocks/predicates/isNumber') const isString = require('crocks/predicates/isString') const prop = require('crocks/Maybe/prop') const safe = require('crocks/Maybe/safe') const safeLift = require('crocks/Maybe/safeLift') // double :: Number - Number const double = x = x + x // chainNumber :: Maybe a - Maybe Number const chainNumber = chain(safe(isNumber)) // doubleValue :: a - Maybe Number const doubleValue = compose( chain(safeLift(isNumber, double)), prop('value') ) chainNumber(Just(45)) //= Just 45 chainNumber(Nothing()) //= Nothing Just(45) .chain(safe(isString)) //= Nothing doubleValue(undefined) //= Nothing doubleValue({ value: '45' }) //= Nothing doubleValue({ number: 45 }) //= Nothing doubleValue({ value: 45 }) //= Just 90 coalesce Maybe a ~ ((() - b), (a - b))) - Maybe b When one would like to option a Maybe but would like to remain within a Maybe type, coalesce can be used. coalesce expects (2) functions for it's inputs. The first function is used when invoked on a Nothing and will return a Just instance wrapping the result of the function. The second function is used when coalesce is invoked on a Just and is used to map the original value, returning a new Just instance wrapping the result of the second function. const { Nothing, Just } = require('crocks/Maybe') const compose = require('crocks/helpers/compose') const composeK = require('crocks/helpers/composeK') const coalesce = require('crocks/pointfree/coalesce') const constant = require('crocks/combinators/constant') const identity = require('crocks/combinators/identity') const isString = require('crocks/predicates/isString') const map = require('crocks/pointfree/map') const objOf = require('crocks/helpers/objOf') const prop = require('crocks/Maybe/prop') const safe = require('crocks/Maybe/safe') // shout :: String - String const shout = x = x.toUpperCase() // defaultString :: Maybe String - Maybe String const defaultString = coalesce(constant(''), identity) // shoutOut :: String - Object const shoutOut = compose( objOf('shout'), shout ) // stringValue :: a - Maybe String const stringValue = composeK( safe(isString), prop('value') ) // shoutValue :: a - Maybe Object const shoutValue = compose( map(shoutOut), defaultString, stringValue ) Just(76) .coalesce(constant(0), identity) //= Just 76 Nothing() .coalesce(constant(0), identity) //= Just 0 shoutValue({ value: 'hello' }) //= Just { shout: 'HELLO' } shoutValue(undefined) //= Just { shout: '' } shoutValue({ value: 49 }) //= Just { shout: '' } shoutValue({}) //= Just { shout: '' } option Maybe a ~ a - a Used as the primary way to \"fold\" a value out of a Maybe, option expects a default value. The default value provided will be returned when option is invoked on a Nothing instance. When invoked on a Just, the underlying value is returned, discarding the provided default value. option is typically ran at the \"edge\" of a flow, to provide default values for complicated representations of disjunction. When the need to immediately map the result of optioning a Maybe arises, then either may be employed to combine it in one operation. const { Nothing, Just } = require('crocks/Maybe') Nothing() .option(0) //= 0 Just(99) .option(0) //= 99 either Maybe a ~ ((() - b), (a - b)) - b Used to provide a means to map a given Maybe instance while optioning out the wrapped value. option can handle most cases for optioning Maybe, but does not provide a means to map a given value at the time of optioning. either expects (2) functions as its arguments. The first is a pointed function that will be used when invoked on a Nothing. While the second will map the value wrapped in a given Just and return the result of that mapping. const { Nothing, Just } = require('crocks/Maybe') const either = require('crocks/pointfree/either') // wrap :: a - [ a ] const wrap = x = [ x ] // empty :: () - [ a ] const empty = () = [] // toArray :: Maybe a - [ a ] const toArray = either(empty, wrap) toArray(Just(56)) //= [ 56 ] toArray(Nothing()) //= [] Helper Functions prop crocks/Maybe/prop prop :: (String | Integer) - a - Maybe b If you want some safety around pulling a value out of an Object or Array with a single key or index, you can always reach for prop. Well, as long as you are working with non-nested data that is. Just tell prop either the key or index you are interested in, and you will get back a function that will take anything and return a Just with the wrapped value if the key/index is defined. If the key/index is not defined, you will get back a Nothing. const composeK = require('crocks/helpers/composeK') const prop = require('crocks/Maybe/prop') // getValue :: a - Maybe b const getValue = prop('value') // getHead :: a - Maybe b const getHead = prop(0) // getFirstValue :: a - Maybe b const getFirstValue = composeK( getHead, getValue ) getValue({ some: false }) //= Nothing getValue(undefined) //= Nothing getValue({ value: 'correct' }) //= Just \"correct\" getFirstValue({ value: [] }) //= Nothing getFirstValue({ value: 84 }) //= Nothing getFirstValue(null) //= Nothing getFirstValue({ value: [ 'a', 'b' ] }) //= Just \"a\" propPath crocks/Maybe/propPath propPath :: Foldable f = f (String | Integer) - a - Maybe b While prop is good for simple, single-level structures, there may come a time when you have to work with nested POJOs or Arrays. When you run into this situation, just pull in propPath and pass it a left-to-right traversal path of keys, indices or a combination of both (gross...but possible). This will kick you back a function that behaves just like prop. You pass it some data, and it will attempt to resolve your provided path. If the path is valid, it will return the value residing there (null and NaN included!) in a Just. But if at any point that path \"breaks\" it will give you back a Nothing. const composeK = require('crocks/helpers/composeK') const isString = require('crocks/predicates/isString') const propPath = require('crocks/Maybe/propPath') const safe = require('crocks/Maybe/safe') // getFirstValue :: a - Maybe b const getFirstValue = propPath([ 'value', 0 ]) // getStringFirst :: a - Maybe String const getStringFirst = composeK( safe(isString), getFirstValue ) getFirstValue({ value: [] }) //= Nothing getFirstValue({ value: 84 }) //= Nothing getFirstValue(undefined) //= Nothing getFirstValue({ value: [ 'a', 'b' ] }) //= Just \"a\" getStringFirst(false) //= Nothing getStringFirst({ towel: true }) //= Nothing getStringFirst({ value: [ 0, 54 ] }) //= Nothing getStringFirst({ value: [ 'nice', 'jobb' ] }) //= Just \"nice\" safe crocks/Maybe/safe safe :: ((b - Boolean) | Pred) - b - Maybe a When using a Maybe, it is a common practice to lift into a Just or a Nothing depending on a condition on the value to be lifted. It is so common that it warrants a function, and that function is called safe. Provide a predicate (a function that returns a Boolean) and a value to be lifted. The value will be evaluated against the predicate, and will lift it into a Just if true and a Nothing if false. const Pred = require('crocks/Pred') const isArray = require('crocks/predicates/isArray') const safe = require('crocks/Maybe/safe') // length :: Array - Number const length = x = x.length // lte2 :: Number - Boolean const lte2 = x = x Nothing safe(lte2, 1) //= Just 1 safe(isArray, {}) //= Nothing safe(isArray, [ 1, 2, 3 ]) //= Just [ 1, 2, 3 ] safe(isSmall, [ 1, 2, 3 ]) //= Nothing safe(isSmall, { ar: [ 1, 2, 3 ] }) //= Nothing safe(isSmall, null) //= Nothing safe(isSmall, [ 1, 2 ]) //= Just [ 1, 2 ] safeLift crocks/Maybe/safeLift safeLift :: ((c - Boolean) | Pred) - (a - b) - c - Maybe b While safe is used to lift a value into a Maybe, you can reach for safeLift when you want to run a function in the safety of the Maybe context. Just like safe, you pass it either a Pred or a predicate function to determine if you get a Just or a Nothing, but then instead of a value, you pass it a unary function. safeLift will then give you back a new function that will first lift its argument into a Maybe and then maps your original function over the result. const Pred = require('crocks/Pred') const isNumber = require('crocks/predicates/isNumber') const safeLift = require('crocks/Maybe/safeLift') // doubleOf :: Number - Number const doubleOf = x = x * 2 // halfOf :: Number - Number const halfOf = x = x / 2 // gt100 :: Number - Boolean const gt100 = x = x 100 // safeDouble :: a - Maybe Number const safeDouble = safeLift(isNumber, doubleOf) // isLargeNumber :: Pred a const isLargeNumber = Pred(isNumber) .concat(Pred(gt100)) // halfLarge :: a - Maybe Number const halfLarge = safeLift(isLargeNumber, halfOf) safeDouble(null) // Nothing safeDouble('33') // Nothing safeDouble(33) // Just 66 halfLarge('1000') // Nothing halfLarge(100) // Nothing halfLarge(false) // Nothing halfLarge(786) // Just 383 halfLarge(100) // Nothing halfLarge(false) // Nothing Transformation Functions eitherToMaybe crocks/Maybe/eitherToMaybe eitherToMaybe :: Either b a - Maybe a eitherToMaybe :: (a - Either c b) - a - Maybe b Used to transform a given Either instance to a Maybe instance, eitherToMaybe will turn a Right instance into a Just wrapping the original value contained in the Right. All Left instances will map to a Nothing, mapping the originally contained value to a Unit. Values on the Left will be lost and as such this transformation is considered lossy in that regard. Like all crocks transformation functions, eitherToMaybe has (2) possible signatures and will behave differently when passed either an Either instance or a function that returns an instance of Either. When passed the instance, a transformed Maybe is returned. When passed an Either returning function, a function will be returned that takes a given value and returns a Maybe. const { Nothing, Just } = require('crocks/Maybe') const { Left, Right } = require('crocks/Either') const eitherToMaybe = require('crocks/Maybe/eitherToMaybe') const constant = require('crocks/combinators/constant') const ifElse = require('crocks/logic/ifElse') const isNumber = require('crocks/predicates/isNumber') // someNumber :: a - Either String Number const someNumber = ifElse( isNumber, Right, constant(Left('Nope')) ) eitherToMaybe(Left(56)) //= Nothing eitherToMaybe(Right('correct')) //= Just \"correct\" Just('ten') .chain(eitherToMaybe(someNumber)) //= Nothing Nothing() .chain(eitherToMaybe(someNumber)) //= Nothing Just(99) .chain(eitherToMaybe(someNumber)) //= Just 99 firstToMaybe crocks/Maybe/firstToMaybe firstToMaybe :: First a - Maybe a firstToMaybe :: (a - First b) - a - Maybe b Used to transform a given First instance to a Maybe instance, firstToMaybe will turn a non-empty instance into a Just wrapping the original value contained within the First. All empty instances will map to a Nothing. Like all crocks transformation functions, firstToMaybe has (2) possible signatures and will behave differently when passed either a First instance or a function that returns an instance of First. When passed the instance, a transformed Maybe is returned. When passed a First returning function, a function will be returned that takes a given value and returns a Maybe. const { Nothing, Just } = require('crocks/Maybe') const First = require('crocks/First') const firstToMaybe = require('crocks/Maybe/firstToMaybe') const mconcat = require('crocks/helpers/mconcat') // firstValue :: [ a ] - First a const firstValue = mconcat(First) firstToMaybe(First.empty()) //= Nothing firstToMaybe(First('winner')) //= Just \"Winner\" Nothing() .chain(firstToMaybe(firstValue)) //= Nothing Just([]) .chain(firstToMaybe(firstValue)) //= Nothing Just([ 'first', 'second', 'third' ]) .chain(firstToMaybe(firstValue)) //= Just \"first\" lastToMaybe crocks/Maybe/lastToMaybe lastToMaybe :: Last a - Maybe a lastToMaybe :: (a - Last b) - a - Maybe b Used to transform a given Last instance to a Maybe instance, lastToMaybe will turn a non-empty instance into a Just wrapping the original value contained within the Last. All empty instances will map to a Nothing. Like all crocks transformation functions, lastToMaybe has (2) possible signatures and will behave differently when passed either a Last instance or a function that returns an instance of Last. When passed the instance, a transformed Maybe is returned. When passed a Last returning function, a function will be returned that takes a given value and returns a Maybe. const { Nothing, Just } = require('crocks/Maybe') const Last = require('crocks/Last') const lastToMaybe = require('crocks/Maybe/lastToMaybe') const mconcat = require('crocks/helpers/mconcat') // lastValue :: [ a ] - Last a const lastValue = mconcat(Last) lastToMaybe(Last.empty()) //= Nothing lastToMaybe(Last('the end')) //= Just \"the end\" Nothing() .chain(lastToMaybe(lastValue)) //= Nothing Just([]) .chain(lastToMaybe(lastValue)) //= Nothing Just([ 'first', 'second', 'third' ]) .chain(lastToMaybe(lastValue)) //= Just \"third\" resultToMaybe crocks/Maybe/resultToMaybe resultToMaybe :: Result e a - Maybe a resultToMaybe :: (a - Result e b) - a - Maybe b Used to transform a given Result instance to a Maybe instance, resultToMaybe will turn an Ok instance into a Just wrapping the original value contained in the Ok. All Err instances will map to a Nothing, mapping the originally contained value to a Unit. Values on the Err will be lost and as such this transformation is considered lossy in that regard. Like all crocks transformation functions, resultToMaybe has (2) possible signatures and will behave differently when passed either an Result instance or a function that returns an instance of Result. When passed the instance, a transformed Maybe is returned. When passed a Result returning function, a function will be returned that takes a given value and returns a Maybe. const { Nothing, Just } = require('crocks/Maybe') const { Err, Ok } = require('crocks/Result') const resultToMaybe = require('crocks/Maybe/resultToMaybe') const identity = require('crocks/combinators/identity') const tryCatch = require('crocks/Result/tryCatch') function datErrTho() { throw new Error('something amiss') } resultToMaybe(Err('this is bad')) //= Nothing resultToMaybe(Ok('this is great')) //= Just \"this is great\" Nothing() .chain(resultToMaybe(identity)) //= Nothing Just('so good') .chain(resultToMaybe(tryCatch(datErrTho))) //= Nothing Just('so good') .chain(resultToMaybe(Ok)) //= Just \"so good\" ","srcFilePath":"src/pages/docs/crocks/Maybe.md","id":"Maybe","location":"/docs/crocks/Maybe.html","url":"/crocks/docs/crocks/Maybe.html"},"Pred":{"title":"Pred","description":"Pred Crock","layout":"guide","weight":100,"content":" Pred a Boolean Defined as a Monoidal Contravariant datatype, Pred wraps a predicate function of the form (a - Boolean). The far right parameter of Pred is always fixed to the type of Boolean, so the result of the wrapped predicate function can never be mapped. While the right parameter is fixed, the input to the predicate can vary. Another property of Pred instances is that they can be combined using their Monodial interface. Combining instances will result in a new instance that returns the result of each Pred under logical conjunction. As Pred wraps a function, it is lazy and will not execute until its argument is satisfied. A given instance is run but calling the runWith method, supplying it the argument to test. One of the features of crocks is the ability to use both normal predicate functions and Pred instances interchangeably. For any crocks function that takes a predicate, either a predicate function or a Pred instance can be used. This implementation of Pred was heavily inspired by this article. const Pred = require('crocks/Pred') const isNumber = require('crocks/predicates/isNumber') const propOr = require('crocks/helpers/propOr') const filter = require('crocks/pointfree/filter') // largeNumber :: Pred Number const largeNumber = Pred(isNumber) .concat(Pred(x = x 100)) // largeItem :: Pred Object const largeItem = largeNumber .contramap(propOr(null, 'item')) largeNumber .runWith(45) //= false largeNumber .runWith(175) //= true largeItem .runWith({ item: 190 }) //= true largeItem .runWith({ item: 9 }) //= false largeItem .runWith(9) //= false filter(largeNumber, [ 200, 375, 15 ]) //= [ 200, 375 ] Implements Semigroup, Monoid, Contravariant Constructor Methods empty Pred.empty :: () - Pred a empty provides the identity for the Monoid in that when the value it provides is concated to any other value, it will return the other value. In the case of Pred the result of empty is a Pred that will always return true. empty is available on both the Constructor and the Instance for convenience. const Pred = require('crocks/Pred') const isEmpty = require('crocks/predicates/isEmpty') const not = require('crocks/logic/not') // empty :: Pred a const empty = Pred.empty() // notEmpty :: Pred a const notEmpty = Pred(not(isEmpty)) empty .runWith('') //= true notEmpty .concat(empty) .runWith([]) //= false notEmpty .concat(empty) .runWith([ 1, 2, 3 ]) //= true empty .concat(notEmpty) .runWith('') //= false empty .concat(notEmpty) .runWith('123') //= true Instance Methods concat Pred a ~ Pred a - Pred a concat is used to combine (2) Semigroups of the same type under an operation specified by the Semigroup. In the case of Pred, the results of both Predss are combined under logical conjunction. const Pred = require('crocks/Pred') const or = require('crocks/logic/or') const not = require('crocks/logic/not') const filter = require('crocks/pointfree/filter') const isEven = x = !(x % 2) // isOdd :: Pred Number const isOdd = Pred(not(isEven)) // lt20 :: Pred Number const lt20 = Pred(x = x < 20) // gt5 :: Pred Number const gt5 = Pred(x = x 5) // inRange :: Pred Number const inRange = lt20.concat(gt5) // isOddInRange :: Pred Number const isOddInRange = isOdd.concat(inRange) // isValid :: Pred Number const isValid = Pred(or(isEven, isOddInRange)) // data :: [ Number ] const data = [ 1, 4, 12, 19, 32, 99, 76, 7 ] isOdd .runWith(5) //= true isOdd .runWith(8) //= false filter(isOdd, data) //= [ 1, 19, 99, 7 ] filter(lt20, data) //= [ 1, 4, 12, 19, 7 ] filter(gt5, data) //= [ 12, 19, 32, 99, 76, 7 ] filter(inRange, data) //= [ 12, 19, 7 ] filter(isOddInRange, data) //= [ 19, 7 ] filter(isEven, data) // [ 4, 12, 32, 76 ] filter(isValid, data) //= [ 4, 12, 19, 32, 76, 7 ] contramap Pred a ~ (b - a) - Pred b While the output of a Pred is fixed to Boolean, the input can vary type and value. This allows a given Pred to be adapted by mapping on the input, before it hits the wrapped predicate function. Using contramap, functions are lifted, mapping the input to now accept the type of the input of the given function. const Pred = require('crocks/Pred') const contramap = require('crocks/pointfree/contramap') const propOr = require('crocks/helpers/propOr') // Length :: String | Function | Array // length :: Length - Number const length = propOr(0, 'length') // gt5 :: Pred Number const gt5 = Pred(x = x 5) // lengthGt5 :: Pred Length const validLength = contramap(length, gt5) // validItemLength :: Pred Object const validItemLength = contramap(propOr(null, 'item'), validLength) gt5 .runWith(5) //= false gt5 .runWith(10) //= true validLength .runWith([ 1, 2, 3, 4, 5, 6 ]) //= true validLength .runWith(null) //= false validLength .runWith('1234') //= false validItemLength .runWith({ item: 'this is an item' }) //= true valueOf Pred a ~ () - a - Boolean valueOf is used on all crocks Monoids as a means of extraction. While the extraction is available, types that implement valueOf are not necessarily a Comonad. This function is used primarily for convenience for some of the helper functions that ship with crocks. Calling valueOf on a Pred instance will result in the underlying predicate function. Most of the time this will not be required when working with crocks because all crocks functions that take a predicate function can also take a Pred instance. const Pred = require('crocks/Pred') const isArray = require('crocks/predicates/isArray') const isString = require('crocks/predicates/isString') const equals = require('crocks/pointfree/equals') const or = require('crocks/logic/or') // lengthIsThree :: Pred a const lengthIsThree = Pred(equals(3)) .contramap(x = x.length) // pred :: Pred a const pred = Pred(or(isArray, isString)) .concat(lengthIsThree) // fn :: a - Boolean const fn = pred.valueOf() pred .runWith(null) //= false pred .runWith([ 1, 2, 3 ]) //= true pred .runWith('This is fun') //= true fn(null) // false fn([ 1, 2, 3 ]) // true fn('This is fun') // true fn([]) // false fn('') // false runWith Pred a ~ a - Boolean As Pred wraps a predicate function, it needs a mean to run it with some value to test against the predicate. Pred instances provide a method called runWith that will accept the value to be tested and then runs it through the predicate returning the result. Most of the time this function is not used while working with other predicate functions in crocks, as all functions that take a predicate function also take a Pred instance. It does come in handy though when supplying predicates to other libraries. const Pred = require('crocks/Pred') const hasProp = require('crocks/predicates/hasProp') const equals = require('crocks/pointfree/equals') const flip = require('crocks/combinators/flip') const runWith = require('crocks/pointfree/runWith') // trueBlue :: Pred Object const trueBlue = Pred(equals(true)) .contramap(({ blue }) = blue) // isValid :: Pred a const isValid = Pred(hasProp('blue')) .concat(trueBlue) // checkValid :: a - Boolean const checkValid = flip(runWith, isValid) checkValid(null) //= false checkValid([ 1, 2, 3 ]) //= false checkValid({ blue: 32 }) //= false checkValid({ blue: true }) //= true ","srcFilePath":"src/pages/docs/crocks/Pred.md","id":"Pred","location":"/docs/crocks/Pred.html","url":"/crocks/docs/crocks/Pred.html"},"Reader":{"title":"Reader","description":"Reader Crock","layout":"guide","weight":110,"content":" Reader e a Reader is a lazy Product Type that enables the composition of computations that depend on a shared environment (e - a). The left portion, the e must be fixed to a type for all related computations. The right portion a can vary in its type. As Reader is lazy, wrapping a function of the form (e - a), nothing is executed until it is run with an environment. Reader provides a method on it's instance that will take an environment called runWith that will run the instance with a given environment. Not only is Reader's environment fixed to a type, but it should be immutable for the \"life\" computation. If a referential type is used as the environment great care should be taken to not modify the value of the environment. const Reader = require('crocks/Reader') const { ask } = Reader const concat = require('crocks/pointfree/concat') // greet :: String - Reader String String const greet = greeting = Reader(name = ${greeting}, ${name}) // addFarewell :: String - Reader String String const addFarewell = farewell = str = ask(env = ${str}${farewell} ${env}) // flow :: Reader String String const flow = greet('Hola') .map(concat('...')) .chain(addFarewell('See Ya')) flow .runWith('Thomas') // = Hola, Thomas...See Ya Thomas flow .runWith('Jenny') // = Hola, Jenny...See Ya Jenny Implements Functor, Apply, Chain, Applicative, Monad Constructor Methods ask Reader.ask :: () - Reader e e Reader.ask :: (e - b) - Reader e b A construction helper that returns a Reader with the environment on the right portion of the Reader. ask can take a function, that can be used to map the environment to a different type or value. const Reader = require('crocks/Reader') const { ask } = Reader // add :: Number - Number - Number const add = x = y = x + y // Typical constructor Reader(add(10)) .runWith(56) //= 66 // Using ask with no function // (identity on environment) ask() .runWith(56) //= 56 // Using ask with a function // (map environment before deposit) ask(add(10)) .runWith(56) //= 66 of Reader.of :: a - Reader e a of is used to construct a Reader with the right portion populated with it's argument. of essentially will lift a value of type a into a Reader, giving back a Reader that is \"pointed\" to the specific value provided. of makes for a wonderful starting point for some of the more complicated flows. const Reader = require('crocks/Reader') const { ask } = Reader const objOf = require('crocks/helpers/objOf') const thrush = require('crocks/combinators/applyTo') // add :: Number - Number - Number const add = x = y = x + y Reader.of(34) .map(add(6)) .runWith() //= 40 Reader.of('Bobby') .map(objOf('name')) .runWith() //= { name: 'Bobby' } Reader.of(57) .chain(x = ask(add).map(thrush(x))) .runWith(43) //= 100 Instance Methods map Reader e a ~ (a - b) - Reader e b While the left side, or the environment, of the Reader must always be fixed to the same type, the right side, or value, of the Reader may vary. Using map allows a function to be lifted into the Reader, mapping the result into the result of the lifted function. const Reader = require('crocks/Reader') const { ask } = Reader const assign = require('crocks/helpers/assign') const B = require('crocks/combinators/composeB') const objOf = require('crocks/helpers/objOf') const option = require('crocks/pointfree/option') const prop = require('crocks/Maybe/prop') // length :: Array - Number const length = x = x.length ask() .map(length) .runWith([ 1, 2, 3 ]) //= 3 // propOr :: (String, a) - b - a const propOr = (key, def) = B(option(def), prop(key)) // lengthObj :: Array - Object const lengthObj = B(objOf('length'), length) // addLength :: Object - Redaer Array Object const addLength = x = ask(propOr('list', [])) .map(B(assign(x), lengthObj)) Reader.of({ num: 27 }) .chain(addLength) .runWith({ list: [ 1, 2, 3 ] }) //= { length: 3, num: 27 } ap Reader e (a - b) ~ Reader e a - Reader e b ap allows for values wrapped in a Reader to be applied to functions also wrapped in a Reader. In order to use ap, the Reader must contain a function as its value. Under the hood, ap unwraps both the function and the value to be applied and applies the value to the function. Finally it will wrap the result of that application back into a Reader. It is required that the inner function is curried. const Reader = require('crocks/Reader') const { ask } = Reader const B = require('crocks/combinators/composeB') const assign = require('crocks/helpers/assign') const liftA2 = require('crocks/helpers/liftA2') const objOf = require('crocks/helpers/objOf') // namePart :: Number - String - String const namePart = indx = x = x.split(' ')[indx] || '' // combine :: Object - Reader Object const combine = x = ask(assign(x)) // full :: Reader Object const full = ask(({ full }) = full) // first :: Reader Object const first = full .map(B(objOf('first'), namePart(0))) // last :: Reader Object const last = full .map(B(objOf('last'), namePart(1))) // fluent style Reader.of(assign) .ap(first) .ap(last) .chain(combine) .runWith({ full: 'Mary Jones' }) //= { full: 'Mary Jones', first: 'Mary', last: 'Jones' } // liftAssign :: Reader Object - Reader Object - Reader Object const liftAssign = liftA2(assign) // using a lift function liftAssign(first, last) .chain(combine) .runWith({ full: 'Tom Jennings' }) //= { full: 'Tom Jennings', first: 'Tom', last: 'Jennings' } chain Reader e a ~ (a - Reader e b) - Reader e b One of the ways Monads like Reader are able to be combined and have their effects applied, is by using the chain method. In the case of Reader, the effect is to read in and make available the shared environment. chain expects a function that will take any a and return a new Reader with a value of b. const Reader = require('crocks/Reader') const { ask } = Reader const B = require('crocks/combinators/composeB') const option = require('crocks/pointfree/option') const prop = require('crocks/Maybe/prop') // multiply :: Number - Number - Number const multiply = x = y = x * y // add :: Number - Number - Number const add = x = y = x + y // propOr :: (String, a) - b - a const propOr = (key, def) = B(option(def), prop(key)) // applyScale :: Number - Reader Object Number const applyScale = x = ask(propOr('scale', 1)) .map(multiply(x)) // applyScale :: Number - Reader Object Number const applyOffset = x = ask(propOr('offset', 0)) .map(add(x)) // applyTransforms :: Number - Reader Object Number const applyTransform = x = Reader.of(x) .chain(applyOffset) .chain(applyScale) applyTransform(45) .runWith({}) //= 45 applyTransform(45) .runWith({ offset: 20 }) //= 65 applyTransform(45) .runWith({ scale: 2 }) //= 90 applyTransform(45) .runWith({ scale: 2, offset: 20 }) //= 130 runWith Reader e a ~ e - a As Reader is a lazy datatype that requires a shared environment to run, it's instance provides a runWith method that takes in an environment and returns the result of the computation. const { ask } = require('crocks/Reader') const Pair = require('crocks/Pair') const fst = require('crocks/Pair/fst') const liftA2 = require('crocks/helpers/liftA2') const snd = require('crocks/Pair/snd') // data :: Pair Number Number const data = Pair(20, 45) // getCorrect :: Reader (Pair Number Number) Number const getCorrect = ask(fst) // getTotal :: Reader (Pair Number Number) Number const getTotal = ask(snd) // divide :: Number - Number - Number const divide = x = y = x / y // formatPercent :: Number - String const formatPercent = x = ${Math.floor(x * 1000) / 10}% // calcPercent :: Reader (Pair Number Number) String const calcPercent = liftA2(divide, getCorrect, getTotal) .map(formatPercent) calcPercent .runWith(data) //=. '44.4%' ","srcFilePath":"src/pages/docs/crocks/Reader.md","id":"Reader","location":"/docs/crocks/Reader.html","url":"/crocks/docs/crocks/Reader.html"},"ReaderT":{"title":"ReaderT","description":"Reader Monad Transformer Crock","layout":"guide","weight":120,"content":" Monad m = ReaderT e (m a) ReaderT is a Monad Transformer that wraps a given Monad with a Reader. This allows the interface of a Reader that enables the composition of computations that depend on a shared environment (e - a), but provides a way to abstract a means the Reader portion, when combining ReaderTs of the same type. All ReaderTs must provide the constructor of the target Monad that is being wrapped. Implements Functor, Apply, Chain, Applicative, Monad Constructor Methods ask ReaderT.ask :: Monad m = () - ReaderT e (m e) ReaderT.ask :: Monad m = (e - a) - ReaderT e (m a) A construction helper that returns a ReaderT with environment on the right portion of the Reader. ask can take a function, that can be used to map the environment to a different type or value. When using the function version, the function must return the type of the Monad the ReaderT wraps, which in turn will be wrapped in another const ReaderT = require('crocks/Reader/ReaderT') const Maybe = require('crocks/Maybe') const safe = require('crocks/Maybe/safe') const isNumber = require('crocks/predicates/isNumber') const MaybeReader = ReaderT(Maybe) const { ask } = MaybeReader // add :: Number - Number - Number const add = x = y = x + y // Typical Constructor MaybeReader(safe(isNumber)) .runWith(76) //= Just 76 MaybeReader(safe(isNumber)) .runWith('76') //= Nothing // Using ask with no function // (identity on environment) ask() .runWith(76) //= Just 76 ask() .runWith('76') //= Just '76' // Using ask with a function // (map environment before deposit) ask(add(10)) .runWith(76) //= Just 86 lift ReaderT.lift :: Monad m = m a - ReaderT e (m a) Used to promote an instance of a given Monad into a ReaderT of that Monads type. This can be used to lift a pointed instance of the underlying Monad. When mixed with composition, lift can be used to promote functions that take the form of a - m b into a function that can be chained with the ReaderT. Although, liftFn can be used to remove the composition boilerplate and promote and a - m b function. const ReaderT = require('crocks/Reader/ReaderT') const Async = require('crocks/Async') const compose = require('crocks/helpers/compose') const curry = require('crocks/helpers/curry') const flip = require('crocks/combinators/flip') const runWith = require('crocks/pointfree/runWith') const tap = require('crocks/helpers/tap') const AsyncReader = ReaderT(Async) const { ask, lift } = AsyncReader const { Rejected } = Async // log :: String - a - () const log = label = console.log.bind(console, label + ':') // forkLog :: Async a b - Async a b const forkLog = tap( m = m.fork(log('rej'), log('res')) ) // runAndLog :: e - ReaderT e (Async a b) - Async a b const runAndLog = curry( x = compose(forkLog, flip(runWith, x)) ) // instance :: ReaderT e (Async String a) const instance = lift(Rejected('Always Rejected')) runAndLog(instance, 'Thomas') //= rej: Always Rejected // Using in a composition // rejectWith :: a - ReaderT e (Async a b) const rejectWith = compose(lift, Rejected) // envReject :: ReadetT e (Async e b) const envReject = ask() .chain(rejectWith) runAndLog(envReject, 'Sammy') //= rej: Sammy liftFn ReaderT.liftFn :: Monad m = (a - m b) - a - ReaderT e (m b) Used to transform a given function in the form of a - m b into a lifted function, where m is the underlying Monad of a ReaderT. This allows for the removal of composition boilerplate that results from using the lift helper. const ReaderT = require('crocks/Reader/ReaderT') const Either = require('crocks/Either') const ifElse = require('crocks/logic/ifElse') const EitherReader = ReaderT(Either) const { ask, liftFn } = EitherReader const { Left, Right } = Either // gte :: Number - Number - Either String Number const gte = x = ifElse( n = n = x, Right, n = Left(${n} is not gte to ${x}) ) // gte10 :: Number - Either String Number const gte10 = gte(10) // add20 :: ReaderT Number (Either String Number) const add20 = ask() .chain(liftFn(gte10)) .map(n = n + 20) add20 .runWith(30) //= Right 50 add20 .runWith(9) //= Left \"9 is not gte to 10\" of ReaderT.of :: Monad m = a - ReaderT e (m a) Lifts a value into a ReaderT using the of method of the underlying Monad. of will disregard the environment and points the right portion to the provided value. const ReaderT = require('../crocks/src/Reader/ReaderT') const Maybe = require('crocks/Maybe') const Either = require('crocks/Either') const State = require('crocks/State') const MaybeReader = ReaderT(Maybe) const EitherReader = ReaderT(Either) const StateReader = ReaderT(State) MaybeReader.of('yep') .map(x = x.toUpperCase()) .runWith(23) //= Just \"YEP\" EitherReader.of(43) .runWith(23) //= Right 43 StateReader.of(0) .runWith(23) .runWith(42) //= Pair(0, 42) Instance Methods map Monad m = ReaderT e (m a) ~ (a - b) - ReaderT e (m b) Provides a means for lifting a normal javascript function into the underlying Monad, allowing the innermost value of the underlying Monad to be mapped. This method will ignore the outer ReaderT, and be applied directly to the underlying Monad. const ReaderT = require('crocks/Reader/ReaderT') const Maybe = require('crocks/Maybe') const isString = require('crocks/predicates/isString') const safe = require('crocks/Maybe/safe') const MaybeReader = ReaderT(Maybe) const { ask, liftFn } = MaybeReader // maybeString :: a - Maybe String const maybeString = safe(isString) // toUpper :: String - String const toUpper = x = x.toUpperCase() // envToUpper :: ReaderT e (Maybe String) const envToUpper = ask() .chain(liftFn(maybeString)) .map(toUpper) envToUpper .runWith(4) //= Nothing envToUpper .runWith('hola') //= Just \"HOLA\" ap Monad m = ReaderT e (m (a - b)) ~ ReaderT e (m a) - ReaderT e (m b) Applies wrapped functions to the provided value, using the ap of the underlying Monad. A ReaderT of the underlying Monad must be provided, which allows access to the environment. const Pair = require('crocks/Pair') const ReaderT = require('crocks/Reader/ReaderT') const Result = require('crocks/Result') const fst = require('crocks/Pair/fst') const snd = require('crocks/Pair/snd') const ifElse = require('crocks/logic/ifElse') const isNumber = require('crocks/predicates/isNumber') const liftA2 = require('crocks/helpers/liftA2') const { Err, Ok } = Result const ResultReader = ReaderT(Result) const { ask, liftFn } = ResultReader // add :: Number - Number - Number const add = x = y = x + y // makeError :: a - Result [ String ] b const makeErr = x = Err([ ${x} is not a Number ]) // isValid :: a - ReaderT e (Result [ String ] Number) const isValid = liftFn( ifElse(isNumber, Ok, makeErr) ) // first :: ReaderT (Pair a b) (Result [ String ] Number) const first = ask(fst) .chain(isValid) // second :: ReaderT (Pair a b) (Result [ String ] Number) const second = ask(snd) .chain(isValid) // Using a fluent style with of ResultReader.of(add) .ap(first) .ap(second) .runWith(Pair(34, 21)) //= Ok 55 // Using a fluent style with map first .map(add) .ap(second) .runWith(Pair(true, 21)) //= Err [ \"true is not a Number\" ] // Using liftA2 liftA2(add, first, second) .runWith(Pair('Bob', 'Jones')) //= Err [ 'Bob is not a Number', 'Jones is not a Number' ] chain Monad m = ReaderT e (m a) ~ Reader e (a - ReaderT e (m b)) - ReaderT e (m b) Can be used to apply the effects of the underlying Monad with the benefit of being able to read from the environment. This method only accepts functions of the form Monad m = a - ReaderT e (m b). const ReaderT = require('../crocks/src/Reader/ReaderT') const Maybe = require('crocks/Maybe') const prop = require('crocks/Maybe/prop') const MaybeReader = ReaderT(Maybe) const { ask, liftFn } = MaybeReader // readProp :: String - b - ReaderT e (Maybe a) const readProp = key = liftFn(prop(key)) // getName :: ReaderT e (Maybe a) const getName = ask() .chain(readProp('name')) // getFirstName :: ReaderT e (Maybe a) const getFirstName = getName .chain(readProp('first')) // getLastName :: ReaderT e (Maybe a) const getLastName = getName .chain(readProp('last')) // person :: Object const person = { name: { first: 'Hazel', middle: 'Anne' } } getFirstName .runWith(person) //= Just \"Hazel\" getLastName .runWith(person) //= Nothing getLastName .runWith(10) //= Nothing runWith Monad m = ReaderT e (m a) ~ e - m a In order to unwrap the underlying Monad, ReaderT needs to be ran with a given environment. A ReaderT instance comes equipped with a runWith method that accepts an environment and returns the resulting Monad. const ReaderT = require('../crocks/src/Reader/ReaderT') const Maybe = require('crocks/Maybe') const MaybeReader = ReaderT(Maybe) const { ask, liftFn } = MaybeReader const prop = require('crocks/Maybe/prop') // data :: Object const data = { animals: [ 'tiger', 'muskrat', 'mouse' ] } // length :: Array - Number const length = x = x.length // getProp :: String - ReaderT Object (Maybe []) const getProp = key = ask() .chain(liftFn(prop(key))) getProp('animals') .map(length) .runWith(data) //= Just 3 ","srcFilePath":"src/pages/docs/crocks/ReaderT.md","id":"ReaderT","location":"/docs/crocks/ReaderT.html","url":"/crocks/docs/crocks/ReaderT.html"},"State":{"title":"State","description":"State Crock","layout":"guide","weight":140,"content":" State s a State is an Algebraic Data Type that abstracts away the associated state management that comes with stateful computations.State is parameterized by two types, a state s and a resultant a. The resultant portion may vary it's type, but the state portion must be fixed to a type that is used by all related stateful computations. All State instances wrap a function of the form s - Pair a s and can be constructed by providing a function of this form. In order to get maximum reuse of existing functions, a few construction helpers are available on the State constructor. State is lazy and is required to be run at the edge with some initial state. Three methods are available on the instance for running the State with a given initial state. runWith will return a Pair a s with the state s on the right and the resultant a on the left. The other two are used for extracting either the state or resultant, unwrapping the values from the Pair and discarding the unwanted portion. evalWith used when the resultant is wanted, while execWith is used to pull the state. const State = require('crocks/State') const { get, put } = State const Pair = require('crocks/Pair') const constant = require('crocks/combinators/constant') // toUpper :: String - String const toUpper = x = x.toUpperCase() // putResultant :: String - State String String const putResultant = x = put(x) .map(constant(x)) // standard construction // State String String State(s = Pair(toUpper(s), s)) .runWith('nice') //= Pair('NICE', 'nice') // construction helper // State String String get(toUpper) .runWith('nice') //= Pair('NICE', 'nice') // combine states get(toUpper) .chain(putResultant) .runWith('nice') //= Pair('NICE', 'NICE') // pull resultant only get(toUpper) .evalWith('nice') //= 'NICE' // pull state only get(toUpper) .execWith('nice') //= 'nice' Implements Functor, Apply, Chain, Applicative, Monad Constructor Methods get State.get :: () - State s s State.get :: (s - a) - State s a A construction helper that is used to access the state portion of a given State instance. To make the state accessible, get will place the state in the resultant portion, overwriting what was there previously. get may be called with or without a function as it's argument. When nothing is provided for the argument, the state will be applied to the resultant as is. The state will be mapped over any provided function that takes the same type as the state, with the result deposited in the resultant. const { get } = require('crocks/State') const chain = require('crocks/pointfree/chain') const compose = require('crocks/helpers/compose') const isNumber = require('crocks/predicates/isNumber') const option = require('crocks/pointfree/option') const prop = require('crocks/Maybe/prop') const safe = require('crocks/Maybe/safe') // propOr :: (String, (b - Boolean), a) - Object - c const propOr = (key, pred, def) = compose(option(def), chain(safe(pred)), prop(key)) // safeNumber :: Object - Number const safeNumber = propOr('number', isNumber, 0) get(safeNumber) .runWith({ number: 23 }) //= Pair(23, { number: 23 }) get(safeNumber) .evalWith({ number: '23' }) //= 0 get() .map(safeNumber) .evalWith({ number: 23 }) //= 23 get() .map(safeNumber) .runWith({ string: '47' }) //= Pair(0, { string: '47'}) modify State.modify :: (s - s) - State s () A construction helper that can be used to lift an endo-function that matches the fixed type of the state portion. The lifted function will receive the state and returns a new State instance with the result of the function in the state portion. Great care should be taken to not use functions that will change the type of the state as it may not be expected in other stateful computations and can result in hard to track down bugs. const { modify } = require('crocks/State') const mapProps = require('crocks/helpers/mapProps') // add :: Number - Number - Number const add = x = y = x + y // addState :: Number - State Number () const addState = x = modify(add(x)) // addValue :: Number - State Object () const addValue = x = modify(mapProps({ value: add(x) })) addState(5) .execWith(45) //= 50 addValue(5) .execWith({ value: 45 }) //= { value: 50 } addValue(5) .execWith({}) //= {} put State.put :: s - State s () Used to replace the state portion of a given State instance,, put can be employed anytime that the state can change without having to know about it's previous value. If the previous value is required for a given stateful computation, modify can be used to lift a function that represents the change. As put updates the state, it is important to ensure that the state portion stays fixed for all related functions. Changing the type of the state portion may result in hard to debug bugs and destroys the relationship between stateful computations. const { put } = require('crocks/State') const compose = require('crocks/helpers/compose') const isString = require('crocks/predicates/isString') const option = require('crocks/pointfree/option') const safe = require('crocks/Maybe/safe') // safeString :: a - String const safeString = compose(option(''), safe(isString)) // reset :: () - State String () const reset = () = put('') // update :: a - State String () const update = compose(put, safeString) // heckYeah :: State String () const heckYeah = update('Oh Heck Yeah') heckYeah .execWith('Gosh') //= 'Oh Heck Yeah' heckYeah .chain(reset) .runWith('Gosh') // Pair((), '') of State.of :: a - State s a Used to \"blindly\" lift any Javascript value into a State, of will take the provided value and return back a new State instance with the value in the resultant. There are many uses for of, but mostly it is used to set the resultant in the same way put is used to replace the state. Many times of is used at the start of a given stateful computation or in conjunction with put and modify to replace the Unit the resultant is set to for those construction helpers. const State = require('crocks/State') const { get, put } = State // updatePop :: String - State String String const updatePop = x = get().chain( old = put(x).chain( () = State.of(old) ) ) State.of('hotness') .chain(updatePop) .runWith('crusty') //= Pair('crusty', 'hotness') Instance Methods map State s a ~ (a - b) - State s b While the state portion s of State must remain fixed to a type, the resultant a can vary in it's type as needed. This allows complex stateful computations to be represented with State. The map method provides a means to lift a function into the datatype that will be applied to the resultant and return a new instance of State with the result of the function as the new resultant. While this is similar to the modify construction helper, which lifts an endo-function that acts upon the state, map does not require an endo-function as it can move to any type. Due to the composition law associated with map, successive maps can be composed together using function composition. This will give the same results but will only map the value once, instead of once for every mapping. const { get } = require('crocks/State') const compose = require('crocks/helpers/compose') const objOf = require('crocks/helpers/objOf') const propOr = require('crocks/helpers/propOr') // add :: Number - Number - Number const add = x = y = x + y // getNum :: State Object Number const getNum = get(propOr(0, 'num')) getNum .map(add(10)) .evalWith({ num: 32 }) //= 42 getNum .map(add(10)) .map(objOf('result')) .evalWith({ val: 32 }) //= { result: 10 } // comp :: Number - Object const comp = compose( objOf('result'), add(10) ) getNum .map(comp) .evalWith({ num: 32 }) //= { result: 42 } ap State s (a - b) ~ State s a - State s b Short for apply, the ap method is used to apply the resultant of a given State instance to a function wrapped in another instance. On a State instance that wraps a function, calling ap, providing it another State instance, will return a new State instance with the result of the function in the resultant portion. When used with curried, polyadic functions, multiple stateful computations can be combined using the lifted function as a means to combine each of the instances' resultants. const { get, modify } = require('crocks/State') const assoc = require('crocks/helpers/assoc') const propOr = require('crocks/helpers/propOr') const data = { tax: .084, sub: 34.97 } // add :: Number - Number - Number const add = x = y = x + y // multiply :: Number - Number - Number const multiply = x = y = x * y // round :: Number - Number const round = x = Math.round(x * 100) / 100 // getKey :: String - State Object Number const getKey = key = get(propOr(0, key)) // updateKey :: String - a - State Object () const updateKey = key = val = modify(assoc(key, val)) // addToSub :: Number - String Object Number const addToSub = x = getKey('sub') .map(add(x)) const calcTax = getKey('tax') .map(multiply) .ap(getKey('sub')) // applyTax :: State Object () const applyTax = calcTax .chain(addToSub) .map(round) .chain(updateKey('total')) applyTax .execWith(data) //= { tax: 0.084, sub: 34.07, total: 37.91 } chain State s a ~ (a - State s b) - State s b As a means to combine stateful computations, chain is used to sequence state transactions that either read from or write to the state. chain takes a unary function that must return a new State instance. chain returns a new State instance that will apply the computation when run. const { get, modify } = require('crocks/State') // add :: Number - State Number () const add = x = modify(y = x + y) // multiply :: Number - State Number () const multiply = x = modify(y = x * y) // double :: () - State Number () const double = () = get() .chain(add) // square :: () - State Number () const square = () = get() .chain(multiply) add(10) .execWith(10) //= 20 add(10) .chain(double) .execWith(10) //= 40 add(10) .chain(square) .execWith(10) //= 400 add(10) .chain(double) .chain(square) .execWith(10) //= 1600 runWith State s a ~ s - Pair a s State is a lazy datatype that requires a value for it's state portion to be run. A given State instance provides a runWith method that accepts a value to run the instance with. The value must be a member of the type that the given State instance is fixed to in it's state portion, s. When called, runWith will run the state transition with the given value as the initial state and will return the resulting Pair with the resultant in the fst (first) and the state in the snd (second). const State = require('crocks/State') const { get, put } = State const K = require('crocks/combinators/constant') // swap :: s - s - State s s const swap = x = old = put(x) .chain(K(State.of(old))) //update :: s - State s s const update = x = get() .chain(swap(x)) update(45) .runWith(100) //= Pair(100, 45) evalWith State s a ~ s - a State is a lazy datatype that requires a value for it's state portion to be run. A given State instance provides an evalWith method that accepts a value to run the instance with. The value must be a member of the type that the given State instance is fixed to in it's state portion, s. When called, evalWith will run the state transition with the given value as the initial state and will return the resulting resultant discarding the state portion. const State = require('crocks/State') const { get } = State const concat = require('crocks/pointfree/concat') const flip = require('crocks/combinators/flip') const liftA2 = require('crocks/helpers/liftA2') const map = require('crocks/pointfree/map') const propOr = require('crocks/helpers/propOr') const name = { first: 'Franklin', last: 'Jennings' } // getLast :: State Object String const getFirst = get(propOr('', 'first')) // getLast :: State Object String const getLast = get(propOr('', 'last')) // inner :: Functor f = f a - f [ a ] const inner = map(Array.of) // combineNames :: State Object [ String ] const combineNames = liftA2( flip(concat), inner(getFirst), inner(getLast) ) combineNames .evalWith(name) //= [ 'Franklin', 'Jennings' ] execWith State s a ~ s - s State is a lazy datatype that requires a value for it's state portion to be run. A given State instance provides an execWith method that accepts a value to run the instance with. The value must be a member of the type that the given State instance is fixed to in it's state portion, s. When called, execWith will run the state transition with the given value as the initial state and will return the resulting state, discarding the resultant portion. const { modify } = require('crocks/State') const compose = require('crocks/helpers/compose') const concat = require('crocks/pointfree/concat') // toUpper :: String - String const toUpper = x = x.toUpperCase() // exclaim :: String - String const exclaim = concat('!!!') // yell :: State String () const yell = modify( compose(exclaim, toUpper) ) yell .execWith('nice') //= 'NICE!!!' Pointfree Functions evalWith (pointfree) crocks/State/evalWith evalWith :: s - State s a - a The evalWith pointfree function can be employed to execute the evalWith method on a given State instance. This function is typically used at the edge of a program where all the side-effects typically reside. As all this function does is return the result of applying a given initial state to the evalWith method to the provided State instance, it will also return the resulting resultant, throwing away the resulting state. const { get } = require('crocks/State') const evalWith = require('crocks/State/evalWith') const compose = require('crocks/helpers/compose') const curry = require('crocks/helpers/curry') const flip = require('crocks/combinators/flip') // addToState :: Number - State Number Number const addToState = x = get(y = x + y) // add :: Number - Number - Number const add = curry( compose(flip(evalWith), addToState) ) // add10 :: Number - Number const add10 = add(10) add10(32) //= 42 add(1295, 42) // 1337 execWith (pointfree) crocks/State/execWith execWith :: s - State s a - s The execWith pointfree function can be employed to execute the execWith method on a given State instance. This function is typically used at the edge of a program where all the side-effects typically reside. As all this function does is return the result of applying a given initial state to the execWith method to the provided State instance, it will also return the resulting state, throwing away the resulting resultant. const State = require('crocks/State') const { modify } = State const execWith = require('crocks/State/execWith') const curry = require('crocks/helpers/curry') const isSameType = require('crocks/predicates/isSameType') const mapProps = require('crocks/helpers/mapProps') const when = require('crocks/logic/when') // middleware :: Object - State Object | Object - Object const middleware = curry( s = when(isSameType(State), execWith(s)) ) // incValue :: State Object () const incValue = modify(mapProps({ value: x = x + 1 })) middleware({ value: 10 }, incValue) //= { value: 11 } middleware({ value: 10 }, { value: 32 }) //= { value: 32 } ","srcFilePath":"src/pages/docs/crocks/State.md","id":"State","location":"/docs/crocks/State.html","url":"/crocks/docs/crocks/State.html"}},"title":"Crocks","description":"Crocks API","layout":"notopic","icon":"code-file","weight":2,"content":" The crocks are the heart and soul of this library. This is where you will find all your favorite ADT's you have grown to love. They include gems such as: Maybe, Either and IO, to name a few. The are usually just a simple constructor that takes either a function or value (depending on the type) and will return you a \"container\" that wraps whatever you passed it. Each container provides a variety of functions that act as the operations you can do on the contained value. There are many types that share the same function names, but what they do from type to type may vary. | Crock | Constructor | Instance | |---|:---|:---| | Arrow | id | both, compose, contramap,first, map, promap, runWith, second | | Async | Rejected, Resolved, all, fromNode, fromPromise, of | alt, ap, bimap, chain, coalesce, fork, map, of, swap, toPromise | | Const | -- | ap, chain, concat, equals, map, valueOf | | Either | Left, Right, of| alt, ap, bimap, chain, coalesce, concat, either, equals, map, of, sequence, swap, traverse | | Equiv | empty | concat, contramap, compareWith, valueOf | | Identity | of | ap, chain, concat, equals, map, of, sequence, traverse, valueOf | | IO | of | ap, chain, map, of, run | | List | empty, fromArray, of | ap, chain, concat, cons, empty, equals, filter, head, map, of, reduce, reduceRight, reject, sequence, tail, toArray, traverse, valueOf | | Maybe | Nothing, Just, of, zero | alt, ap, chain, coalesce, concat, equals, either, map, of, option, sequence, traverse, zero | | Pair | --- | ap, bimap, chain, concat, equals, extend, fst, map, merge, of, sequence, snd, swap, traverse, toArray | | Pred * | empty | concat, contramap, runWith, valueOf | | Reader | ask, of | ap, chain, map, runWith | | ReaderT | ask, lift, liftFn, of | ap, chain, map, runWith | | Result | Err, Ok, of| alt, ap, bimap, chain, coalesce, concat, either, equals, map, of, sequence, swap, traverse | | Star | id | both, compose, contramap, map, promap, runWith | | State | get, modify, of, put | ap, chain, evalWith, execWith, map, runWith | | Unit | empty, of | ap, chain, concat, empty, equals, map, of, valueOf | | Writer| of | ap, chain, equals, log, map, of, read, valueOf | \\* based on this article [arrow]: Arrow.html [arrow-id]: Arrow.html#id [arrow-both]: Arrow.html#both [arrow-compose]: Arrow.html#compose [arrow-contra]: Arrow.html#contramap [arrow-first]: Arrow.html#first [arrow-map]: Arrow.html#map [arrow-promap]: Arrow.html#promap [arrow-runwith]: Arrow.html#runwith [arrow-second]: Arrow.html#second [async]: Async.html [async-rejected]: Async.html#rejected [async-resolved]: Async.html#resolved [async-all]: Async.html#all [async-fromnode]: Async.html#fromnode [async-frompromise]: Async.html#frompromise [async-of]: Async.html#of [async-alt]: Async.html#alt [async-ap]: Async.html#ap [async-bimap]: Async.html#bimap [async-chain]: Async.html#chain [async-coalesce]: Async.html#coalesce [async-fork]: Async.html#fork [async-map]: Async.html#map [async-of]: Async.html#of [async-swap]: Async.html#swap [async-topromise]: Async.html#topromise [equiv]: Equiv.html [equiv-empty]: Equiv.html#empty [equiv-concat]: Equiv.html#concat [equiv-contra]: Equiv.html#contramap [equiv-compare]: Equiv.html#comparewith [equiv-value]: Equiv.html#valueof [pred]: Pred.html [pred-empty]: Pred.html#empty [pred-concat]: Pred.html#concat [pred-contra]: Pred.html#contramap [pred-run]: Pred.html#runwith [pred-value]: Pred.html#valueof [maybe]: Maybe.html [maybe-nothing]: Maybe.html#nothing [maybe-just]: Maybe.html#just [maybe-of]: Maybe.html#of [maybe-zero]: Maybe.html#zero [maybe-alt]: Maybe.html#alt [maybe-ap]: Maybe.html#ap [maybe-chain]: Maybe.html#chain [maybe-coalesce]: Maybe.html#coalesce [maybe-concat]: Maybe.html#concat [maybe-equals]: Maybe.html#equals [maybe-either]: Maybe.html#either [maybe-map]: Maybe.html#map [maybe-option]: Maybe.html#option [maybe-sequence]: Maybe.html#sequence [maybe-traverse]: Maybe.html#traverse [maybe-zero]: Maybe.html#zero [reader]: Reader.html [reader-ask]: Reader.html#ask [reader-of]: Reader.html#of [reader-ap]: Reader.html#ap [reader-chain]: Reader.html#chain [reader-map]: Reader.html#map [reader-run]: Reader.html#runwith [readert]: ReaderT.html [readert-ask]: ReaderT.html#ask [readert-lift]: ReaderT.html#lift [readert-liftfn]: ReaderT.html#liftfn [readert-of]: ReaderT.html#of [readert-ap]: ReaderT.html#ap [readert-chain]: ReaderT.html#chain [readert-map]: ReaderT.html#map [readert-run]: ReaderT.html#runwith [state]: State.html [state-get]: State.html#get [state-modify]: State.html#modify [state-put]: State.html#put [state-of]: State.html#of [state-ap]: State.html#ap [state-chain]: State.html#chain [state-map]: State.html#map [state-run]: State.html#runwith [state-eval]: State.html#evalwith [state-exec]: State.html#execwith ","srcFilePath":"src/pages/docs/crocks/index.md","id":"crocks","location":"/docs/crocks/","url":"/crocks/docs/crocks/","childIds":["Arrow","Async","Equiv","Maybe","Pred","Reader","ReaderT","State"]},"functions":{"children":{"combinators":{"description":"Combinators API","layout":"notopic","title":"Combinators","weight":10,"content":" applyTo crocks/combinators/applyTo applyTo :: a - (a - b) - b Ever run into a situation where you have a value but do not have a function to apply it to? Well this little bird, named Thrush, is there to help out. Just give it a value and it will give you back a function ready to take a function. Once that function is provided, it will return the result of applying your value to that function. composeB crocks/combinators/composeB composeB :: (b - c) - (a - b) - a - c Provides a means to describe a composition between two functions. it takes two functions and a value. Given composeB(f, g), which is read f after g, it will return a function that will take value a and apply it to g, passing the result as an argument to f, and will finally return the result of f. (This allows only two functions, if you want to avoid things like: composeB(composeB(f, g), composeB(h, i)) then check out compose.) constant crocks/combinators/constant constant :: a - () - a This is a very handy dandy function, used a lot. Pass it any value and it will give you back a function that will return that same value no matter what you pass it. flip crocks/combinators/flip flip :: (a - b - c) - b - a - c This little function just takes a function and returns a function that takes the first two parameters in reverse. One can compose flip calls down the line to flip all, or some of the other parameters if there are more than two. Mix and match to your heart's desire. identity crocks/combinators/identity identity :: a - a This function and constant are the workhorses of writing code with this library. It quite simply is just a function that when you pass it something, it returns that thing right back to you. So simple, I will leave it as an exercise to reason about why this is so powerful and important. substitution crocks/combinators/substitution substitution :: (a - b - c) - (a - b) - a - c While it a complicated little bugger, it can come in very handy from time to time. In it's first two arguments it takes functions. The first must be binary and the second unary. That will return you a function that is ready to take some value. Once supplied the fun starts, it will pass the a to the first argument of both functions, and the result of the second function to the second parameter of the first function. Finally after all that juggling, it will return the result of that first function. When used with partial application on that first parameter, a whole new world of combinatory madness is presented! ","srcFilePath":"src/pages/docs/functions/combinators.md","id":"combinators","location":"/docs/functions/combinators.html","url":"/crocks/docs/functions/combinators.html"},"helpers":{"title":"Helpers","description":"Helper functions","layout":"notopic","weight":20,"content":" assign crocks/helpers/assign assign :: Object - Object - Object When working with Objects, a common operation is to combine (2) of them. This can be accomplished in crocks by reaching for assign. Unlike the Object.assign that ships with JavaScript, this assign will combine your Objects into a new shallow copy of their merger. assign only takes two arguments and will overwrite keys present in the second argument with values from the first. As with most of the crocks Object based functions, assign will omit any key-value pairs that are undefined. Check out a related function named defaultProps that will only assign values that are undefined in the second argument. assoc crocks/helpers/assoc assoc :: String - a - Object - Object There may come a time when you want to add a key-value pair to an Object and want control over how the key and value are applied. That is where assoc can come to your aid. Just provide a String key and a value of any type to be associated to the key. Finally pass it any Object and you will get back a shallow copy with your key-value pair merged in. This will overwrite any exiting keys with new value specified. Used with flip, you can do some interesting things with this function, give it a play! If you just want to create an Object and not concatenate it to another Object, objOf may be the function for you. binary crocks/helpers/binary binary :: ((*) - c) - a - b - c With all the different functions out there in the real world, sometimes it is nice to restrict them to a specific -arity to work with your all your wonderful compositions. When you want to restict any function of any arity to a simple binary function. Just pass your function to binary and you will get back a curried, binary function that will only apply (2) arguments to the inner function, ignoring any others. This works very well with functions like Array.prototype.reduce where you may only care about the first 2 arguments. if you need to constrain to more than (2) arguments, then you will want to reach for nAry. binary is basically syntactic sugar for nAry(2, fn). Also related is unary, which constrains to (1) argument. branch crocks/Pair/branch branch :: a - Pair a a When you want to branch a computation into two parts, this is the function you want to reach for. All it does is let you pass in any a and will return you a Pair that has your value on both the first and second parameter. This allows you to work on the value in two separate computation paths. Be advised that this is Javascript and if a is an object type (Object, Array, Date, etc) they will reference each other. Pro-Tip: Pair provides a merge function that will let you fold the two values into a single value. compose crocks/helpers/compose compose :: ((y - z), ..., (a - b)) - a - z While the composeB can be used to create a composition of two functions, there are times when you want to compose an entire flow together. That is where compose is useful. With compose you can create a right-to-left composition of functions. It will return you a function that represents your flow. Not really sold on writing flows from right-to-left? Well then, I would recommend reaching for pipe. composeK crocks/helpers/composeK composeK :: Chain m = ((y - m z), ..., (a - m b)) - a - m z There are many times that, when working with the various crocks, our flows are just a series of chains. Due to some neat properties with types that provide a chain function, you can remove some boilerplate by reaching for composeK. Just pass it the functions you would normally pass to chain and it will do all the boring hook up for you. Just like compose, functions are applied right-to-left, so you can turn this: const { chain, compose, isObject, prop, safe } = crocks const data = { do: { re: { mi: 'fa' } } } // fluent :: a - Maybe b const fluent = x = safe(isObject, x) .chain(prop('do')) .chain(prop('re')) .chain(prop('mi')) fluent(data) // = Just 'fa' // pointfree :: a - Maybe b const pointfree = compose( chain(prop('mi')), chain(prop('re')), chain(prop('do')), safe(isObject) ) pointfree(data) // = Just 'fa' into the more abbreviated form: const { composeK, isObject, prop, safe } = crocks const data = { do: { re: { mi: 'fa' } } } // flow :: a - Maybe b const flow = composeK( prop('mi'), prop('re'), prop('do'), safe(isObject) ) flow(data) // = Just 'fa' As demonstrated in the above example, this function more closely resembles flows that are using a more pointfree style of coding. As with the other composition functions in crocks, a pipeK function is provided for flows that make more sense expressed in a left-to-right style. composeP crocks/helpers/composeP composeP :: Promise p = ((y - p z c), ..., (a - p b c)) - a - p z c When working with Promises, it is common place to create chains on a Promise's then function: const promFunc = x = promiseSomething(x) .then(doSomething) .then(doAnother) Doing this involves a lot of boilerplate and forces you into a fluent style, whether you want to be or not. Using composeP you have the option to compose a series of Promise returning functions like you would any other function composition, in a right-to-left fashion. Like so: const { composeP } = crocks const promFunc = composeP(doAnother, doSomething, promiseSomething) Due to the nature of the then function, only the head of your composition needs to return a Promise. This will create a function that takes a value, which is passed through your chain, returning a Promise which can be extended. This is only a then chain, it does not do anything with the catch function. If you would like to provide your functions in a left-to-right manner, check out pipeP. composeS crocks/helpers/composeS composeS :: Semigroupoid s = (s y z, ..., s a b) - s a z When working with things like Arrow and Star there will come a point when you would like to compose them like you would any Function. That is where composeS comes in handy. Just pass it the Semigroupoids you want to compose and it will give you back a new Semigroupoid of the same type with all of the underlying functions composed and ready to be run. Like compose, composeS composes the functions in a right-to-left fashion. If you would like to represent your flow in a more left-to-right manner, then pipeS is provided for such things. const { Arrow, bimap, branch, composeS, merge, mreduce, Sum } = require('crocks') const length = xs = xs.length const divide = (x, y) = x / y const avg = Arrow(bimap(mreduce(Sum), length)) .promap(branch, merge(divide)) const double = Arrow(x = x * 2) const data = [ 34, 198, 3, 43, 92 ] composeS(double, avg) .runWith(data) // = 148 curry crocks/helpers/curry curry :: ((a, b, ...) - z) - a - b - ... - z Pass this function a function and it will return you a function that can be called in any form that you require until all arguments have been provided. For example if you pass a function: f : (a, b, c) - d you get back a function that can be called in any combination, such as: f(x, y, z), f(x)(y)(z), f(x, y)(z), or even f(x)(y, z). This is great for doing partial application on functions for maximum re-usability. defaultProps crocks/helpers/defaultProps defaultProps :: Object - Object - Object Picture this, you have an Object and you want to make sure that some properties are set with a given default value. When the need for this type of operation presents itself, defaultProps can come to your aid. Just pass it an Object that defines your defaults and then the Object your want to default those props on. If a key that is present on the defaults Object is not defined on your data, then the default value will be used. Otherwise, the value from your data will be used instead. You could just apply flip to the assign function and get the same result, but having a function named defaultProps may be easier to read in code. As with most Object related functions in crocks, defaultProps will return you a shallow copy of the result and not include any undefined values in either Object. defaultTo crocks/helpers/defaultTo defaultTo :: a - b - a With things like null, undefined and NaN showing up all over the place, it can be hard to keep your expected types inline without resorting to nesting in a Maybe with functions like safe. If you want to specifically guard for null, undefined and NaN and get things defaulted into the expected type, then defaultTo should work for you. Just pass it what you would like your default value to be and then the value you want guarded, and you will get back either the default or the passed value, depending on if the passed value is null, undefined or NaN. While this is JavaScript and you can return anything, it is suggested to stick to the signature and only let as through. As a b can be an a as well. dissoc crocks/helpers/dissoc dissoc :: String - Object - Object While assoc can be used to associate a given key-value pair to a given Object, dissoc does the opposite. Just pass dissoc a String key and the Object you wish to dissociate that key from and you will get back a new, shallow copy of the Object sans your key. As with all the Object functions, dissoc will remove any undefined values from the result. fanout crocks/helpers/fanout fanout :: (a - b) - (a - c) - (a - Pair b c) fanout :: Arrow a b - Arrow a c - Arrow a (Pair b c) fanout :: Monad m = Star a (m b) - Star a (m c) - Star a (m (Pair b c)) There are may times that you need to keep some running or persistent state while performing a given computation. A common way to do this is to take the input to the computation and branch it into a Pair and perform different operations on each version of the input. This is such a common pattern that it warrants the fanout function to take care of the initial split and mapping. Just provide a pair of either simple functions or a pair of one of the computation types (Arrow or Star). You will get back something of the same type that is configured to split it's input into a pair and than apply the first Function/ADT to the first portion of the underlying Pair and the second on the second. fromPairs crocks/helpers/fromPairs fromPairs :: Foldable f = f (Pair String a) - Object As an inverse to toPairs, fromPairs takes either an Array or List of key-value Pairs and constructs an Object from it. The Pair must contain a String in the fst and any type of value in the snd. The fst will become the key for the value in the snd. All primitive values are copied into the new Object, while non-primitives are references to the original. If you provide an undefined values for the second, that Pair will not be represented in the resulting Object. Also, when if multiple keys share the same name, that last value will be moved over. liftA2 crocks/helpers/liftA2 liftA2 :: Applicative m = (a - b - c) - m a - m b - m c liftA3 crocks/helpers/liftA3 liftA3 :: Applicative m = (a - b - c - d) - m a - m b - m c - m d Ever see yourself wanting to map a binary or trinary function, but map only allows unary functions? Both of these functions allow you to pass in your function as well as the number of Applicatives (containers that provide both of and ap functions) you need to get the mapping you are looking for. liftN crocks/helpers/liftN liftN :: Applicative m = Number - (() - a) - (m) - m a While liftA2 and liftA3 will handle a majority of the functions we tend to encounter, many cases arise when we want to deal with functions of a greater arity. In those cases, liftN will allow the lifting of function of any size arity. liftN takes a Number that specifies the arity of the function to be lifted, followed by the function itself and finally the required number of Applicative instances of the same type to be applied to the target function. In most cases, there is no need to explicitly curry the target function. This function operates in the same vein as nAry and as such manually curried functions (i.e. x = y = x + y) will need to be explicitly curried using curry to ensure proper application of the arguments. const compose = require('crocks/helpers/compose') const curry = require('crocks/helpers/curry') const liftN = require('crocks/helpers/liftN') const isNumber = require('crocks/predicates/isNumber') const isString = require('crocks/predicates/isString') const map = require('crocks/pointfree/map') const safe = require('crocks/Maybe/safe') // apply :: (((*) - b), [ a ]) - b const apply = fn = xs = fn.apply(null, xs) // join :: String - String - String const join = x = y = ${x} ${y} // safeString :: a - Maybe String const safeString = safe(isString) // sumArgs :: (* Number) - Number const sumArgs = (...args) = args.reduce((x, y) = x + y, 0) // max :: Applicative m = [ m Number ] - m Number const max = apply(liftN(4, Math.max)) // sum :: Applicative m = [ m Number ] - m Number const sum = apply(liftN(4, sumArgs)) // apJoin :: Applicative m = [ m String ] - m String const apJoin = liftN(2, curry(join)) // good :: [ Number ] const good = [ 45, 54, 96, 99 ] // bad :: [ String ] const bad = [ 'one', 'two', 'three', 'four' ] // arMax :: [ Number ] - [ Number ] const arMax = compose(max, map(Array.of)) // safeSum :: Maybe Number - Maybe Number const safeSum = compose(sum, map(safe(isNumber))) arMax(good) //= [ 99 ] safeSum(good) //= Just 294 safeSum(bad) //= Nothing apJoin(safeString('Joey'), safeString('Fella')) //= Just \"Joey Fella\" apJoin(safeString(9), safeString('Fella')) //= Nothing mapProps crocks/helpers/mapProps mapProps :: { (* - *) } - Object - Object Would like to map specific keys in an Object with a specific function? Just bring in mapProps and pass it an Object with the functions you want to apply on the keys you want them associated to. When the resulting function receives an Object, it will return a new Object with the keys mapped according to the mapping functions. All keys from the original Object that do not exist in the mapping Object will still exist untouched, but the keys with mapping functions with now contain the result of applying the original value to the provided mapping function. mapProps also allows for mapping on nested Objects for times when the shape of the original Object is know. const mapProps = require('crocks/helpers/mapProps') const add = x = y = x + y const toUpper = x = x.toUpperCase() const mapping = { entry: toUpper, fauna: { unicorns: add(1), elephants: add(-1) }, flora: { nariphon: add(10), birch: add(1) } } mapProps(mapping, { entry: 'legend', fauna: { unicorns: 10, zombies: 3 }, other: { hat: 2 } }) //= { entry: 'LEGEND', fauna: { unicorns: 11, zombies: 3 }, other: { hat: 2} } mapReduce crocks/helpers/mapReduce mapReduce :: Foldable f = (a - b) - (c - b - c) - c - f a - c Sometimes you need the power provided by mreduceMap but you do not have a Monoid to lift into. mapReduce provides the same power, but with the flexibility of using functions to lift and combine. mapReduce takes a unary mapping function, a binary reduction function, the initial value and finally a Foldable structure of data. Once all arguments are provided, mapReduce folds the provided data, by mapping each value through your mapping function, before sending it to the second argument of your reduction function. const Max = require('crocks/Max') const { Nothing } = require('crocks/Maybe') const isNumber = require('crocks/predicates/isNumber') const mapReduce = require('crocks/helpers/mapReduce') const safeLift = require('crocks/Maybe/safeLift') const data = [ '100', null, 3, true, 1 ] const safeMax = mapReduce( safeLift(isNumber, Max), (y, x) = y.concat(x).alt(y).alt(x), Nothing() ) safeMax(data) .option(Max.empty()) .valueOf() // = 3 mconcat crocks/helpers/mconcat mconcat :: Monoid m, Foldable f = m - f a - m a mreduce crocks/helpers/mreduce mreduce :: Monoid m, Foldable f = m - f a - a These two functions are very handy for combining an entire List or Array of values by providing a Monoid and your collection of values. The difference between the two is that mconcat returns the result inside the Monoid used to combine them. Where mreduce returns the bare value itself. mconcatMap crocks/helpers/mconcatMap mconcatMap :: Monoid m, Foldable f = m - (b - a) - f b - m a mreduceMap crocks/helpers/mreduceMap mreduceMap :: Monoid m, Foldable f = m - (b - a) - f b - a There comes a time where the values you have in a List or an Array are not in the type that is needed for the Monoid you want to combine with. These two functions can be used to map some transforming function from a given type into the type needed for the Monoid. In essence, this function will run each value through the function before it lifts the value into the Monoid, before concat is applied. The difference between the two is that mconcatMap returns the result inside the Monoid used to combine them. Where mreduceMap returns the bare value itself. nAry crocks/helpers/nAry nAry :: Number - (() - a) - () - a When using functions like Math.max or Object.assign that take as many arguments as you can throw at them, it makes it hard to curry them in a reasonable manner. nAry can make things a little nicer for functions like that. It can also be put to good use to limit a given function to a desired number of arguments to avoid accidentally supplying default arguments when you do not what them applied. First pass nAry the number of arguments you wish to limit the function to and then the function you wish to limit. nAry will give you back a curried function that will only apply the specified number of arguments to the inner function. Unary and binary functions are so common that crocks provides specific functions for those cases: unary and binary. objOf crocks/helpers/objOf objOf :: String - a - Object If you ever find yourself in a situation where you have a key and a value and just want to combine the two into an Object, then it sounds like objOf is the function for you. Just pass it a String for the key and any type of value, and you'll get back an Object that is composed of those two. If you find yourself constantly concatenating the result of this function into another Object, you may want to use assoc instead. omit crocks/helpers/omit omit :: Foldable f = f String - Object - Object Sometimes you just want to strip Objects of unwanted properties by key. Using omit will help you get that done. Just pass it a Foldable structure with a series of Strings as keys and then pass it an Object and you will get back not only a shallow copy, but also an Object free of any of those pesky undefined values. You can think of omit as a way to black-list or reject Object properties based on key names. This function ignores inherited properties and should only be used with POJOs. If you want to filter or white-list properties rather than reject them, take a look at pick. once crocks/helpers/once once :: (() - a) - (() - a) There are times in Javascript development where you only want to call a function once and memo-ize the first result for every subsequent call to that function. Just pass the function you want guarded to once and you will get back a function with the expected guarantees. partial crocks/helpers/partial partial :: ((() - c), *) - () - c There are many times when using functions from non-functional libraries or from built-in JS functions, where it does not make sense to wrap it in a curry. You just want to partially apply some arguments to it and get back a function ready to take the rest. That is a perfect opportunity to use partial. Just pass a function as the first argument and then apply any other arguments to it. You will get back a curried function that is ready to accept the rest of the arguments. const { map, partial } = require('crocks') const max10 = partial(Math.min, 10) const data = [ 13, 5, 13 ] map(max10, data) // = [ 10, 5, 10] pick crocks/helpers/pick pick :: Foldable f = f String - Object - Object When dealing with Objects, sometimes it is necessary to only let some of the key-value pairs on an object through. Think of pick as a sort of white-list or filter for Object properties. Pass it a Foldable structure of Strings that are the keys you would like to pick off of your Object. This will give you back a shallow copy of the key-value pairs you specified. This function will ignore inherited properties and should only be used with POJOs. Any undefined values will not be copied over, although null values are allowed. For black-listing properties, have a look at omit. pipe crocks/helpers/pipe pipe :: ((a - b), ..., (y - z)) - a - z If you find yourself not able to come to terms with doing the typical right-to-left composition, then crocks provides a means to accommodate you. This function does the same thing as compose, the only difference is it allows you define your flows in a left-to-right manner. pipeK crocks/helpers/pipeK pipeK :: Chain m = ((a - m b), ..., (y - m z)) - a - m z Like composeK, you can remove much of the boilerplate when chaining together a series of functions with the signature: Chain m = a - m b. The difference between the two functions is, while composeK is right-to-left, pipeK is the opposite, taking its functions left-to-right. const { curry, List, Writer } = require('../crocks') const OpWriter = Writer(List) const addLog = curry( (x, y) = OpWriter(adding ${x} to ${y}, x + y) ) const scaleLog = curry( (x, y) = OpWriter(scaling ${y} by ${x}, x * y) ) const fluent = x = OpWriter.of(x) .chain(addLog(4)) .chain(scaleLog(3)) fluent(0).log() // = List [ \"adding 4 to 0\", \"scaling 4 by 3\" ] const chainPipe = pipeK( addLog(4), scaleLog(3) ) chainPipe(0).log() // = List [ \"adding 4 to 0\", \"scaling 4 by 3\" ] pipeP crocks/helpers/pipeP pipeP :: Promise p = ((a - p b d), ..., (y - p z d)) - a - p z d Like the composeP function, pipeP will let you remove the standard boilerplate that comes with working with Promise chains. The only difference between pipeP and composeP is that it takes its functions in a left-to-right order: const { pipeP } = crocks const promFunc = x = promise(x) .then(doSomething) .then(doAnother) const promPipe = pipeP(proimse, doSomething, doAnother) pipeS crocks/helpers/pipeS pipeS :: Semigroupoid s = (s a b, ..., s y z) - s a z While Stars and Arrows come in very handy at times, the only thing that could make them better is to compose them . With pipeS you can do just that with any Semigroupoid. Just like with composeS, you just pass it Semigroupoids of the same type and you will get back another Semigroupoid with them all composed together. The only difference between the two, is that pipeS composes in a left-to-right fashion, while composeS does the opposite. const { curry, isNumber, pipeS, prop, safeLift, Star } = require('../crocks') const add = curry( (x, y) = x + y ) const pull = x = Star(prop(x)) const safeAdd = x = Star(safeLift(isNumber, add(x))) const data = { num: 56, string: '56' } const flow = (key, num) = pipeS( pull(key), safeAdd(num) ) flow('num', 10).runWith(data) // = Just 66 flow('string', 100).runWith(data) // = Nothing propOr crocks/helpers/propOr propOr :: a - (String | Integer) - b - c If you want some safety around pulling a value out of an Object or Array with a single key or index, you can always reach for propOr. Well, as long as you are working with non-nested data that is. Just tell propOr either the key or index you are interested in, and you will get back a function that will take anything and return the wrapped value if the key/index is defined. If the key/index is not defined however, you will get back the provided default value. const propOr = require('crocks/helpers/propOr') const data = { foo: 'bar', null: null, nan: NaN, undef: undefined } // def :: (String | Integer) - a - b const def = propOr('default') def('foo', data) //= \"bar\" def('null', data) //= null def('nan', data) //= NaN def('baz', data) //= \"default\" def('undef', data) //= \"default\" propPathOr crocks/helpers/propPathOr propPathOr :: Foldable f = a - f (String | Integer) - b - c While propOr is good for simple, single-level structures, there may come a time when you have to work with nested POJOs or Arrays. When you run into this situation, just pull in propPathOr and pass it a left-to-right traversal path of keys, indices or a combination of both (gross...but possible). This will kick you back a function that behaves just like propOr. You pass it some data, and it will attempt to resolve your provided path. If the path is valid, it will return the value. But if at any point that path \"breaks\" it will give you back the default value. const propPathOr = require('crocks/helpers/propPathOr') const data = { foo: { bar: 'bar', null: null, nan: NaN, undef: undefined }, arr: [ 1, 2 ] } // def :: [ String | Integer ] - a - b const def = propPathOr('default') def([ 'foo', 'bar' ], data) //= \"bar\" def([ 'baz', 'tommy' ], data) //= \"default\" def([ 'foo', 'null' ], data) //= null def([ 'foo', 'nan' ], data) //= NaN def([ 'foo', 'undef' ], data) //= \"default\" def([ 'arr', 'length' ], data) //= 2 tap crocks/helpers/tap tap :: (a - b) - a - a It is hard knowing what is going on inside of some of these ADTs or your wonderful function compositions. Debugging can get messy when you need to insert a side-effect into your flow for introspection purposes. With tap, you can intervene in your otherwise pristine flow and make sure that the original value is passed along to the next step of your flow. This function does not guarantee immutability for reference types (Objects, Arrays, etc), you will need to exercise some discipline here to not mutate. toPairs crocks/Pair/toPairs toPairs :: Object - List (Pair String a) When dealing with Objects, sometimes it makes more sense to work in a Foldable structure like a List of key-value Pairs. toPairs provides a means to take an object and give you back a List of Pairs that have a String that represents the key in the fst and the value for that key in the snd. The primitive values are copied, while non-primitive values are references. Like most of the Object functions in crocks, any keys with undefined values will be omitted from the result. crocks provides an inverse to this function named fromPairs. tryCatch crocks/Result/tryCatch tryCatch :: (a - b) - a - Result e b Typical try-catch blocks are very imperative in their usage. This tryCatch function provides a means of capturing that imperative nature in a simple declarative style. Pass it a function that could fail and it will return you another function wrapping the first function. When called, the new function will either return the result in a Result.Ok if everything was good, or an error wrapped in an Result.Err if it fails. unary crocks/helpers/unary unary :: ((*) - b) - a - b If you every need to lock down a given function to just one argument, then look no further than unary. Just pass it a function of any arity, and you will get back another function that will only apply (1) argument to given function, no matter what is passed to it. unary is just syntactic sugar around nAry in the form of nAry(1, fn) as it is such a common case. Another common case is binary which, as the name implies, only applies (2) arguments to a given function. unit crocks/helpers/unit unit :: () - undefined While it seems like just a simple function, unit can be used for a number of things. A common use for it is as a default noop as it is a function that does nothing and returns undefined. You can also use it in a pointed fashion to represent some special value for a given type. This pointed use is the heart and soul of the infamous Maybe type. [safe]: ../crocks/Maybe.html#safe ","srcFilePath":"src/pages/docs/functions/helpers.md","id":"helpers","location":"/docs/functions/helpers.html","url":"/crocks/docs/functions/helpers.html"},"logic-functions":{"description":"Logic Functions API","layout":"notopic","title":"Logic Functions","weight":30,"content":" The functions in this section are used to represent logical branching in a declarative manner. Each of these functions require either Preds or predicate functions in their input. Since these functions work with Preds and predicate functions, rather than values, this allows for composeable, \"lazy\" evaluation. All logic functions can be referenced from crocks/logic and and :: ((a - Boolean) | Pred a) - ((a - Boolean) | Pred a) - a - Boolean Say you have two predicate functions or Preds and would like to combine them into one predicate over conjunction, well you came to the right place, and accepts either predicate functions or Preds and will return you a function ready to take a value. Once that value is passed, it will run it through both of the predicates and return the result of combining it over a logical and. This is super helpful combined with or for putting together reusable, complex predicates. As they follow the general form of (a - Boolean) they are easily combined with other logic functions. ifElse ifElse :: ((a - Boolean) | Pred a) - (a - b) - (a - b) - a - b Whenever you need to modify a value based some condition and want a functional way to do it without some imperative if statement, then reach for ifElse. This function take a predicate (some function that returns a Boolean) and two functions. The first is what is executed when the predicate is true, the second on a false condition. This will return a function ready to take a value to run through the predicate. After the value is evaluated, it will be ran through it's corresponding function, returning the result as the final result. This function comes in really handy when creating lifting functions for Sum Types (like Either or Maybe). not not :: ((a - Boolean) | Pred) - a - Boolean When you need to negate a predicate function or a Pred, but want a new predicate function that does the negation, then not is going to get you what you need. Using not will allow you to stay as declarative as possible. Just pass not your predicate function or a Pred, and it will give you back a predicate function ready for insertion into your flow. All predicate based functions in crocks take either a Pred or predicate function, so it should be easy to swap between the two. or or :: ((a - Boolean) | Pred) - ((a - Boolean) | Pred) - a - Boolean Say you have two predicate functions or Preds and would like to combine them into one predicate over disjunction, look no further, or accepts either predicate functions or Preds and will return you a function ready to take a value. Once that value is passed, it will run it through both of the predicates and return the result of combining it over a logical or. This is super helpful combined with and for putting together reusable, complex predicates. As they follow the general form of (a - Boolean) they are easily combined with other logic functions. unless unless :: ((a - Boolean) | Pred) - (a - a) - a - a There may come a time when you need to adjust a value when a condition is false, that is where unless can come into play. Just provide a predicate function (a function that returns a Boolean) and a function to apply your desired modification. This will get you back a function that when you pass it a value, it will evaluate it and if false, will run your value through the provided function. Either the original or modified value will be returned depending on the result of the predicate. Check out when for a negated version of this function. when when :: ((a - Boolean) | Pred) - (a - a) - a - a There may come a time when you need to adjust a value when a condition is true, that is where when can come into play. Just provide a predicate function (a function that returns a Boolean) and a function to apply your desired modification. This will get you back a function that when you pass it a value, it will evaluate it and if true, will run your value through the provided function. Either the original or modified value will be returned depending on the result of the predicate. Check out unless for a negated version of this function. ","srcFilePath":"src/pages/docs/functions/logic-functions.md","id":"logic-functions","location":"/docs/functions/logic-functions.html","url":"/crocks/docs/functions/logic-functions.html"},"pointfree-functions":{"title":"Point-free Functions","description":"Point-free Functions API","layout":"notopic","weight":50,"content":" While it can seem natural to work with all these containers in a fluent fashion, it can get cumbersome and hard to get a lot of reuse out of. A way to really get the most out of reusability in Javascript is to take what is called a point-free approach. Below is a small code same to contrast the difference between the two calling styles: const crocks = require('crocks') const { compose, map, safe, isInteger } = crocks // map is the point-free function // isEven :: Integer - Boolean const isEven = x = (x % 2) === 0 // maybeInt :: a - Maybe Integer const maybeInt = safe(isInteger) // fluentIsEven :: a - Maybe Boolean const fluentIsEven = data = maybeInt(data) .map(isEven) // pointfreeIsEven :: a - Maybe Boolean const pointfreeIsEven = compose(map(isEven), maybeInt) These functions provide a very clean way to build out very simple functions and compose them all together to compose a more complicated flow. Each point-free function provided in crocks is \"auto-curried\" and follows a \"data-last\" pattern in the order of how it receives it's arguments. Typically the most stable of the arguments comes first, moving all the way to the least stable argument (which usually is the data flowing through your composition). Below lists the provided functions and the data types they work with (m refers to an accepted Datatype): Signatures | Function | Signature | Location | |---|:---|:---| | alt | m a - m a - m a | crocks/pointfree | | ap | m a - m (a - b) - m b | crocks/pointfree | | bimap | (a - c) - (b - d) - m a b - m c d | crocks/pointfree | | both | m (a - b) - m (Pair a a - Pair b b) | crocks/pointfree | | chain | (a - m b) - m a - m b | crocks/pointfree | | coalesce | (a - c) - (b - c) - m a b - m _ c | crocks/pointfree | | compareWith | a - a - m a - b | crocks/pointfree | | concat | m a - m a - m a | crocks/pointfree | | cons | a - m a - m a | crocks/pointfree | | contramap | (b - a) - m a - m b | crocks/pointfree | | either | (a - c) - (b - c) - m a b - c | crocks/pointfree | | empty | m - m | crocks/pointfree | | equals | m - m - Boolean | crocks/pointfree | | evalWith | s - m - a | crocks/State | | execWith | s - m - s | crocks/State | | extend | (m a - b) - m a - m b | crocks/pointfree | | filter | ((a - Boolean) &124; Pred a) - m a - m a | crocks/pointfree | | first | m (a - b) - m (Pair a c - Pair b c) | crocks/pointfree | | fold | Semigroup s = m s - s | crocks/pointfree | | fst | m a b - a | crocks/Pair | | head | m a - Maybe a | crocks/pointfree | | log | m a b - a | crocks/Writer | | map | (a - b) - m a - m b | crocks/pointfree | | merge | (a - b - c) - m a b - c | crocks/Pair | | option | a - m a - a | crocks/pointfree | | promap | (c - a) - (b - d) - m a b - m c d | crocks/pointfree | | read | m a b - Pair a b | crocks/Writer | | reduce | (b - a - b) - b - m a - b | crocks/pointfree | | reduceRight | (b - a - b) - b - m a - b | crocks/pointfree | | reject | ((a - Boolean) &#124; Pred a) - m a - m a | crocks/pointfree | | run | m a - b | crocks/pointfree | | runWith | a - m - b | crocks/pointfree | | second | m (a - b) - m (Pair c a - Pair c b) | crocks/pointfree | | sequence | Applicative f = (b - f b) - m (f a) - f (m a) | crocks/pointfree | | snd | m a b - b | crocks/Pair | | swap | (c - d) - (a - b) - m c a - m b d | crocks/pointfree | | tail | m a - Maybe (m a) | crocks/pointfree | | traverse | Applicative f = (c - f c) - (a - f b) - m (f a) - f (m b) | crocks/pointfree | | valueOf | m a - a | crocks/pointfree | Datatypes | Function | Datatypes | |---|:---| | alt | Async, Either, Maybe, Result | | ap | Array, Async, Const, Either, Identity, IO, List, Maybe, Pair, Reader, Result, State, Unit, Writer | | bimap | Async, Either, Pair, Result | | both | Arrow, Function, Star | | chain | Array, Async, Const, Either, Identity, IO, List, Maybe, Pair, Reader, Result, State, Unit, Writer | | coalesce | Async, Either, Maybe, Result | | compareWith | Equiv | | concat | All, Any, Array, Assign, Const, Either, Endo, Equiv, First, Identity, Last, List, Max, Maybe, Min, Pair, Pred, Prod, Result, String, Sum, Unit | | cons | Array, List | | contramap | Arrow, Equiv, Pred, Star | | either | Either, Maybe, Result | | empty | All, Any, Array, Assign, Endo, Equiv, First, Last, List, Max, Min, Object, Pred, Prod, String, Sum, Unit | | evalWith | State | | execWith | State | | extend | Pair | | filter | Array, List, Object | | first | Arrow, Function, Star | | fold | Array, List | | fst | Pair | | head | Array, List, String | | log | Writer | | map | Async, Array, Arrow, Const, Either, Function, Identity, IO, List, Maybe, Object, Pair, Reader, Result, Star, State, Unit, Writer | | merge | Pair | | option | First, Last, Maybe | | promap | Arrow, Star | | read | Writer | | reduce | Array, List | | reduceRight | Array, List | | reject | Array, List, Object | | run | IO | | runWith | Arrow, Endo, Pred, Reader, Star, State | | second | Arrow, Function, Star | | sequence | Array, Either, Identity, List, Maybe, Pair, Result | | snd | Pair | | swap | Async, Either, Pair, Result | | tail | Array, List, String | | traverse | Array, Either, Identity, List, Maybe, Pair, Result | | valueOf | All, Any, Assign, Const, Endo, Equiv, First, Identity, Last, Max, Min, Pred, Prod, Sum, Unit, Writer | [all-concat]: ../monoids/All.htmlconcat [all-empty]: ../monoids/All.html#empty [all-value]: ../monoids/All.html#valueof [any-concat]: ../monoids/Any.html#concat [any-empty]: ../monoids/Any.html#empty [any-value]: ../monoids/Any.html#valueof [assign-concat]: ../monoids/Assign.html#concat [assign-empty]: ../monoids/Assign.html#empty [assign-value]: ../monoids/Assign.html#valueof [arrow-both]: ../crocks/Arrow.html#both [arrow-contra]: ../crocks/Arrow.html#contramap [arrow-first]: ../crocks/Arrow.html#first [arrow-map]: ../crocks/Arrow.html#map [arrow-pro]: ../crocks/Arrow.html#promap [arrow-run]: ../crocks/Arrow.html#runwith [arrow-second]: ../crocks/Arrow.html#second [async-alt]: ../crocks/Async.html#alt [async-ap]: ../crocks/Async.html#ap [async-bimap]: ../crocks/Async.html#bimap [async-chain]: ../crocks/Async.html#chain [async-coalesce]: ../crocks/Async.html#coalesce [async-map]: ../crocks/Async.html#map [async-swap]: ../crocks/Async.html#swap [endo-concat]: ../monoids/Endo.html#concat [endo-empty]: ../monoids/Endo.html#empty [endo-run]: ../monoids/Endo.html#runwith [endo-value]: ../monoids/Endo.html#valueof [equiv-compare]: ../crocks/Equiv.html#comparewith [equiv-concat]: ../crocks/Equiv.html#concat [equiv-contra]: ../crocks/Equiv.html#contramap [equiv-empty]: ../crocks/Equiv.html#empty [equiv-value]: ../crocks/Equiv.html#valueof [first-concat]: ../monoids/First.html#concat [first-empty]: ../monoids/First.html#empty [first-option]: ../monoids/First.html#option [first-value]: ../monoids/First.html#valueof [last-concat]: ../monoids/Last.html#concat [last-empty]: ../monoids/Last.html#empty [last-option]: ../monoids/Last.html#option [last-value]: ../monoids/Last.html#valueof [max-concat]: ../monoids/Max.html#concat [max-empty]: ../monoids/Max.html#empty [max-value]: ../monoids/Max.html#valueof [maybe-alt]: ../crocks/Maybe.html#alt [maybe-ap]: ../crocks/Maybe.html#ap [maybe-chain]: ../crocks/Maybe.html#chain [maybe-coalesce]: ../crocks/Maybe.html#coalesce [maybe-concat]: ../crocks/Maybe.html#concat [maybe-either]: ../crocks/Maybe.html#either [maybe-map]: ../crocks/Maybe.html#map [maybe-option]: ../crocks/Maybe.html#option [maybe-sequence]: ../crocks/Maybe.html#sequence [maybe-traverse]: ../crocks/Maybe.html#traverse [min-concat]: ../monoids/Min.html#concat [min-empty]: ../monoids/Min.html#empty [min-value]: ../monoids/Min.html#valueof [pred-concat]: ../crocks/Pred.html#concat [pred-contra]: ../crocks/Pred.html#contramap [pred-empty]: ../crocks/Pred.html#empty [pred-run]: ../crocks/Pred.html#runwith [pred-value]: ../crocks/Pred.html#valueof [prod-concat]: ../monoids/Prod.html#concat [prod-empty]: ../monoids/Prod.html#empty [prod-value]: ../monoids/Prod.html#valueof [sum-concat]: ../monoids/Sum.html#concat [sum-empty]: ../monoids/Sum.html#empty [sum-value]: ../monoids/Sum.html#valueof [reader-ap]: ../crocks/Reader.html#ap [reader-chain]: ../crocks/Reader.html#chain [reader-map]: ../crocks/Reader.html#map [reader-run]: ../crocks/Reader.html#runwith [state-ap]: ../crocks/State.html#ap [state-chain]: ../crocks/State.html#chain [state-eval]: ../crocks/State.html#evalwith [state-exec]: ../crocks/State.html#execwith [state-map]: ../crocks/State.html#map [state-run]: ../crocks/State.html#runwith [exec]: ../crocks/State.html#execwith-pointfree [eval]: ../crocks/State.html#evalwith-pointfree ","srcFilePath":"src/pages/docs/functions/pointfree-functions.md","id":"pointfree-functions","location":"/docs/functions/pointfree-functions.html","url":"/crocks/docs/functions/pointfree-functions.html"},"predicate-functions":{"description":"Predicate Functions API","layout":"notopic","title":"Predicate Functions","weight":40,"content":" All functions in this group have a signature of * - Boolean and are used with the many predicate based functions that ship with crocks, like safe, ifElse and filter to name a few. They also fit naturally with the Pred ADT. All predicate functions can be referenced from crocks/predicates. Below is a list of all the current predicates that are included with a description of their truth: hasProp :: (String | Integer) - a - Boolean: an Array or Object that contains the provided index or key hasPropPath :: [ String | Integer ] - a - Boolean: an Array or Object that contains the provided index path isAlt :: a - Boolean: an ADT that provides map and alt methods isAlternative :: a - Boolean: an ADT that provides alt, zero, map, ap, chain and ofmethods isApplicative :: a - Boolean: an ADT that provides map, ap and of methods isApply :: a - Boolean: an ADT that provides map and ap methods isArray :: a - Boolean: Array isBifunctor :: a - Boolean: an ADT that provides map and bimap methods isBoolean :: a - Boolean: Boolean isCategory :: a - Boolean: an ADT that provides id and compose methods isChain :: a - Boolean: an ADT that provides map, ap and chain methods isContravariant : a - Boolean: an ADT that provides contramap method isDefined :: a - Boolean: Every value that is not undefined, null included isEmpty :: a - Boolean: Empty Object, Array or String isExtend :: a - Boolean: an ADT that provides map and extend methods isFoldable :: a - Boolean: Array, List or any structure with a reduce method isFunction :: a - Boolean: Function isFunctor :: a - Boolean: an ADT that provides a map method isInteger :: a - Boolean: Integer isMonad :: a - Boolean: an ADT that provides map, ap, chain and of methods isMonoid :: a - Boolean: an ADT that provides concat and empty methods isNil :: a - Boolean: undefined or null or NaN isNumber :: a - Boolean: Number that is not a NaN value, Infinity included isObject :: a - Boolean: Plain Old Javascript Object (POJO) isPlus :: a - Boolean: an ADT that provides map, alt and zero methods isProfunctor : a - Boolean: an ADT that provides map, contramap and promap methods isPromise :: a - Boolean: an object implementing then and catch isSame :: a - b - Boolean: same value or reference, use equals for value equality isSameType :: a - b - Boolean: Constructor matches a values type, or two values types match isSemigroup :: a - Boolean: an ADT that provides a concat method isSemigroupoid :: a - Boolean: an ADT that provides a compose method isSetoid :: a - Boolean: an ADT that provides an equals method isString :: a - Boolean: String isTraversable :: a - Boolean: an ADT that provides map and traverse methods propEq: (String | Interger) - a - Object - Boolean: an Object that contains the provided key propPathEq :: [ String | Integer ] - a - Object - Boolean: an Object that contains the provided key in the provided traversal path [pred]: ../crocks/Pred.html [ifelse]: logic-functions.html#ifelse [safe]: helpers.html#safe ","srcFilePath":"src/pages/docs/functions/predicate-functions.md","id":"predicate-functions","location":"/docs/functions/predicate-functions.html","url":"/crocks/docs/functions/predicate-functions.html"},"transformation-functions":{"title":"Transformation Functions","description":"Transformation Functions API","layout":"notopic","weight":60,"content":" Transformation functions are mostly used to reduce unwanted nesting of similar types. Take for example the following structure: const data = Either.of(Maybe.of(3)) // Right Just 3 // mapping on the inner Maybe is tedious at best data .map(map(x = x + 1)) // Right Just 4 .map(map(x = x * 10)) // Right Just 40 // and extraction...super gross data .either(identity, identity) // Just 3 .option(0) // 3 // or data .either(option(0), option(0)) // 3 The transformation functions, that ship with crocks, provide a means for dealing with this. Using them effectively, can turn the above code into something more like this: const data = Either.of(Maybe.of(3)) // Right Just 3 .chain(maybeToEither(0)) // Right 3 // mapping on a single Either, much better data .map(x = x + 1) // Right 4 .map(x = x * 10) // Right 40 // no need to default the Left case anymore data .either(identity, identity) // 3 // effects of the inner type are applied immediately const nested = Either.of(Maybe.Nothing) // Right Nothing const unnested = nested .chain(maybeToEither(0)) // Left 0 // Always maps, although the inner Maybe skips nested .map(map(x = x + 1)) // Right Nothing (runs mapping) .map(map(x = x * 10)) // Right Nothing (runs mapping) .either(identity, identity) // Nothing .option(0) // 0 // Never maps on a Left, just skips it unnested .map(x = x + 1) // Left 0 (skips mapping) .map(x = x * 10) // Left 0 (skips mapping) .either(identity, identity) // 0 Not all types can be transformed to and from each other. Some of them are lazy and/or asynchronous, or are just too far removed. Also, some transformations will result in a loss of information. Moving from an Either to a Maybe, for instance, would lose the Left value of Either as a Maybe's first parameter (Nothing) is fixed at Unit. Conversely, if you move the other way around, from a Maybe to an Either you must provide a default Left value. Which means, if the inner Maybe results in a Nothing, it will map to Left of your provided value. As such, not all of these functions are guaranteed isomorphic. With some types you just cannot go back and forth and expect to retain information. Each function provides two signatures, one for if a Function is used for the second argument and another if the source ADT is passed instead. Although it may seem strange, this provides some flexibility on how to apply the transformation. The ADT version is great for squishing an already nested type or to perform the transformation in a composition. While the Function version can be used to extend an existing function without having to explicitly compose it. Both versions can be seen here: // Avoid nesting // inc :: a - Maybe Number const inc = safeLift(isNumber, x = x + 1) // using Function signature // asyncInc :: a - Async Number Number const asyncInc = maybeToAsync(0, inc) // using ADT signature to compose (extending functions) // asyncInc :: a - Async Number Number const anotherInc = compose(maybeToAsync(0), inc) // resolveValue :: a - Async _ a const resolveValue = Async.Resolved resolveValue(3) // Resolved 3 .chain(asyncInc) // Resolved 4 .chain(anotherInc) // Resolved 5 .chain(compose(maybeToAsync(20), inc)) // Resolved 6 resolveValue('oops') // Resolved 'oops' .chain(asyncInc) // Rejected 0 .chain(anotherInc) // Rejected 0 .chain(compose(maybeToAsync(20), inc)) // Rejected 0 // Squash existing nesting // Just Right 'nice' const good = Maybe.of(Either.Right('nice')) // Just Left 'not so nice' const bad = Maybe.of(Either.Left('not so nice')) good .chain(eitherToMaybe) // Just 'nice' bad .chain(eitherToMaybe) // Nothing Transformation Signatures | Transform | ADT signature | Function Signature | Location | |---|:---|:---|:---| | arrayToList | [ a ] - List a | (a - [ b ]) - a - List b | crocks/List | | eitherToAsync | Either e a - Async e a | (a - Either e b) - a - Async e b | crocks/Async | | eitherToFirst | Either b a - First a | (a - Either c b) - a - First b | crocks/First | | eitherToLast | Either b a - Last a | (a - Either c b) - a - Last b | crocks/Last | | eitherToMaybe | Either b a - Maybe a | (a - Either c b) - a - Maybe b | crocks/Maybe | | eitherToResult | Either e a - Result e a | (a - Either e b) - a - Result e b | crocks/Result | | firstToAsync | e - First a - Async e a | e - (a - First b) - a - Async e b | crocks/Async | | firstToEither | c - First a - Either c a | c - (a - First b) - a - Either c b | crocks/Either | | firstToLast | First a - Last a | (a - First b) - a - Last b | crocks/Last | | firstToMaybe | First a - Maybe a | (a - First b) - a - Maybe b | crocks/Maybe | | firstToResult | c - First a - Result c a | c - (a - First b) - a - Result c b | crocks/Result | | lastToAsync | e - Last a - Async e a | e - (a - Last b) - a - Async e b | crocks/Async | | lastToEither | c - Last a - Either c a | c - (a - Last b) - a - Either c b | crocks/Either | | lastToFirst | Last a - First a | (a - Last b) - a - First b | crocks/First | | lastToMaybe | Last a - Maybe a | (a - Last b) - a - Maybe b | crocks/Maybe | | lastToResult | c - Last a - Result c a | c - (a - Last b) - a - Result c b | crocks/Result | | listToArray | List a - [ a ] | (a - List b) - a - [ b ] | crocks/List | | maybeToAsync | e - Maybe a - Async e a | e - (a - Maybe b) - a - Async e b | crocks/Async | | maybeToEither | c - Maybe a - Either c a | c - (a - Maybe b) - a - Either c b | crocks/Either | | maybeToFirst | Maybe a - First a | (a - Maybe b) - a - First b | crocks/First | | maybeToLast | Maybe a - Last a | (a - Maybe b) - a - Last b | crocks/Last | | maybeToResult | c - Maybe a - Result c a | c - (a - Maybe b) - a - Result c b | crocks/Result | | resultToAsync | Result e a - Async e a | (a - Result e b) - a - Async e b | crocks/Async | | resultToEither | Result e a - Either e a | (a - Result e b) - a - Either e b | crocks/Either | | resultToFirst | Result e a - First a | (a - Result e b) - a - First b | crocks/First | | resultToLast | Result e a - Last a | (a - Result e b) - a - Last b | crocks/Last | | resultToMaybe | Result e a - Maybe a | (a - Result e b) - a - Maybe b | crocks/Maybe | | writerToPair | Writer m a - Pair m a | (a - Writer m b) - a - Pair m b | crocks/Pair | [either-async]: ../crocks/Async.htmleithertoasync [first-async]: ../crocks/Async.html#firsttoasync [last-async]: ../crocks/Async.html#lasttoasync [maybe-async]: ../crocks/Async.html#maybetoasync [result-async]: ../crocks/Async.html#resulttoasync [either-maybe]: ../crocks/Maybe.html#eithertomaybe [first-maybe]: ../crocks/Maybe.html#firsttomaybe [last-maybe]: ../crocks/Maybe.html#lasttomaybe [result-maybe]: ../crocks/Maybe.html#resulttomaybe [either-first]: ../monoids/First.html#eithertofirst [last-first]: ../monoids/First.html#lasttofirst [maybe-first]: ../monoids/First.html#maybetofirst [result-first]: ../monoids/First.html#resulttofirst [either-last]: ../monoids/Last.html#eithertolast [first-last]: ../monoids/Last.html#firsttolast [maybe-last]: ../monoids/Last.html#maybetolast [result-last]: ../monoids/Last.html#resulttolast ","srcFilePath":"src/pages/docs/functions/transformation-functions.md","id":"transformation-functions","location":"/docs/functions/transformation-functions.html","url":"/crocks/docs/functions/transformation-functions.html"}},"title":"Functions","description":"functions","layout":"notopic","icon":"code-file","weight":40,"content":" There are (6) function classifications included in this library: Combinators: A collection of functions that are used for working with other functions. These do things like compose (2) functions together, or flip arguments on a function. They typically either take a function, return a function or a bit a both. These are considered the glue that holds the mighty house of crocks together and a valuable aid in writing reusable code. Helper Functions: All other support functions that are either convenient versions of combinators or not even combinators at all cover this group. Logic Functions: A helpful collection of Logic based combinators. All of these functions work with predicate functions and let you combine them in some very interesting ways. Predicate Functions: A helpful collection of predicate functions to get you started. Point-free Functions: Wanna use these ADTs in a way that you never have to reference the actual data being worked on? Well here is where you will find all of these functions to do that. For every algebra available on both the Crocks and Monoids there is a function here. Transformation Functions: All the functions found here are used to transform from one type to another, naturally. These come are handy in situations where you have functions that return one type (like an Either), but are working in a context of another (say Maybe). You would like to compose these, but in doing so will result in a nesting that you will need to account for for the rest of your flow. Combinators | Function | Signature | Location | |:---|:---|:---| | applyto | a - (a - b) - b | crocks/combinators/applyTo | | composeB | (b - c) - (a - b) - a - c | crocks/combinators/composeB | | constant | a - () - a | crocks/combinators/constant | | flip | (a - b - c) - b - a - c | crocks/combinators/flip | | identity | a - a | crocks/combinators/identity | | substitution | (a - b - c) - (a - b) - a - c | crocks/combinators/substitution | Helpers | Function | Signature | Location | |:---|:---|:---| | assign | Object - Object - Object | crocks/helpers/assign | | assoc | String - a - Object - Object | crocks/helpers/assoc | | binary | ((*) - c) - a - b - c | crocks/helpers/binary | | branch | a - Pair a a | crocks/Pair/branch | | compose | ((y - z), ..., (a - b)) - a - z | crocks/helpers/compose | | composeK | Chain m = ((y - m z), ..., (a - m b)) - a - m z | crocks/helpers/composeK | | composeP | Promise p = ((y - p z c), ..., (a - p b c)) - a - p z c | crocks/helpers/composeP | | composeS | Semigroupoid s = (s y z, ..., s a b) - s a z | crocks/helpers/composeS | | curry | ((a, b, ...) - z) - a - b - ... - z | crocks/helpers/curry | | defaultProps | Object - Object - Object | crocks/helpers/defaultProps | | defaultTo | a - b - a | crocks/helpers/defaultTo | | dissoc | String - Object - Object | crocks/helpers/dissoc | | fanout | (a - b) - (a - c) - (a - Pair b c) | crocks/helpers/fanout | | fromPairs | Foldable f = f (Pair String a) - Object | crocks/helpers/fromPairs | | liftA2 | Applicative m = (a - b - c) - m a - m b - m c | crocks/helpers/liftA2 | | liftA3 | Applicative m = (a - b - c - d) - m a - m b - m c - m d | crocks/helpers/liftA3 | | liftN | Applicative m = Number - (() - a) - (m) - m a | crocks/helpers/liftN | | mapProps | Object - Object - Object | crocks/helpers/mapProps | | mapReduce | Foldable f = (a - b) - (c - b - c) - c - f a - c | crocks/helpers/mapReduce | | mconcat | Monoid m, Foldable f = m - f a - m a | crocks/helpers/mconcat | | mconcatMap | Monoid m, Foldable f = m - (b - a) - f b - m a | crocks/helpers/mconcatMap | | mreduce | Monoid m, Foldable f = m - f a - a | crocks/helpers/mreduce | | mreduceMap | Monoid m, Foldable f = m - (b - a) - f b - a | crocks/helpers/mreduceMap | | nAry | Number - (() - a) - () - a | crocks/helpers/nAry | | objOf | String - a - Object | crocks/helpers/objOf | | omit | Foldable f = f String - Object - Object | crocks/helpers/omit | | once | (() - a) - (() - a) | crocks/helpers/once | | partial | ((() - c), *) - () - c | crocks/helpers/partial | | pick | Foldable f = f String - Object - Object | crocks/helpers/pick | | pipe | ((a - b), ..., (y - z)) - a - z | crocks/helpers/pipe | | pipeK | Chain m = ((a - m b), ..., (y - m z)) - a - m z | crocks/helpers/pipeK | | pipeP | Promise p = ((a - p b d), ..., (y - p z d)) - a - p z d | crocks/helpers/pipeP | | pipeS | Semigroupoid s = (s a b, ..., s y z) - s a z | crocks/helpers/pipeS | | prop | (String &#124; Integer) - a - Maybe b | crocks/Maybe/prop | | propOr | a - (String &#124; Integer) - b - c | crocks/helpers/propOr | | propPath | Foldable f = f (String &#124; Integer) - a - Maybe b | crocks/Maybe/propPath | | propPathOr | Foldable f = a - f (String &#124; Integer) - b - c | crocks/helpers/propPathOr | | safe | ((a - Boolean) &#124; Pred) - a - Maybe a | crocks/Maybe/safe | | safeLift | ((a - Boolean) &#124; Pred) - (a - b) - a - Maybe b | crocks/Maybe/safeLift | | tap | (a - b) - a - a | crocks/helpers/tap | | toPairs | Object - List (Pair String a) | crocks/Pair/toPairs | | tryCatch | (a - b) - a - Result e b | crocks/Result/tryCatch | | unary | ((*) - b) - a - b | crocks/helpers/unary | | unit | () - undefined | crocks/helpers/unit | Logic Every function in crocks, that takes a predicate function of the form a - Boolean, can be replaced with a Pred instance of the type: Pred a and vice-versa | Function | Signature | Location | |:---|:---|:---| | and | (a - Boolean) - (a - Boolean) - a - Boolean | crocks/logic/and | | ifElse | (a - Boolean) - (a - b) - (a - b) - a - b | crocks/logic/ifElse | | not | (a - Boolean) - a - Boolean | crocks/logic/not | | or | (a - Boolean) - (a - Boolean) - a - Boolean | crocks/logic/or | | unless | (a - Boolean) - (a - a) - a - a | crocks/logic/unless | | when | (a - Boolean) - (a - a) - a - a | crocks/logic/when | [monoids]: ../monoids/index.html [crocks]: ../crocks/index.html [pred]: ../crocks/Pred.html [applyto]: combinators.htmlapplyto [composeb]: combinators.html#composeb [constant]: combinators.html#constant [flip]: combinators.html#flip [identity]: combinators.html#identity [substitution]: combinators.html#substitution [assign]: helpers.html#assign [assoc]: helpers.html#assoc [binary]: helpers.html#binary [branch]: helpers.html#branch [compose]: helpers.html#compose [composek]: helpers.html#composek [composep]: helpers.html#composep [composes]: helpers.html#composes [curry]: helpers.html#curry [defaultprops]: helpers.html#defaultprops [defaultto]: helpers.html#defaultto [dissoc]: helpers.html#dissoc [fanout]: helpers.html#fanout [frompairs]: helpers.html#frompairs [lifta2]: helpers.html#lifta2 [lifta3]: helpers.html#lifta3 [liftn]: helpers.html#liftn [mapprops]: helpers.html#mapprops [mapreduce]: helpers.html#mapreduce [mconcat]: helpers.html#mconcat [mconcatmap]: helpers.html#mconcatmap [mreduce]: helpers.html#mreduce [mreducemap]: helpers.html#mreducemap [nary]: helpers.html#nary [objof]: helpers.html#objof [omit]: helpers.html#omit [once]: helpers.html#once [partial]: helpers.html#partial [pick]: helpers.html#pick [pipe]: helpers.html#pipe [pipek]: helpers.html#pipek [pipep]: helpers.html#pipep [pipes]: helpers.html#pipes [prop]: ../crocks/Maybe.html#prop [propor]: helpers.html#propor [proppath]: ../crocks/Maybe.html#proppath [proppathor]: helpers.html#proppathor [safe]: ../crocks/Maybe.html#safe [safelift]: ../crocks/Maybe.html#safelift [tap]: helpers.html#tap [topairs]: helpers.html#topairs [trycatch]: helpers.html#trycatch [unary]: helpers.html#unary [unit]: helpers.html#unit [and]: logic-functions.html#and [ifelse]: logic-functions.html#ifelse [not]: logic-functions.html#not [or]: logic-functions.html#or [unless]: logic-functions.html#unless [when]: logic-functions.html#when ","srcFilePath":"src/pages/docs/functions/index.md","id":"functions","location":"/docs/functions/","url":"/crocks/docs/functions/","childIds":["combinators","helpers","logic-functions","predicate-functions","pointfree-functions","transformation-functions"]},"monoids":{"children":{"All":{"title":"All","description":"All Monoid","layout":"guide","weight":10,"content":" All Boolean All is a Monoid that will combine (2) values of any type using logical conjunction (AND) on their coerced Boolean values, mapping truth-y values to true and false-y values to false. const All = require('crocks/All') const mconcat = require('crocks/helpers/mconcat') const trueNum = All(13) const falseNum = All(0) const trueString = All('So true') trueNum.concat(falseNum) //= All false trueNum.concat(trueString) //= All true const allGood = mconcat(All) allGood([ 1, 5, 89 ]) //= All true allGood([ 'nice', '00', null ]) //= All false Implements Semigroup, Monoid Constructor Methods empty All.empty :: () - All empty provides the identity for the Monoid in that when the value it provides is concated to any other value, it will return the other value. In the case of All the result of empty is true. empty is available on both the Constructor and the Instance for convenience. const All = require('crocks/All') All.empty() //= All true All(true).concat(All.empty()) //= All true All(false).concat(All.empty()) //= All false Instance Methods concat All ~ All - All concat is used to combine (2) Semigroups of the same type under an operation specified by the Semigroup. In the case of All, it will combine the (2) using logical AND (conjunction). const All = require('crocks/All') All(true).concat(All(true)) //= All true All(true).concat(All(false)) //= All false All(false).concat(All(true)) //= All false All(false).concat(All(false)) //= All false valueOf All ~ () - Boolean valueOf is used on all crocks Monoids as a means of extraction. While the extraction is available, types that implement valueOf are not necessarily a Comonad. This function is used primarily for convenience for some of the helper functions that ship with crocks. Calling valueOf on an All instance will result in the underlying Boolean value. const All = require('crocks/All') All(0).valueOf() //= false All('string').valueOf() //= true //= false All(true) .concat('') .valueOf() ","srcFilePath":"src/pages/docs/monoids/All.md","id":"All","location":"/docs/monoids/All.html","url":"/crocks/docs/monoids/All.html"},"Any":{"title":"Any","description":"Any Monoid","layout":"guide","weight":20,"content":" Any Boolean Any is a Monoid that will combine (2) values of any type using logical disjunction (OR) on their coerced Boolean values, mapping truth-y values to true and false-y values to false. const Any = require('crocks/Any') const isNumber = require('crocks/predicates/isNumber') const mconcatMap = require('crocks/helpers/mconcat') const trueString = Any('string') const falseString = Any('') const object = Any({ nice: true }) trueString.concat(falseString) //= Any false trueString.concat(object) //= Any true const anyNumber = mconcatMap(Any, isNumber) anyNumber([ 'string', 3 ]) //= Any true anyNumber([ true, 'string' ]) //= Any false Implements Semigroup, Monoid Constructor Methods empty Any.empty :: () - Any empty provides the identity for the Monoid in that when the value it provides is concated to any other value, it will return the other value. In the case of Any the result of empty is false. empty is available on both the Constructor and the Instance for convenience. const Any = require('crocks/Any') Any.empty() //= Any false Any(true).concat(Any.empty()) //= Any true Any(false).concat(Any.empty()) //= Any false Instance Methods concat Any ~ Any - Any concat is used to combine (2) Semigroups of the same type under an operation specified by the Semigroup. In the case of Any, it will combine the (2) using logical OR (disjunction). const Any = require('crocks/Any') Any(true).concat(Any(true)) //= Any true Any(true).concat(Any(false)) //= Any true Any(false).concat(Any(true)) //= Any true Any(false).concat(Any(false)) //= Any false valueOf Any ~ () - Boolean valueOf is used on all crocks Monoids as a means of extraction. While the extraction is available, types that implement valueOf are not necessarily a Comonad. This function is used primarily for convenience for some of the helper functions that ship with crocks. Calling valueOf on an Any instance will result in the underlying Boolean value. const Any = require('crocks/Any') Any(0).valueOf() //= false Any('string').valueOf() //= true //= true Any(45) .concat('') .valueOf() ","srcFilePath":"src/pages/docs/monoids/Any.md","id":"Any","location":"/docs/monoids/Any.html","url":"/crocks/docs/monoids/Any.html"},"Assign":{"title":"Assign","description":"Assign Monoid","layout":"guide","weight":30,"content":" Assign Object Assign is a Monoid that will combine (2) objects under assignment using Object.assign on the (2) Objects. const Assign = require('crocks/Assign') const first = { name: 'Bob' } const last = { lastName: 'Smith' } Assign(first) .concat(Assign(last)) //= Assign { name: 'Bob', lastName: 'Smith' } Implements Semigroup, Monoid Constructor Methods empty Assign.empty :: () - Assign empty provides the identity for the Monoid in that when the value it provides is concated to object other value, it will return the other value. In the case of Assign the result of empty is an empty Object. empty is available on both the Constructor and the Instance for convenience. const Assign = require('crocks/Assign') Assign.empty() //= Assign {} Assign({}) .concat(Assign.empty()) //= Assign {} Assign({ a: 1 }) .concat(Assign.empty()) //= Assign { a: 1 } Instance Methods concat Assign ~ Assign - Assign concat is used to combine (2) Semigroups of the same type under an operation specified by the Semigroup. In the case of Assign, it will combine (2) objects, overwriting the first Object's previous values with the values of the second Object. const Assign = require('crocks/Assign') Assign({}) .concat(Assign({})) //= Assign {} Assign({ a: 1 }) .concat(Assign({ b: 2 })) //= Assign { a: 1, b: 2 } Assign({ a: 1, b: 2 }) .concat(Assign({ a: 3, b: 4 })) //= Assign { a: 3, b: 4 } Assign({ b: 4 }) .concat(Assign({ a: 1 })) //= Assign { b: 4, a: 1 } valueOf Assign ~ () - Object valueOf is used on all crocks Monoids as a means of extraction. While the extraction is available, types that implement valueOf are not necessarily a Comonad. This function is used primarily for convenience for some of the helper functions that ship with crocks. Calling valueOf on an Assign instance will result in the underlying Object. const Assign = require('crocks/Assign') Assign({}) .valueOf() //= {} Assign({ a: 1 }) .valueOf() //= { a: 1 } Assign({ a: 1 }) .concat({ b: 25 }) .valueOf() //= { a: 1, b: 25 } ","srcFilePath":"src/pages/docs/monoids/Assign.md","id":"Assign","location":"/docs/monoids/Assign.html","url":"/crocks/docs/monoids/Assign.html"},"Endo":{"title":"Endo","description":"Endo Monoid","layout":"guide","weight":40,"content":" Endo a Endo is a Monoid that will combine (2) functions that have matching domains and codomains (endofunctions) under function composition. Due to the nature of Endo wrapping a function, the underlying value can either be extracted using valueOf like any other Monoid or can be executed directly using runWith, supplying the input. const Endo = require('crocks/Endo') const curry = require('crocks/helpers/curry') const mconcat = require('crocks/helpers/mconcat') const valueOf = require('crocks/pointfree/valueOf') // add :: Number - Number - Number const add = x = y = x + y // multiply :: Number - Number - Number const multiply = x = y = x * y // runEndo :: Endo a - a - a const runEndo = curry(valueOf) // flow :: Endo Number const addAndDouble = Endo(add(10)) .concat(Endo(multiply(2))) // always10 :: Endo Number const always10 = mconcat(Endo, [ add(100), multiply(0), add(10) ]) runEndo(addAndDouble, 5) //= 30 always10 .runWith(75) //= 10 Implements Semigroup, Monoid Constructor Methods empty Endo.empty :: () - Endo a empty provides the identity for the Monoid in that when the value it provides is concated to any other value, it will return the other value. In the case of Endo the result of empty is the identity function, which echos its input. empty is available on both the Constructor and the Instance for convenience. const Endo = require('crocks/Endo') const runWith = require('crocks/pointfree/runWith') // empty :: Endo a const empty = Endo.empty() // toUpper :: Endo String const toUpper = Endo(x = x.toUpperCase()) // runNice :: Endo String - String const runNice = runWith('nice') runNice(empty.concat(toUpper)) //= \"NICE\" runNice(toUpper.concat(empty)) //= \"NICE\" Instance Methods concat Endo a ~ Endo a - Endo a concat is used to combine (2) Semigroups of the same type under an operation specified by the Semigroup. In the case of Endo, it will combine (2) endofunctions under function composition. const Endo = require('crocks/Endo') const assoc = require('crocks/helpers/assoc') const mapProps = require('crocks/helpers/mapProps') const objOf = require('crocks/helpers/objOf') // inc :: Number - Number const inc = x = x + 1 // incValue :: Endo Object const incValue = Endo(mapProps({ value: inc })) // addDone :: Endo Object const addDone = Endo(assoc('done', true)) // finish :: Endo Object const packResults = Endo(objOf('results')) // finish :: Endo Object const finish = incValue.concat(addDone) finish.runWith({ value: 99 }) //= { value: 100, done: true } finish .concat(packResults) .runWith({ value: 99 }) //= { results: { value: 100, done: true } } valueOf Endo a ~ () - (a - a) valueOf is used on all crocks Monoids as a means of extraction. While the extraction is available, types that implement valueOf are not necessarily a Comonad. This function is used primarily for convenience for some of the helper functions that ship with crocks. Calling valueOf on an Endo instance will result in the underlying endofunction. const Endo = require('crocks/Endo') const filter = require('crocks/pointfree/filter') const map = require('crocks/pointfree/map') const mconcat = require('crocks/helpers/mconcat') // lt10 :: [ Number ] - [ Number ] const lt10 = filter(x = x < 10) // double :: [ Number ] - [ Number ] const double = map(x = x * 2) // buildEndo :: [ (a - a) ] - Endo a const buildEndo = mconcat(Endo) // fn :: [ Number ] - [ Number ] const fn = buildEndo([ lt10, double ]) .valueOf() fn([ 12, 5, 3, 90 ]) //= [ 10, 6 ] fn([]) //= [] runWith Endo a ~ a - a Endo wraps a function and as such, its underlying endofunction can be run while inside of an Endo by calling runWith. Providing a valid value of the same type required by the function, runWith will execute the underlying function and return the result. const Endo = require('crocks/Endo') const filter = require('crocks/pointfree/filter') const map = require('crocks/pointfree/map') const mconcat = require('crocks/helpers/mconcat') // lt10 :: [ Number ] - [ Number ] const lt10 = filter(x = x < 10) // double :: [ Number ] - [ Number ] const double = map(x = x * 2) // buildEndo :: [ (a - a) ] - Endo a const flow = mconcat(Endo, [ lt10, double ]) flow .runWith([ 12, 5, 3, 90 ]) //= [ 10, 6 ] flow .runWith([]) //= [] ","srcFilePath":"src/pages/docs/monoids/Endo.md","id":"Endo","location":"/docs/monoids/Endo.html","url":"/crocks/docs/monoids/Endo.html"},"First":{"title":"First","description":"First Monoid","layout":"guide","weight":50,"content":" First a = First (Maybe a) First is a Monoid that will always return the first, non-empty value when (2) First instances are combined. First is able to be a Monoid because it implements a Maybe under the hood. The use of the Maybe allows for an empty First to be represented with a Nothing. First can be constructed with either a value or a Maybe instance. Any value passed to the constructor will be wrapped in a Just to represent a non-empty instance of First. Any Maybe passed to the constructor will be lifted as is, allowing the ability to \"choose\" a value based on some disjunction. While most Monoids only provide a valueOf function used for extraction, First takes advantage of its underlying Maybe to provide an additional option method. Using valueOf will extract the underlying Maybe, while option will extract the underlying value in theMaybe, using the provided default value when the underlying Maybe is a Nothing instance. const First = require('crocks/First') const and = require('crocks/logic/and') const isNumber = require('crocks/predicates/isNumber') const mconcatMap = require('crocks/helpers/mconcatMap') const safe = require('crocks/Maybe/safe') // isEven :: Number - Boolean const isEven = x = !(x % 2) // isValid :: a - Boolean const isValid = and(isNumber, isEven) // chooseFirst :: [ * ] - First Number const chooseFirst = mconcatMap(First, safe(isValid)) chooseFirst([ 21, 45, 2, 22, 19 ]) .valueOf() //= Just 2 chooseFirst([ 'a', 'b', 'c' ]) .option('') //= \"\" Implements Semigroup, Monoid Constructor Methods empty First.empty :: () - First a empty provides the identity for the Monoid in that when the value it provides is concated to any other value, it will return the other value. In the case of First the result of empty is Nothing. empty is available on both the Constructor and the Instance for convenience. const First = require('crocks/First') const { empty } = First First.empty() //= First( Nothing ) First(3) .concat(empty()) //= First( Just 3 ) empty() .concat(First(3)) //= First( Just 3 ) Instance Methods concat First a ~ First a - First a concat is used to combine (2) Semigroups of the same type under an operation specified by the Semigroup. In the case of First, it will always provide the first non-empty value. Any subsequent non-empty values will be thrown away and will always result in the first non-empty value. const First = require('crocks/First') const concat = require('crocks/pointfree/concat') const a = First('a') const b = First('b') const c = First('c') a.concat(b) //= First( Just \"a\" ) b.concat(a) //= First( Just \"b\" ) concat(c, concat(b, a)) //= First( Just \"a\" ) concat(concat(c, b), a) //= First( Just \"a\" ) concat(concat(a, b), c) //= First( Just \"c\" ) option First a ~ a - a First wraps an underlying Maybe which provides the ability to option out a value in the case of an empty instance. Just like option on a Maybe instance, it takes a value as its argument. When run on an empty instance, the provided default will be returned. If option is run on a non-empty instance however, the wrapped value will be extracted not only from the First but also from the underlying Just. If the underlying Maybe is desired, the valueOf method can be used and will return the Maybe instead. const First = require('crocks/First') const compose = require('crocks/helpers/compose') const chain = require('crocks/pointfree/chain') const isString = require('crocks/predicates/isString') const mconcatMap = require('crocks/helpers/mconcatMap') const prop = require('crocks/Maybe/prop') const safe = require('crocks/Maybe/safe') // stringVal :: a - Maybe String const stringVal = compose( chain(safe(isString)), prop('val') ) // firstValid :: [ a ] - First String const firstValid = mconcatMap(First, stringVal) // good :: [ Object ] const good = [ { val: 23 }, { val: 'string' }, { val: '23' } ] // bad :: [ Object ] const bad = [ { val: 23 }, { val: null }, {} ] firstValid(good) .option('') //= \"string\" firstValid(bad) .option('') //= \"\" valueOf First a ~ () - Maybe a valueOf is used on all crocks Monoids as a means of extraction. While the extraction is available, types that implement valueOf are not necessarily a Comonad. This function is used primarily for convenience for some of the helper functions that ship with crocks. Calling valueOf on a First instance will result in the underlying Maybe. const First = require('crocks/First') const { Nothing } = require('crocks/Maybe') const valueOf = require('crocks/pointfree/valueOf') valueOf(First(56)) //= Just 56 valueOf(First.empty()) //= Nothing First(37) .concat(First(99)) .valueOf() //= Just 37 First(Nothing()) .concat(First.empty()) .valueOf() //= Nothing Transformation Functions eitherToFirst crocks/First/eitherToFirst eitherToFirst :: Either b a - First a eitherToFirst :: (a - Either c b) - a - First b Used to transform a given Either instance to a First instance, eitherToFirst will turn a Right instance into a non-empty First, wrapping the original value contained in the Right. All Left instances will map to an empty First, mapping the originally contained value to a Unit. Values on the Left will be lost and as such this transformation is considered lossy in that regard. Like all crocks transformation functions, eitherToFirst has (2) possible signatures and will behave differently when passed either an Either instance or a function that returns an instance of Either. When passed the instance, a transformed First is returned. When passed an Either returning function, a function will be returned that takes a given value and returns a First. const First = require('crocks/First') const { Left, Right } = require('crocks/Either') const eitherToFirst = require('crocks/First/eitherToFirst') const concat = require('crocks/pointfree/concat') const constant = require('crocks/combinators/constant') const flip = require('crocks/combinators/flip') const ifElse = require('crocks/logic/ifElse') const isNumber = require('crocks/predicates/isNumber') const mapReduce = require('crocks/helpers/mapReduce') // someNumber :: a - Either String Number const someNumber = ifElse( isNumber, Right, constant(Left('Nope')) ) // firstNumber :: [ a ] - First Number const firstNumber = mapReduce( eitherToFirst(someNumber), flip(concat), First.empty() ) // \"Bad Times\" is lost, mapped to Nothing eitherToFirst(Left('Bad Times')) //= First( Nothing ) eitherToFirst(Right('correct')) //= First( Just \"correct\" ) firstNumber([ 'string', null, 34, 76 ]) //= First( Just 34 ) firstNumber([ 'string', null, true ]) //= First( Nothing ) lastToFirst crocks/First/lastToFirst lastToFirst :: Last a - First a lastToFirst :: (a - Last b) - a - First b Used to transform a given Last instance to a First instance, lastToFirst will turn a non-empty instance into a non-empty First wrapping the original value contained within the Last. All empty instances will map to an empty First. Like all crocks transformation functions, lastToFirst has (2) possible signatures and will behave differently when passed either a Last instance or a function that returns an instance of Last. When passed the instance, a transformed First is returned. When passed a Last returning function, a function will be returned that takes a given value and returns a First. const First = require('crocks/First') const Last = require('crocks/Last') const lastToFirst = require('crocks/First/lastToFirst') const isString = require('crocks/predicates/isString') const mconcatMap = require('crocks/helpers/mconcatMap') const safe = require('crocks/Maybe/safe') // lastString :: [ a ] - Last String const lastString = mconcatMap(Last, safe(isString)) // fixLastString :: [ a ] - First String const fixLastString = lastToFirst(lastString) lastToFirst(Last.empty()) //= First( Nothing ) lastToFirst(Last(false)) //= First( Just false ) fixLastString([ 'one', 2, 'Three', 4 ]) .concat(First('another string')) //= First( Just \"Three\" ) fixLastString([ 1, 2, 3, 4 ]) .concat(First('First String')) //= First( Just \"First String\" ) maybeToFirst crocks/First/maybeToFirst maybeToFirst :: Maybe a - First a maybeToFirst :: (a - Maybe b) - a - First b Used to transform a given Maybe instance to a First instance, maybeToFirst will turn a Just into a non-empty First instance, wrapping the original value contained within the First. All Nothing instances will map to an empty First instance. This function is available mostly for completion sake, as First can always take a Maybe as its argument during construction. So while there is not a real need for this to be used for transforming instances, it can come in handy for lifting Maybe returning functions. Like all crocks transformation functions, maybeToFirst has (2) possible signatures and will behave differently when passed either a Maybe instance or a function that returns an instance of Maybe. When passed the instance, a transformed First is returned. When passed a Maybe returning function, a function will be returned that takes a given value and returns a First. const First = require('crocks/First') const { Nothing, Just } = require('crocks/Maybe') const maybeToFirst = require('crocks/First/maybeToFirst') const chain = require('crocks/pointfree/chain') const compose = require('crocks/helpers/compose') const isNumber = require('crocks/predicates/isNumber') const prop = require('crocks/Maybe/prop') const safe = require('crocks/Maybe/safe') // numVal :: a - Maybe Number const numVal = compose( chain(safe(isNumber)), prop('val') ) // firstNumVal :: a - First Number const firstNumVal = maybeToFirst(numVal) maybeToFirst(Just(99)) //= First( Just 99 ) maybeToFirst(Nothing()) //= First( Nothing ) First(Just(99)) //= First( Just 99 ) First(Nothing()) //= First( Nothing ) firstNumVal({ val: 97 }) .concat(First(80)) //= First( Just 97 ) firstNumVal({ val: '97' }) .concat(First(80)) //= First( Just 80 ) firstNumVal(null) .concat(First(80)) //= First( Just 80 ) resultToFirst crocks/First/resultToFirst resultToFirst :: Result e a - First a resultToFirst :: (a - Result e b) - a - First b Used to transform a given Result instance to a First instance, resultToFirst will turn an Ok instance into a non-empty First, wrapping the original value contained in the Ok. All Err instances will map to an empty First, mapping the originally contained value to a Unit. Values on the Err will be lost and as such this transformation is considered lossy in that regard. Like all crocks transformation functions, resultToFirst has (2) possible signatures and will behave differently when passed either an Result instance or a function that returns an instance of Result. When passed the instance, a transformed First is returned. When passed a Result returning function, a function will be returned that takes a given value and returns a First. const First = require('crocks/First') const { Err, Ok } = require('crocks/Result') const resultToFirst = require('crocks/First/resultToFirst') const isNumber = require('crocks/predicates/isNumber') const tryCatch = require('crocks/Result/tryCatch') function onlyNums(x) { if(!isNumber(x)) { throw new Error('something amiss') } return x } // firstNum :: a - First Number const firstNum = resultToFirst(tryCatch(onlyNums)) // \"this is bad\" is lost, mapped to Nothing resultToFirst(Err('this is bad')) //= First( Nothing ) resultToFirst(Ok('this is great')) //= First( Just \"this is great\" ) firstNum(90) .concat(First(0)) //= First( Just 90 ) firstNum(null) .concat(First(0)) //= First( Just 0 ) [just]: ../crocks/Maybe.html#just [maybe]: ../crocks/Maybe.html [nothing]: ../crocks/Maybe.html#nothing [option]: ../crocks/Maybe.html#option ","srcFilePath":"src/pages/docs/monoids/First.md","id":"First","location":"/docs/monoids/First.html","url":"/crocks/docs/monoids/First.html"},"Last":{"title":"Last","description":"Last Monoid","layout":"guide","weight":60,"content":" Last a = Last (Maybe a) Last is a Monoid that will always return the last, non-empty value when (2) Last instances are combined. Last is able to be a Monoid because it implements a Maybe under the hood. The use of the Maybe allows for an empty Last to be represented with a Nothing. Last can be constructed with either a value or a Maybe instance. Any value passed to the constructor will be wrapped in a Just to represent a non-empty instance of Last. Any Maybe passed to the constructor will be lifted as is, allowing the ability to \"choose\" a value based on some disjunction. While most Monoids only provide a valueOf function used for extraction, Last takes advantage of its underlying Maybe to provide an additional option method. Using valueOf will extract the underlying Maybe, while option will extract the underlying value in the Maybe, using the provided default value when the underlying Maybe is a Nothing instance. const Last = require('crocks/Last') const and = require('crocks/logic/and') const isNumber = require('crocks/predicates/isNumber') const mconcatMap = require('crocks/helpers/mconcatMap') const safe = require('crocks/Maybe/safe') // isEven :: Number - Boolean const isEven = x = x % 2 === 0 // isValid :: a - Boolean const isValid = and(isNumber, isEven) // chooseLast :: [ * ] - Last Number const chooseLast = mconcatMap(Last, safe(isValid)) chooseLast([ 21, 45, 2, 22, 19 ]) .valueOf() //= Just 22 chooseLast([ 'a', 'b', 'c' ]) .option('') //= \"\" Implements Semigroup, Monoid Constructor Methods empty Last.empty :: () - Last a empty provides the identity for the Monoid in that when the value it provides is concated to any other value, it will return the other value. In the case of Last the result of empty is Nothing. empty is available on both the Constructor and the Instance for convenience. const Last = require('crocks/Last') const { empty } = Last empty() //= Last( Nothing ) Last(3) .concat(empty()) //= Last( Just 3 ) empty() .concat(Last(3)) //= Last( Just 3 ) Instance Methods concat Last a ~ Last a - Last a concat is used to combine (2) Semigroups of the same type under an operation specified by the Semigroup. In the case of Last, it will always provide the last non-empty value. All previous non-empty values will be thrown away and will always result in the last non-empty value. const Last = require('crocks/Last') const concat = require('crocks/pointfree/concat') const a = Last('a') const b = Last('b') const c = Last('c') a.concat(b) //= Last( Just \"b\" ) b.concat(a) //= Last( Just \"a\" ) concat(c, concat(b, a)) //= Last( Just \"c\" ) concat(concat(c, b), a) //= Last( Just \"c\" ) concat(concat(a, b), c) //= Last( Just \"a\" ) option Last a ~ a - a Last wraps an underlying Maybe which provides the ability to option out a value in the case of an empty instance. Just like option on a Maybe instance, it takes a value as its argument. When run on an empty instance, the provided default will be returned. If option is run on a non-empty instance however, the wrapped value will be extracted not only from the Last but also from the underlying Just. If the underlying Maybe is desired, the valueOf method can be used and will return the Maybe instead. const Last = require('crocks/Last') const compose = require('crocks/helpers/compose') const chain = require('crocks/pointfree/chain') const isString = require('crocks/predicates/isString') const mconcatMap = require('crocks/helpers/mconcatMap') const prop = require('crocks/Maybe/prop') const safe = require('crocks/Maybe/safe') // stringVal :: a - Maybe String const stringVal = compose( chain(safe(isString)), prop('val') ) // lastValid :: [ a ] - Last String const lastValid = mconcatMap(Last, stringVal) // good :: [ Object ] const good = [ { val: 23 }, { val: 'string' }, { val: '23' } ] // bad :: [ Object ] const bad = [ { val: 23 }, { val: null }, {} ] lastValid(good) .option('') //= \"23\" lastValid(bad) .option('') //= \"\" valueOf Last a ~ () - Maybe a valueOf is used on all crocks Monoids as a means of extraction. While the extraction is available, types that implement valueOf are not necessarily a Comonad. This function is used primarily for convenience for some of the helper functions that ship with crocks. Calling valueOf on a Last instance will result in the underlying Maybe. const Last = require('crocks/Last') const { Nothing } = require('crocks/Maybe') const valueOf = require('crocks/pointfree/valueOf') valueOf(Last(56)) //= Just 56 valueOf(Last.empty()) //= Nothing Last(37) .concat(Last(99)) .valueOf() //= Just 99 Last(Nothing()) .concat(Last.empty()) .valueOf() //= Nothing Transformation Functions eitherToLast crocks/Last/eitherToLast eitherToLast :: Either b a - Last a eitherToLast :: (a - Either c b) - a - Last b Used to transform a given Either instance to a Last instance, eitherToLast will turn a Right instance into a non-empty Last, wrapping the original value contained in the Right. All Left instances will map to an empty Last, mapping the originally contained value to a Unit. Values on the Left will be lost and as such this transformation is considered lossy in that regard. Like all crocks transformation functions, eitherToLast has (2) possible signatures and will behave differently when passed either an Either instance or a function that returns an instance of Either. When passed the instance, a transformed Last is returned. When passed an Either returning function, a function will be returned that takes a given value and returns a Last. const Last = require('crocks/Last') const { Left, Right } = require('crocks/Either') const eitherToLast = require('crocks/Last/eitherToLast') const concat = require('crocks/pointfree/concat') const constant = require('crocks/combinators/constant') const flip = require('crocks/combinators/flip') const ifElse = require('crocks/logic/ifElse') const isNumber = require('crocks/predicates/isNumber') const mapReduce = require('crocks/helpers/mapReduce') // someNumber :: a - Either String Number const someNumber = ifElse( isNumber, Right, constant(Left('Nope')) ) // lastNumber :: [ a ] - Last Number const lastNumber = mapReduce( eitherToLast(someNumber), flip(concat), Last.empty() ) // \"Bad Times\" is lost, mapped to Nothing eitherToLast(Left('Bad Times')) //= Last( Nothing ) eitherToLast(Right('correct')) //= Last( Just \"correct\" ) lastNumber([ 'string', null, 34, 76 ]) //= Last( Just 76 ) lastNumber([ 'string', null, true ]) //= Last( Nothing ) firstToLast crocks/Last/firstToLast firstToLast :: First a - Last a firstToLast :: (a - First b) - a - Last b Used to transform a given First instance to a Last instance, firstToLast will turn a non-empty instance into a non-empty Last wrapping the original value contained within the First. All empty instances will map to an empty Last. Like all crocks transformation functions, firstToLast has (2) possible signatures and will behave differently when passed either a First instance or a function that returns an instance of First. When passed the instance, a transformed Last is returned. When passed a First returning function, a function will be returned that takes a given value and returns a Last. const Last = require('crocks/Last') const First = require('crocks/First') const firstToLast = require('crocks/Last/firstToLast') const isString = require('crocks/predicates/isString') const mconcatMap = require('crocks/helpers/mconcatMap') const safe = require('crocks/Maybe/safe') // firstString :: [ a ] - First String const firstString = mconcatMap(First, safe(isString)) // unfixFirstString :: [ a ] - Last String const unfixFirstString = firstToLast(firstString) firstToLast(First.empty()) //= Last( Nothing ) firstToLast(First(false)) //= Last( Just false ) unfixFirstString([ 'one', 2, 'Three', 4 ]) //= Last( Just \"one\" ) unfixFirstString([ 'one', 2, 'Three', 4 ]) .concat(Last('another string')) //= Last( Just \"another string\" ) unfixFirstString([ 1, 2, 3, 4 ]) .concat(Last('Last String')) //= Last( Just \"Last String\" ) maybeToLast crocks/Last/maybeToLast maybeToLast :: Maybe a - Last a maybeToLast :: (a - Maybe b) - a - Last b Used to transform a given Maybe instance to a Last instance, maybeToLast will turn a Just into a non-empty Last instance, wrapping the original value contained within the Last. All Nothing instances will map to an empty Last instance. This function is available mostly for completion sake, as Last can always take a Maybe as its argument during construction. So while there is not a real need for this to be used for transforming instances, it can come in handy for lifting Maybe returning functions. Like all crocks transformation functions, maybeToLast has (2) possible signatures and will behave differently when passed either a Maybe instance or a function that returns an instance of Maybe. When passed the instance, a transformed Last is returned. When passed a Maybe returning function, a function will be returned that takes a given value and returns a Last. const Last = require('crocks/Last') const { Nothing, Just } = require('crocks/Maybe') const maybeToLast = require('crocks/Last/maybeToLast') const chain = require('crocks/pointfree/chain') const compose = require('crocks/helpers/compose') const isNumber = require('crocks/predicates/isNumber') const prop = require('crocks/Maybe/prop') const safe = require('crocks/Maybe/safe') // numVal :: a - Maybe Number const numVal = compose( chain(safe(isNumber)), prop('val') ) // lastNumVal :: a - Last Number const lastNumVal = maybeToLast(numVal) maybeToLast(Just(99)) //= Last( Just 99 ) maybeToLast(Nothing()) //= Last( Nothing ) Last(Just(99)) //= Last( Just 99 ) Last(Nothing()) //= Last( Nothing ) Last(Just(80)) .concat(lastNumVal({ val: 97 })) //= Last( Just 97 ) lastNumVal({ val: 97 }) .concat(Last(80)) //= Last( Just 80 ) lastNumVal(null) .concat(Last(80)) //= Last( Just 80 ) resultToLast crocks/Last/resultToLast resultToLast :: Result e a - Last a resultToLast :: (a - Result e b) - a - Last b Used to transform a given Result instance to a Last instance, resultToLast will turn an Ok instance into a non-empty Last, wrapping the original value contained in the Ok. All Err instances will map to an empty Last, mapping the originally contained value to a Unit. Values on the Err will be lost and as such this transformation is considered lossy in that regard. Like all crocks transformation functions, resultToLast has (2) possible signatures and will behave differently when passed either an Result instance or a function that returns an instance of Result. When passed the instance, a transformed Last is returned. When passed a Result returning function, a function will be returned that takes a given value and returns a Last. const Last = require('crocks/Last') const { Err, Ok } = require('crocks/Result') const resultToLast = require('crocks/Last/resultToLast') const isNumber = require('crocks/predicates/isNumber') const tryCatch = require('crocks/Result/tryCatch') function onlyNums(x) { if(!isNumber(x)) { throw new Error('something amiss') } return x } // lastNum :: a - Last Number const lastNum = resultToLast(tryCatch(onlyNums)) // \"this is bad\" is lost, mapped to Nothing resultToLast(Err('this is bad')) //= Last( Nothing ) resultToLast(Ok('this is great')) //= Last( Just \"this is great\" ) lastNum(90) .concat(Last(0)) //= Last( Just 0 ) lastNum(null) .concat(Last(0)) //= Last( Just 0 ) [just]: ../crocks/Maybe.html#just [maybe]: ../crocks/Maybe.html [nothing]: ../crocks/Maybe.html#nothing [option]: ../crocks/Maybe.html#option ","srcFilePath":"src/pages/docs/monoids/Last.md","id":"Last","location":"/docs/monoids/Last.html","url":"/crocks/docs/monoids/Last.html"},"Max":{"title":"Max","description":"Max Monoid","layout":"guide","weight":70,"content":" Max Number Max is a Monoid that will combines (2) Numbers, resulting in the largest of the two. const Max = require('crocks/Max') const mconcat = require('crocks/helpers/mconcat') Max(76) //= Max 76 mconcat(Max, [ 95, 102, 56 ]) //= Max 102 Max(100) .concat(Max(10)) //= Max 100 Max.empty() .concat(Max(100)) //= Max 100 Implements Semigroup, Monoid Constructor Methods empty Max.empty :: () - Max empty provides the identity for the Monoid in that when the value it provides is concated to any other value, it will return the other value. In the case of Max the result of empty is -Infinity. empty is available on both the Constructor and the Instance for convenience. const Max = require('crocks/Max') Max.empty() //= Max -Infinity Max.empty() .concat(Max.empty()) //= Max -Infinity Max(32) .concat(Max.empty()) //= Max 32 Max.empty() .concat(Max(34)) //= Max 34 Instance Methods concat Max ~ Max - Max concat is used to combine (2) Semigroups of the same type under an operation specified by the Semigroup. In the case of Max, it will result in the largest of the (2) Numbers. const Max = require('crocks/Max') Max(23) .concat(Max(13)) //= Max 23 Max(-23) .concat(Max(-32)) //= Max -23 Max.empty() .concat(Max(Infinity)) //= Max Infinity valueOf Max ~ () - Number valueOf is used on all crocks Monoids as a means of extraction. While the extraction is available, types that implement valueOf are not necessarily a Comonad. This function is used primarily for convenience for some of the helper functions that ship with crocks. Calling valueOf on a Max instance will result in the underlying Number. const Max = require('crocks/Max') Max(4) .valueOf() //= 4 Max.empty() .valueOf() //= -Infinity Max(34) .concat(Max(21)) .valueOf() //= 34 ","srcFilePath":"src/pages/docs/monoids/Max.md","id":"Max","location":"/docs/monoids/Max.html","url":"/crocks/docs/monoids/Max.html"},"Min":{"title":"Min","description":"Min Monoid","layout":"guide","weight":80,"content":" Min Number Min is a Monoid that will combines (2) Numbers, resulting in the smallest of the two. const Min = require('crocks/Min') const mconcat = require('crocks/helpers/mconcat') Min(76) //= Min 76 mconcat(Min, [ 95, 12, 56 ]) //= Min 12 Min(100) .concat(Min(10)) //= Min 10 Min.empty() .concat(Min(100)) //= Min 100 Implements Semigroup, Monoid Constructor Methods empty Min.empty :: () - Min empty provides the identity for the Monoid in that when the value it provides is concated to any other value, it will return the other value. In the case of Min the result of empty is Infinity. empty is available on both the Constructor and the Instance for convenience. const Min = require('crocks/Min') Min.empty() //= Min Infinity Min.empty() .concat(Min.empty()) //= Min Infinity Min(32) .concat(Min.empty()) //= Min 32 Min.empty() .concat(Min(34)) //= Min 34 Instance Methods concat Min ~ Min - Min concat is used to combine (2) Semigroups of the same type under an operation specified by the Semigroup. In the case of Min, it will result in the smallest of the (2) Numbers. const Min = require('crocks/Min') Min(50) .concat(Min(24)) //= Min 24 Min(-120) .concat(Min(-50)) //= Min -120 Min.empty() .concat(Min(-Infinity)) //= Min -Infinity valueOf Min ~ () - Number valueOf is used on all crocks Monoids as a means of extraction. While the extraction is available, types that implement valueOf are not necessarily a Comonad. This function is used primarily for convenience for some of the helper functions that ship with crocks. Calling valueOf on a Min instance will result in the underlying Number. const Min = require('crocks/Min') Min(33) .valueOf() //= 33 Min.empty() .valueOf() //= Infinity Min(35) .concat(Min(20)) .valueOf() //= 20 ","srcFilePath":"src/pages/docs/monoids/Min.md","id":"Min","location":"/docs/monoids/Min.html","url":"/crocks/docs/monoids/Min.html"},"Prod":{"title":"Prod","description":"Prod Monoid","layout":"guide","weight":90,"content":" Prod Number Prod is a Monoid that will combine (2) Numbers under multiplication. const Prod = require('crocks/Prod') const compose = require('crocks/helpers/compose') const concat = require('crocks/pointfree/concat') const emptyProd = Prod.empty() const tenProd = Prod(10) const hundredProd = Prod(100) emptyProd .concat(emptyProd) //= Prod 1 tenProd .concat(hundredProd) //= Prod 1000 // prodBy2 :: Number - Prod const double = compose(concat(Prod(2)), Prod) double(4) //= Prod 8 double(11) //= Prod 22 Implements Semigroup, Monoid Constructor Methods empty Prod.empty :: () - Prod empty provides the identity for the Monoid in that when the value it provides is concated to object other value, it will return the other value. In the case of Prod the result of empty is 1. empty is available on both the Constructor and the Instance for convenience. const Prod = require('crocks/Prod') Prod.empty() //= Prod 1 Prod.empty() .concat(Prod.empty()) //= Prod 1 Prod(4) .concat(Prod.empty()) //= Prod 4 Prod.empty() .concat(Prod(4)) //= Prod 4 Instance Methods concat Prod ~ Prod - Prod concat is used to combine (2) Semigroups of the same type under an operation specified by the Semigroup. In the case of Prod, concat will multiply the (2) Numbers. const Prod = require('crocks/Prod') Prod(5) .concat(Prod(4)) //= Prod 20 Prod(45) .concat(Prod(32)) //= Prod 1440 Prod(1000) .concat(Prod(Infinity)) //= Prod Infinity Prod.empty() .concat(Prod(3)) //= Prod 3 valueOf Prod ~ () - Number valueOf is used on all crocks Monoids as a means of extraction. While the extraction is available, types that implement valueOf are not necessarily a Comonad. This function is used primarily for convenience for some of the helper functions that ship with crocks. Calling valueOf on a Prod instance will result in the underlying Number. const Prod = require('crocks/Prod') Prod.empty() .valueOf() //= 1 Prod(4) .valueOf() //= 4 Prod(34) .concat(Prod(21)) .valueOf() //= 714 ","srcFilePath":"src/pages/docs/monoids/Prod.md","id":"Prod","location":"/docs/monoids/Prod.html","url":"/crocks/docs/monoids/Prod.html"},"Sum":{"title":"Sum","description":"Sum Monoid","layout":"guide","weight":100,"content":" Sum Number Sum is a Monoid that will combine (2) Numbers under addition. const Sum = require('crocks/Sum') const mconcat = require('crocks/helpers/mconcat') const mconcatMap = require('crocks/helpers/mconcatMap') Sum(13) //= Sum 13 mconcat(Sum, [ 5, 2 ]) //= Sum 7 Sum(10) .concat(Sum(10)) //= Sum 20 // sumByTen :: [ Number ] - Sum const sumByTen = mconcatMap(Sum, x = x * 10) sumByTen([ 2, 2 ]) //= Sum 40 Implements Semigroup, Monoid Constructor Methods empty Sum.empty :: () - Sum empty provides the identity for the Monoid in that when the value it provides is concated to any other value, it will return the other value. In the case of Sum the result of empty is 0. empty is available on both the Constructor and the Instance for convenience. const Sum = require('crocks/Sum') Sum.empty() //= Sum 0 Sum.empty() .concat(Sum.empty()) //= Sum 0 Sum(4) .concat(Sum.empty()) //= Sum 4 Sum.empty() .concat(Sum(4)) //= Sum 4 Instance Methods concat Sum ~ Sum - Sum concat is used to combine (2) Semigroups of the same type under an operation specified by the Semigroup. In the case of Sum, it will add the (2) Numbers. const Sum = require('crocks/Sum') Sum(5) .concat(Sum(4)) //= Sum 9 Sum(45) .concat(Sum(32)) //= Sum 77 Sum(1000) .concat(Sum(Infinity)) //= Sum Infinity Sum(1) .concat(Sum(3)) //= Sum 4 valueOf Sum ~ () - Number valueOf is used on all crocks Monoids as a means of extraction. While the extraction is available, types that implement valueOf are not necessarily a Comonad. This function is used primarily for convenience for some of the helper functions that ship with crocks. Calling valueOf on a Sum instance will result in the underlying Number. const Sum = require('crocks/Sum') Sum(4) .valueOf() //= 4 Sum.empty() .valueOf() //= 0 Sum(34) .concat(Sum(21)) .valueOf() //= 55 ","srcFilePath":"src/pages/docs/monoids/Sum.md","id":"Sum","location":"/docs/monoids/Sum.html","url":"/crocks/docs/monoids/Sum.html"}},"title":"Monoids","description":"Monoids API","layout":"notopic","icon":"code-file","weight":3,"content":" Each Monoid provides a means to represent a binary operation and is usually locked down to a specific type. These are great when you need to combine a list of values down to one value. In this library, any ADT that provides both an empty and a concat function can be used as a Monoid. There are a few of the crocks that are also monoidial, so be on the look out for those as well. All Monoids work with the following helper functions mconcat, mreduce, mconcatMap and mreduceMap. All Monoids provide empty functions on their Constructors as well as the following Instance Functions: valueOf, empty and concat. | Monoid | Type | Operation | Empty (Identity) | |---|---|---|---| | All | Boolean | Logical AND | true | | Any | Boolean | Logical OR | false | | Assign | Object | Object.assign | {lb}{rb} | | Endo | Function | compose | identity | | First | Maybe | First Just | Nothing | | Last | Maybe | Last Just | Nothing | | Max | Number | Math.max | -Infinity | | Min | Number | Math.min | Infinity | | Prod | Number | Multiplication | 1 | | Sum | Number | Addition | 0 | [crocks]: ../crocks/index.html [mconcat]: ../functions/helpers.html#mconcat [mreduce]: ../functions/helpers.html#mreduce [mconcatMap]: ../functions/helpers.html#mconcatmap [mreduceMap]: ../functions/helpers.html#mreducemap [Maybe]: ../crocks/Maybe.html [just]: ../crocks/Maybe.html#just [nothing]: ../crocks/Maybe.html#nothing [All]: All.html [Any]: Any.html [Assign]: Assign.html [Endo]: Endo.html [First]: First.html [Last]: Last.html [Max]: Max.html [Min]: Min.html [Prod]: Prod.html [Sum]: Sum.html ","srcFilePath":"src/pages/docs/monoids/index.md","id":"monoids","location":"/docs/monoids/","url":"/crocks/docs/monoids/","childIds":["All","Any","Assign","Endo","First","Last","Max","Min","Prod","Sum"]}},"title":"Documentation","description":"Everything you need to know to get started.","content":" Docs Start learning how to leverage the power of . Choose a Guide Each one provide step by step coverage for every core feature. ","srcFilePath":"src/pages/docs/index.soy","id":"docs","location":"/docs/","url":"/crocks/docs/","childIds":["getting-started","crocks","monoids","functions","search"]}},"childIds":["docs"]},"basePath":"/crocks"}